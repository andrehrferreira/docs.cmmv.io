# Authentication

The ``@cmmv/auth`` module provides a set of features to handle authentication in your application. It supports both HTTP and WebSocket-based authentication and can be easily integrated into any ``@cmmv`` based application.

## Installation

To install the ``@cmmv/auth`` module, run the following command:

```typescript
$ pnpm add @cmmv/auth jsonwebtoken
```

## Integrating 

Once installed, you can integrate the ``@cmmv/auth`` module into your application as shown below. This example demonstrates the basic setup of a CMMV application that includes the ``@cmmv/auth`` module for handling authentication.

```typescript
require('dotenv').config();

import { Application } from '@cmmv/core';
import { ExpressAdapter, ExpressModule } from '@cmmv/http';
import { ProtobufModule } from '@cmmv/protobuf';
import { WSModule, WSAdapter } from '@cmmv/ws';
import { ViewModule } from '@cmmv/view';
...
import { AuthModule } from '@cmmv/auth';

Application.create({
    httpAdapter: ExpressAdapter,
    wsAdapter: WSAdapter,
    modules: [
        ExpressModule,
        ProtobufModule,
        WSModule,
        ViewModule,
        RepositoryModule,
        AuthModule,  // Add the AuthModule 
    ],
    services: [
        // Add your custom services here
    ],
    contracts: [
        // Add your contracts here
    ],
});
```

## Configuration 

The ``.cmmv.config.js`` file is the central configuration file for your CMMV application, which allows you to set up different settings related to the server, authentication, and other modules. Below is a detailed explanation of the configuration options relevant to the ``@cmmv/auth`` module:

```javascript
module.exports = {
    env: process.env.NODE_ENV,

    server: {
        session: {
            enabled: true,  // Enable session support
            options: {
                // Name of the session cookie
                sessionCookieName: 
                    process.env.SESSION_COOKIENAME || "cmmv-session", 
                // Secret for signing the session ID cookie
                secret: process.env.SESSION_SECRET || "secret", 
                // Prevents session being saved back to the session store
                resave: false, 
                // Forces a session to be saved, even if itâ€™s uninitialized
                saveUninitialized: false, 
                cookie: { 
                    // Ensures the browser only sends the cookie over HTTPS
                    secure: true,  
                    // The max age (in milliseconds) for the session cookie
                    maxAge: 60000  
                }
            }
        }
    },

    // Authentication settings for @cmmv/auth
    auth: {
        // Enable local registration (email/password)
        localRegister: true,  
        // Enable local login (email/password)
        localLogin: true,     
        // Secret key for signing JWT tokens
        jwtSecret: process.env.JWT_SECRET || "secret",  
        // Token expiration time in seconds (1 hour)
        expiresIn: 60 * 60,  
        
        google: {
            // Google OAuth client ID
            clientID: process.env.GOOGLE_CLIENT_ID,  
            // Google OAuth client secret
            clientSecret: process.env.GOOGLE_CLIENT_SECRET,  
            // URL to redirect after Google login
            callbackURL: "http://localhost:3000/auth/google/callback"  
        }
    },
};
```

## Generated 

The ``@cmmv/auth`` module is responsible for generating the necessary files for authentication in a CMMV-based application. This includes protocol buffers (proto files), TypeScript definitions, service implementations, and controllers. If the ``@cmmv/ws`` module is installed, it will also generate the WebSocket gateway for handling authentication events. Below are the key components that are generated by this module:

**``src/protos/auth.proto``**

This ``.proto`` file defines the ``User``, ``LoginRequest``, ``LoginResponse``, ``RegisterRequest``, ``RegisterResponse`` messages, and the ``AuthService`` service with two RPC methods, Login and Register.

```proto
// Generated automatically by CMMV

syntax = "proto3";
package auth;

message User {
   string username = 1;
   string password = 2;
   string googleId = 3;
   string groups = 4;
}

message LoginRequest {
    string username = 1;
    string password = 2;
}

message LoginResponse {
    bool success = 1;
    string token = 2;
    string message = 3;
}

message RegisterRequest {
    string username = 1;
    string email = 2;
    string password = 3;
}

message RegisterResponse {
    bool success = 1;
    string message = 3;
}
          
service AuthService {
    rpc Login (LoginRequest) returns (LoginResponse);
    rpc Register (RegisterRequest) returns (RegisterResponse);
}
```

<br/>

**``src/protos/auth.d.ts``**

This file provides TypeScript interfaces that mirror the ``.proto`` definitions, making it easier to work with the data structures in your application.

```typescript
// Generated automatically by CMMV

export namespace User {
    export type username = string;
    export type password = string;
    export type googleId = string;
    export type groups = string;
}

export interface LoginRequest {
    username: string;
    password: string;
}

export interface LoginResponse {
    success: boolean;
    token: string;
    message: string;
}

export interface RegisterRequest {
    username: string;
    email: string;
    password: string;
}

export interface RegisterResponse {
    success: boolean;
    message: string;
}
```

<br/>

**``src/services/auth.services.ts``**

The service handles the core logic for user authentication, such as logging in and registering users. It makes use of class-validator for validation and class-transformer for transforming the incoming data into a User object.

```typescript
// Generated automatically by CMMV
    
import * as jwt from 'jsonwebtoken';
import { validate } from 'class-validator';
import { plainToClass } from 'class-transformer';

import { 
    Telemetry, Service, 
    AbstractService, Config
} from "@cmmv/core";

import { Repository } from '@cmmv/repository';

import { User, IUser } from '../models/user.model';

import { 
    LoginRequest, LoginResponse, 
    RegisterRequest, RegisterResponse 
} from '../protos/auth';

import { UserEntity } from '../entities/user.entity';

@Service("auth")
export class AuthService extends AbstractService {

    public async login(
        payload: LoginRequest, 
        req?: any, res?: any, 
        session?: any
    ): Promise<{ result: LoginResponse, user: any }> {
        Telemetry.start('AuthService::login', req?.requestId);

        const jwtToken = Config.get<string>("auth.jwtSecret");
        const expiresIn = Config.get<number>("auth.expiresIn", 60 * 60);
        const sessionEnabled = Config.get<boolean>(
            "server.session.enabled", true
        );
        const cookieName = Config.get<string>(
            "server.session.options.sessionCookieName", 
            "token"
        );
        const cookieTTL = Config.get<number>(
            "server.session.options.cookie.maxAge", 
            24 * 60 * 60 * 100
        );
        const cookieSecure = Config.get<boolean>(
            "server.session.options.cookie.secure", 
            process.env.NODE_ENV !== 'dev'
        );

        const userValidation = plainToClass(User, payload, { 
            exposeUnsetFields: true,
            enableImplicitConversion: true
        }); 

        const user = await Repository.findBy(UserEntity, userValidation);;

        if (!user) {
            return { result: { 
                success: false, token: "", 
                message: "Invalid credentials" 
            }, user: null  };
        }
            
        const token = jwt.sign({ 
            id: user.id,
            username: payload.username 
        }, jwtToken, { expiresIn });

        res.cookie(cookieName, `Bearer ${token}`, {
            httpOnly: true,
            secure: cookieSecure,
            sameSite: 'strict',
            maxAge: cookieTTL
        });

        if(sessionEnabled){
            session.user = {
                username: payload.username,
                token: token,
            };
    
            session.save();
        }
        
        Telemetry.end('AuthService::login', req?.requestId);        
        return { result: { 
            success: true, token, 
            message: "Login successful" 
        }, user };
    }

    public async register(
        payload: RegisterRequest, req?: any
    ): Promise<RegisterResponse> {
        Telemetry.start('AuthService::register', req?.requestId);
        const jwtToken = Config.get("auth.jwtSecret");

        const newUser = plainToClass(User, payload, { 
            exposeUnsetFields: true,
            enableImplicitConversion: true
        }); 

        const errors = await validate(newUser, { 
            skipMissingProperties: true 
        });
        
        if (errors.length > 0) {
            console.error(errors);
            Telemetry.end('AuthService::register', req?.requestId);
            return { 
                success: false, 
                message: JSON.stringify(errors[0].constraints) 
            };
        } 
        else {    
            try{
                const result = await Repository.insert<UserEntity>(
                    UserEntity, newUser
                );

                Telemetry.end('AuthService::register', req?.requestId);

                return (result) ? 
                    { 
                        success: true, 
                        message: "User registered successfully!" 
                    } : 
                    { 
                        success: false, 
                        message: "Error trying to register new user" 
                    };
            }   
            catch(e){
                console.error(e);
                Telemetry.end('AuthService::register', req?.requestId);
                return { success: false, message: e.message };
            }                                                    
        }
    }
}
```

<br/>

**``src/controllers/auth.controller.ts``**

This controller is responsible for handling authentication-related HTTP requests. It includes endpoints for logging in, registering, and retrieving the current user's information.

```typescript
// Generated automatically by CMMV
    
import { Config } from "@cmmv/core";
import { Auth } from "@cmmv/auth";

import { 
    Controller, Post, Body, Req, 
    Res, Get, Session
} from "@cmmv/http";

import { AuthService } from '../services/auth.service';

import { 
    LoginRequest, LoginResponse, 
    RegisterRequest, RegisterResponse 
} from '../protos/auth';

@Controller("auth")
export class AuthController {
    constructor(private readonly authService: AuthService) {}

    @Get("user")
    @Auth()  // Uses the Auth decorator for authorization
    async user(@Req() req) {
        return req.user;
    }

    @Post("login")
    async login(
        @Body() payload: LoginRequest, 
        @Req() req, @Res() res, @Session() session
    ): Promise<LoginResponse> {
        const { result } = await this.authService.login(
            payload, req, res, session
        );

        return result;
    }

    @Post("register")
    async register(
        @Body() payload: RegisterRequest
    ): Promise<RegisterResponse> {
        return await this.authService.register(payload);
    }
}
```

<br/>

**``src/gateways/auth.gateway.ts``**

When ``@cmmv/ws`` is installed, a WebSocket gateway is generated to handle authentication events in real-time.

```typescript
// Generated automatically by CMMV

import { Rpc, Message, Data, Socket, RpcUtils } from "@cmmv/ws";
import { AuthService } from '../services/auth.service';

import { 
    LoginRequest,
    RegisterRequest  
} from "../protos/auth";

@Rpc("auth")
export class AuthGateway {
    constructor(private readonly authService: AuthService) {}

    @Message("LoginRequest")
    async login(@Data() data: LoginRequest, @Socket() socket) {
        try{
            const { result } = await this.authService.login(data);
            const response = await RpcUtils.pack(
                "auth", "LoginResponse", result
            );

            if(response)
                socket.send(response);            
        }
        catch(e){
            return null;
        }
    }

    @Message("RegisterRequest")
    async register(@Data() data: RegisterRequest, @Socket() socket) {
        try{
            const result = await this.authService.register(data);
            const response = await RpcUtils.pack(
                "auth", "RegisterResponse", result
            );

            if(response)
                socket.send(response);            
        }
        catch(e){
            return null;
        }
    }
}
```

## Decorator 

The ``@Auth`` decorator is designed to enforce authentication and authorization on specific routes within an application. It provides middleware functionality that checks if a user is authenticated by verifying a JWT (JSON Web Token) and optionally validates that the user has the required roles to access the route.

This decorator is used in conjunction with route handlers to protect specific endpoints. It validates the existence of a JWT token and, if provided, checks whether the token's payload includes the necessary roles to access the route.

* **Token Location:** The middleware first checks for the JWT token in the request cookies (using a configurable cookie name) or in the ``Authorization`` header. If no token is found, it returns a ``401 Unauthorized`` response.
* **Token Verification:** If a token is found, it verifies the token using the secret stored in the configuration (``auth.jwtSecret``). If the token is invalid or expired, the middleware returns a ``401 Unauthorized`` response.
* **Role Validation:** If roles are specified, the middleware checks if the token's payload includes the required roles. If the user does not have the appropriate roles, the middleware returns a ``403 Forbidden`` response.
* **User Information:** Upon successful validation, the decoded token (which typically includes user information such as user ID, username, and roles) is attached to the ``req.user`` object for further use in the route handler.

```typescript
import { Controller, Get, Req } from '@cmmv/http';
import { Auth } from '@cmmv/auth';

@Controller('user')
export class UserController {
    // Protects the route, checks for valid JWT
    @Get('profile')
    @Auth()  
    async getProfile(@Req() req) {
        return req.user;  // Access the authenticated user's info
    }

    // Protects the route, checks for valid JWT and admin role
    @Get('admin')
    @Auth(['admin'])  
    async getAdminDashboard(@Req() req) {
        return `Welcome admin ${req.user.username}`;
    }
}
```

<br/>

* **roles?:** (Optional) An array of roles that a user must have to access the route. If no roles are provided, only authentication is required (i.e., a valid JWT). If roles are specified, the user must possess at least one of the provided roles.

```typescript
@Auth(['admin', 'moderator']) 
```

**Configuration Dependencies**

* **JWT Secret:** The decorator uses the secret specified in the configuration (``auth.jwtSecret``) to verify the token.
* **Session Cookie Name:** By default, the token is checked in a cookie with the name specified in ``server.session.options.sessionCookieName``. If no token is found in the cookie, it checks the ``Authorization`` header.

The decorator adds the authentication and authorization middleware to the route's metadata. This middleware is processed before the route handler is executed, ensuring that unauthorized users are blocked before any business logic is reached.