<h1>Singleton</h1><a id="singleton" title="Singleton"></a>
<p>In CMMV, dependency injection was replaced with singleton registries to simplify global services management. In typical dependency injection, you must declare all necessary providers for each module. However, in real-world applications, many modules share common services like cache, queues, or databases. Using singletons allows these services to be instantiated once and accessed globally throughout the application. This reduces complexity, prevents circular dependencies, and ensures a single instance manages its state. Hereâ€™s an example of a globally scoped singleton class implementation:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Singleton</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@cmmv/core&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Scope</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Singleton</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">set</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">boolean</span> {
        <span class="hljs-keyword">const</span> scope = <span class="hljs-title class_">Scope</span>.<span class="hljs-title function_">getInstance</span>();

        <span class="hljs-keyword">if</span> (!scope.<span class="hljs-property">data</span>.<span class="hljs-title function_">has</span>(name)) {
            scope.<span class="hljs-property">data</span>.<span class="hljs-title function_">set</span>(name, data);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">has</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> {
        <span class="hljs-keyword">const</span> scope = <span class="hljs-title class_">Scope</span>.<span class="hljs-title function_">getInstance</span>();
        <span class="hljs-keyword">return</span> scope.<span class="hljs-property">data</span>.<span class="hljs-title function_">has</span>(name);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> get&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>): T | <span class="hljs-literal">null</span> {
        <span class="hljs-keyword">const</span> scope = <span class="hljs-title class_">Scope</span>.<span class="hljs-title function_">getInstance</span>();
        <span class="hljs-keyword">return</span> scope.<span class="hljs-property">data</span>.<span class="hljs-title function_">has</span>(name) ? (scope.<span class="hljs-property">data</span>.<span class="hljs-title function_">get</span>(name) <span class="hljs-keyword">as</span> T) : <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">clear</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-keyword">const</span> scope = <span class="hljs-title class_">Scope</span>.<span class="hljs-title function_">getInstance</span>();
        scope.<span class="hljs-property">data</span>.<span class="hljs-title function_">delete</span>(name);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> addToArray&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: T): <span class="hljs-built_in">boolean</span> {
        <span class="hljs-keyword">const</span> scope = <span class="hljs-title class_">Scope</span>.<span class="hljs-title function_">getInstance</span>();
        <span class="hljs-keyword">const</span> array = scope.<span class="hljs-property">data</span>.<span class="hljs-title function_">get</span>(name) || [];
        
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(array)) {
            array.<span class="hljs-title function_">push</span>(value);
            scope.<span class="hljs-property">data</span>.<span class="hljs-title function_">set</span>(name, array);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> removeFromArray&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: T): <span class="hljs-built_in">boolean</span> {
        <span class="hljs-keyword">const</span> scope = <span class="hljs-title class_">Scope</span>.<span class="hljs-title function_">getInstance</span>();
        <span class="hljs-keyword">const</span> array = scope.<span class="hljs-property">data</span>.<span class="hljs-title function_">get</span>(name);
        
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(array)) {
            <span class="hljs-keyword">const</span> index = array.<span class="hljs-title function_">indexOf</span>(value);

            <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) {
                array.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
                scope.<span class="hljs-property">data</span>.<span class="hljs-title function_">set</span>(name, array);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> getArray&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>): T[] | <span class="hljs-literal">null</span> {
        <span class="hljs-keyword">const</span> scope = <span class="hljs-title class_">Scope</span>.<span class="hljs-title function_">getInstance</span>();
        <span class="hljs-keyword">const</span> array = scope.<span class="hljs-property">data</span>.<span class="hljs-title function_">get</span>(name);

        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(array)) 
            <span class="hljs-keyword">return</span> array <span class="hljs-keyword">as</span> T[];
        
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> getArrayFromIndex&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>): T | <span class="hljs-literal">null</span> {
        <span class="hljs-keyword">const</span> scope = <span class="hljs-title class_">Scope</span>.<span class="hljs-title function_">getInstance</span>();
        <span class="hljs-keyword">const</span> array = scope.<span class="hljs-property">data</span>.<span class="hljs-title function_">get</span>(name);

        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(array) &amp;&amp; array.<span class="hljs-property">length</span> &gt;= index) 
            <span class="hljs-keyword">return</span> array[index] <span class="hljs-keyword">as</span> T;
        
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
}
</code></pre>
<p>In my opinion, using the singleton pattern over NestJS-style dependency injection offers several advantages, particularly for larger applications with many controllers and providers.</p>
<p><strong>Performance:</strong> Singleton instances are created once and reused, reducing the overhead of instantiating services multiple times, which can slow down bootstrapping in NestJS as it resolves dependencies.</p>
<p><strong>Simplified Design:</strong> Global services are readily accessible without requiring explicit injection, minimizing complexity in managing common services (like cache, queues, or databases) across modules.</p>
<p><strong>Avoid Circular Dependencies:</strong> Singletons naturally avoid circular dependency issues because they manage their lifecycle independently, whereas dependency injection systems might struggle when multiple services depend on each other.</p>
<p><strong>Scalability:</strong> As the application grows, using singleton registries streamlines service management. NestJS requires defining global providers or importing modules, which can complicate application scaling and make maintaining a long dependency chain more cumbersome.</p>
<p>In summary, while both approaches have their pros and cons, the singleton model can offer more performance and simplicity, especially for larger, production-heavy applications.</p>
