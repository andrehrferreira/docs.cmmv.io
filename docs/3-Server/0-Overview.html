<h1>Server</h1><a id="server" title="Server"></a>
<p>The <code>@cmmv/server</code> is a minimalistic server written in TypeScript, designed to maintain the same structure and methods as <a href="https://expressjs.com/" target="_blank" rel="nofollow">Express</a>, while addressing performance issues and introducing new features for efficient delivery of components and static files.</p>
<p>This project incorporates code from <a href="https://github.com/expressjs/express" target="_blank" rel="nofollow">Express</a>, <a href="https://github.com/koajs/koa" target="_blank" rel="nofollow">Koa</a>, and <a href="https://github.com/fastify/fastify" target="_blank" rel="nofollow">Fastify</a>, but has been completely rewritten in TypeScript with a focus on modernity and performance. Additionally, it integrates features from Vite to optimize the delivery of components and assets, ensuring a faster and more agile experience for modern applications.</p>
<p>Due to the complexity of the project, it has been separated into another repository <a href="https://github.com/andrehrferreira/cmmv-server" target="_blank" rel="nofollow">cmmv-server monorepo</a>, which contains multiple packages. In addition to the core server, several modules have been implemented, including:</p>
<ul>
<li>body-parser</li>
<li>compression</li>
<li>cookie-parser</li>
<li>cors</li>
<li>etag</li>
<li>helmet</li>
<li>server-static</li>
</ul>
<p>Below, we will discuss each module in more detail.</p>
<p>Currently, the project is in a testing phase and therefore not recommended for production use.</p>
<h2>Features</h2><a id="features" title="Features"></a>
<ul>
<li>Fully rewritten in <strong>TypeScript</strong>.</li>
<li><strong>Dynamic property definitions</strong> (like <code>Object.defineProperty</code>) were removed to avoid serious performance issues.</li>
<li><strong>Fastify-inspired hook system</strong> for flexible request lifecycle management.</li>
<li>Support for <strong>HTTP/2</strong>.</li>
<li>Compression support for <strong>Brotli</strong>, <strong>gzip</strong>, and <strong>deflate</strong>.</li>
<li><strong>ETag</strong> implementation using <strong>FNV-1a</strong>.</li>
<li>Built-in support for cryptographic algorithms such as <strong>MD5</strong>, <strong>SHA-1</strong>, and others from the <code>crypto</code> module.</li>
<li>Superior performance compared to <strong>Koa</strong>, <strong>Hapi</strong>, and <strong>Express</strong>, and ongoing optimization to achieve performance similar to <strong>Fastify</strong>.</li>
<li>Full compatibility with all methods provided by <strong>Express.js</strong>.</li>
</ul>
<h2>Benchmarks</h2><a id="benchmarks" title="Benchmarks"></a>
<p>Below is the current performance comparison result between CMMV and other HTTP server projects in Node.js</p>
<p><code>npm run benchmarks:all</code></p>
<table>
<thead>
<tr>
<th>(index)</th>
<th>Framework</th>
<th>Reqs/s</th>
<th>Total Reqs</th>
<th>Transfer/s</th>
<th>Transfer Total</th>
<th>Latency</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>http</td>
<td>25051</td>
<td>250511</td>
<td>4.25 MB</td>
<td>42.53 MB</td>
<td>300 ms</td>
</tr>
<tr>
<td>1</td>
<td>fastify</td>
<td>23491</td>
<td>234912</td>
<td>3.58 MB</td>
<td>35.84 MB</td>
<td>230 ms</td>
</tr>
<tr>
<td>2</td>
<td>cmmv</td>
<td>21787</td>
<td>217850</td>
<td>3.32 MB</td>
<td>33.24 MB</td>
<td>186 ms</td>
</tr>
<tr>
<td>3</td>
<td>koa</td>
<td>21521</td>
<td>215214</td>
<td>3.59 MB</td>
<td>35.92 MB</td>
<td>264 ms</td>
</tr>
<tr>
<td>4</td>
<td>hapi</td>
<td>16009</td>
<td>160086</td>
<td>3.37 MB</td>
<td>33.74 MB</td>
<td>163 ms</td>
</tr>
<tr>
<td>5</td>
<td>express</td>
<td>6607</td>
<td>66061</td>
<td>1.5 MB</td>
<td>14.99 MB</td>
<td>115 ms</td>
</tr>
</tbody>
</table>
<p>Following the performance test adding <code>json</code>, <code>server static</code>, <code>compression</code> middlewares</p>
<p><code>npm run benchmarks:complex</code></p>
<table>
<thead>
<tr>
<th>(index)</th>
<th>Framework</th>
<th>Reqs/s</th>
<th>Total Reqs</th>
<th>Transfer/s</th>
<th>Transfer Total</th>
<th>Latency</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>fastify</td>
<td>25490</td>
<td>254886</td>
<td>4.28 MB</td>
<td>42.78 MB</td>
<td>286 ms</td>
</tr>
<tr>
<td>1</td>
<td>cmmv</td>
<td>18518</td>
<td>185149</td>
<td>3.23 MB</td>
<td>32.31 MB</td>
<td>179 ms</td>
</tr>
<tr>
<td>2</td>
<td>express</td>
<td>4796</td>
<td>47963</td>
<td>1.19 MB</td>
<td>11.94 MB</td>
<td>226 ms</td>
</tr>
</tbody>
</table>
<h2>Installation</h2><a id="installation" title="Installation"></a>
<p>Install the <code>@cmmv/server</code> package via npm:</p>
<pre><code class="hljs language-bash" lang="bash">$ npm install @cmmv/server @cmmv/server-static @cmmv/body-parser
</code></pre>
<h2>Quick Start</h2><a id="quick-start" title="Quick Start"></a>
<p>Below is a simple example of how to create a new CMMV application:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> cmmv, { json, urlencoded, serverStatic } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@cmmv/server&#x27;</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">cmmv</span>({
    <span class="hljs-comment">/*http2: true,
    https: {
        key: readFileSync(&quot;./cert/private-key.pem&quot;),
        cert: readFileSync(&quot;./cert/certificate.pem&quot;),
        passphrase: &quot;1234&quot;
    }*/</span>
});

app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">serverStatic</span>(<span class="hljs-string">&#x27;public&#x27;</span>));
app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">json</span>({ <span class="hljs-attr">limit</span>: <span class="hljs-string">&#x27;50mb&#x27;</span> }));
app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">urlencoded</span>({ <span class="hljs-attr">limit</span>: <span class="hljs-string">&#x27;50mb&#x27;</span>, <span class="hljs-attr">extended</span>: <span class="hljs-literal">true</span> }));

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-title function_">async</span> (req, res) =&gt; {
    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);
});

app.<span class="hljs-title function_">listen</span>({ <span class="hljs-attr">host</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span> })
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">server</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> addr = server.<span class="hljs-title function_">address</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
        <span class="hljs-string">`Listen on http://<span class="hljs-subst">${addr.address}</span>:<span class="hljs-subst">${addr.port}</span>`</span>,
    );
})
.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(err.<span class="hljs-property">message</span>);
});
</code></pre>
<h2>Application</h2><a id="application" title="Application"></a>
<p>The Application class is central to the <code>@cmmv/server</code> and provides a flexible foundation for managing HTTP/HTTP2 server instances, routing, middleware, and error handling. It is built on top of Node.js’s <code>EventEmitter</code>, and integrates features such as query parsing, content-type parsers, and HTTP method handlers.</p>
<p>This class is responsible for managing the lifecycle of HTTP requests, routing them to the correct handlers, and applying middlewares and hooks (such as pre-parsing, on-request, and error handling). The class also supports customizable settings and error handling mechanisms. Here’s a breakdown of its features:</p>
<p><em><strong>Features:</strong></em></p>
<ul>
<li><strong>HTTP/HTTP2 Support:</strong> The <code>Application</code> class can create either HTTP or HTTP2 servers, supporting both regular and secure requests.</li>
<li><strong>Routing:</strong> Offers full routing capabilities for different HTTP methods (<code>GET</code>, <code>POST</code>, etc.) via the <code>Router</code> class.</li>
<li><strong>Middleware:</strong> Supports chaining middlewares via the <code>use()</code> method, including handling arrays of middlewares.</li>
<li><strong>Error Handling:</strong> Custom error handling through <code>setErrorHandler</code> that allows defining specific error-handling logic.</li>
<li><strong>View Rendering:</strong> Uses the <code>View</code> class for rendering templates. It supports custom view engines that can be registered via <code>app.engine()</code>.</li>
<li><strong>Hooks:</strong> Manages lifecycle hooks like <code>onRequest</code>, <code>preParsing</code>, <code>onError</code>, and more, which can be used to customize request handling.</li>
<li><strong>Configuration Options:</strong> Configurable server settings like timeouts, body limits, and HTTP2 support.</li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Type</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>http2</code></td>
<td>Enables HTTP2 support. When <code>true</code>, the server instance will use HTTP2 for communication.</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>https</code></td>
<td>Configuration for HTTPS (including keys and certificates). Required for secure HTTP2.</td>
<td><code>object</code></td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>connectionTimeout</code></td>
<td>The time (in milliseconds) the server will wait before closing idle connections.</td>
<td><code>number</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>keepAliveTimeout</code></td>
<td>The time (in milliseconds) the server will wait for a keep-alive connection before closing it.</td>
<td><code>number</code></td>
<td><code>72000</code></td>
</tr>
<tr>
<td><code>maxRequestsPerSocket</code></td>
<td>The maximum number of requests allowed per socket.</td>
<td><code>number</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>requestTimeout</code></td>
<td>The time (in milliseconds) the server will wait for the request to complete before timing out.</td>
<td><code>number</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>bodyLimit</code></td>
<td>The maximum size (in bytes) for the request body.</td>
<td><code>number</code></td>
<td><code>1048576</code></td>
</tr>
<tr>
<td><code>maxHeaderSize</code></td>
<td>The maximum size (in bytes) for the request headers.</td>
<td><code>number</code></td>
<td><code>16384</code></td>
</tr>
<tr>
<td><code>insecureHTTPParser</code></td>
<td>Enables the use of an insecure HTTP parser that accepts non-standard HTTP requests.</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>joinDuplicateHeaders</code></td>
<td>Combines duplicate HTTP headers into a single header if set to <code>true</code>.</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>querystringParser</code></td>
<td>Custom query string parsing function. Must be a function if provided.</td>
<td><code>function</code></td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>serverFactory</code></td>
<td>A custom function for creating the server instance, useful for advanced configurations like clustering.</td>
<td><code>function</code></td>
<td><code>undefined</code></td>
</tr>
</tbody>
</table>
<p>This table lists the configuration options available when creating an instance of the <code>Application</code> class, which can be used to fine-tune its behavior for different environments and use cases.</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> cmmv <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@cmmv/server&#x27;</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title function_">cmmv</span>({
    <span class="hljs-attr">http2</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">https</span>: {
        <span class="hljs-attr">key</span>: fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./key.pem&#x27;</span>),
        <span class="hljs-attr">cert</span>: fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./cert.pem&#x27;</span>)
    },
    <span class="hljs-attr">requestTimeout</span>: <span class="hljs-number">30000</span>
});

app.<span class="hljs-title function_">listen</span>({ <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>, <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;0.0.0.0&#x27;</span> });
</code></pre>
<p>This example creates a secure HTTP2 server using the <code>Application</code> class with custom request timeouts and listens on port 8080. The flexibility of the <code>Application</code> class allows for dynamic middleware registration, custom hooks, and full control over server behavior.</p>
<h2>Router</h2><a id="router" title="Router"></a>
<p>The <code>Router</code> class is responsible for defining, registering, and handling routes in the <code>@cmmv/server</code>. It uses the <a href="https://github.com/delvedor/find-my-way" target="_blank" rel="nofollow"><code>find-my-way</code></a> module to manage HTTP method routing, and it provides an abstraction for setting up routes using various HTTP methods (GET, POST, PUT, DELETE, etc.).</p>
<p>By utilizing <code>find-my-way</code>, the <code>Router</code> class ensures efficient routing, supporting features such as route param handling, middleware stacking, and dynamic route resolution. This router supports all major HTTP methods and allows flexible route definitions.</p>
<p>Features of the <code>Router</code>:</p>
<ul>
<li><strong>Route Management:</strong> Allows registering routes for all HTTP methods, including custom methods like <code>BIND</code>, <code>MKCOL</code>, and more.</li>
<li><strong>Middleware Support:</strong> Supports middleware stacking for each route, allowing the addition of multiple handlers per route.</li>
<li><strong>Parameter Handlers:</strong> Provides a mechanism to handle parameters within routes via the <code>param()</code> method, similar to how Express handles route parameters.</li>
<li><strong>Dynamic Path Handling:</strong> Efficiently resolves dynamic paths and can apply multiple middlewares to the same route.</li>
<li><strong>Error Handling:</strong> Includes mechanisms to ensure valid route handlers are defined, with error handling for missing or invalid handlers.</li>
<li><strong>Compatibility:</strong> While it provides an API similar to Express.js for route definitions, it does not depend on Express and operates independently.</li>
</ul>
<p>The <code>find-my-way</code> library is a high-performance HTTP router that matches requests to registered routes. It provides features such as:</p>
<ul>
<li><strong>Dynamic Routing:</strong> Supports dynamic path segments and parameters (e.g., <code>/users/:id</code>).</li>
<li><strong>Multiple Methods:</strong> Routes can be registered for any HTTP method (GET, POST, etc.).</li>
<li><strong>Case Sensitivity:</strong> Routes are case-insensitive by default but can be configured otherwise.</li>
<li><strong>Performance:</strong> Designed for efficiency, it supports fast lookup times for large numbers of routes.</li>
<li><strong>Middleware Stack:</strong> Allows attaching an array of middleware functions to a single route.</li>
</ul>
<p>The Router class provides methods for each HTTP method and allows route definitions. Below is a table summarizing the methods and their functionality:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
<th>Example Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>acl()</code></td>
<td>Registers a route for the ACL method.</td>
<td><code>router.acl('/resources', handler)</code></td>
</tr>
<tr>
<td><code>bind()</code></td>
<td>Registers a route for the BIND method.</td>
<td><code>router.bind('/binding', handler)</code></td>
</tr>
<tr>
<td><code>checkout()</code></td>
<td>Registers a route for the CHECKOUT method.</td>
<td><code>router.checkout('/checkout', handler)</code></td>
</tr>
<tr>
<td><code>connect()</code></td>
<td>Registers a route for the CONNECT method.</td>
<td><code>router.connect('/connect', handler)</code></td>
</tr>
<tr>
<td><code>copy()</code></td>
<td>Registers a route for the COPY method.</td>
<td><code>router.copy('/copy', handler)</code></td>
</tr>
<tr>
<td><code>delete()</code></td>
<td>Registers a route for the DELETE method.</td>
<td><code>router.delete('/resource/:id', handler)</code></td>
</tr>
<tr>
<td><code>get()</code></td>
<td>Registers a route for the GET method. Also registers HEAD by default.</td>
<td><code>router.get('/users', handler)</code></td>
</tr>
<tr>
<td><code>head()</code></td>
<td>Registers a route for the HEAD method.</td>
<td><code>router.head('/headers', handler)</code></td>
</tr>
<tr>
<td><code>link()</code></td>
<td>Registers a route for the LINK method.</td>
<td><code>router.link('/link', handler)</code></td>
</tr>
<tr>
<td><code>lock()</code></td>
<td>Registers a route for the LOCK method.</td>
<td><code>router.lock('/lock', handler)</code></td>
</tr>
<tr>
<td><code>m-search()</code></td>
<td>Registers a route for the M-SEARCH method.</td>
<td><code>router['m-search']('/search', handler)</code></td>
</tr>
<tr>
<td><code>merge()</code></td>
<td>Registers a route for the MERGE method.</td>
<td><code>router.merge('/merge', handler)</code></td>
</tr>
<tr>
<td><code>mkactivity()</code></td>
<td>Registers a route for the MKACTIVITY method.</td>
<td><code>router.mkactivity('/activity', handler)</code></td>
</tr>
<tr>
<td><code>mkcalendar()</code></td>
<td>Registers a route for the MKCALENDAR method.</td>
<td><code>router.mkcalendar('/calendar', handler)</code></td>
</tr>
<tr>
<td><code>mkcol()</code></td>
<td>Registers a route for the MKCOL method.</td>
<td><code>router.mkcol('/col', handler)</code></td>
</tr>
<tr>
<td><code>move()</code></td>
<td>Registers a route for the MOVE method.</td>
<td><code>router.move('/move', handler)</code></td>
</tr>
<tr>
<td><code>notify()</code></td>
<td>Registers a route for the NOTIFY method.</td>
<td><code>router.notify('/notify', handler)</code></td>
</tr>
<tr>
<td><code>options()</code></td>
<td>Registers a route for the OPTIONS method.</td>
<td><code>router.options('/options', handler)</code></td>
</tr>
<tr>
<td><code>patch()</code></td>
<td>Registers a route for the PATCH method.</td>
<td><code>router.patch('/update', handler)</code></td>
</tr>
<tr>
<td><code>post()</code></td>
<td>Registers a route for the POST method.</td>
<td><code>router.post('/submit', handler)</code></td>
</tr>
<tr>
<td><code>propfind()</code></td>
<td>Registers a route for the PROPFIND method.</td>
<td><code>router.propfind('/find', handler)</code></td>
</tr>
<tr>
<td><code>proppatch()</code></td>
<td>Registers a route for the PROPPATCH method.</td>
<td><code>router.proppatch('/patch', handler)</code></td>
</tr>
<tr>
<td><code>purge()</code></td>
<td>Registers a route for the PURGE method.</td>
<td><code>router.purge('/purge', handler)</code></td>
</tr>
<tr>
<td><code>put()</code></td>
<td>Registers a route for the PUT method.</td>
<td><code>router.put('/resource', handler)</code></td>
</tr>
<tr>
<td><code>rebind()</code></td>
<td>Registers a route for the REBIND method.</td>
<td><code>router.rebind('/rebind', handler)</code></td>
</tr>
<tr>
<td><code>report()</code></td>
<td>Registers a route for the REPORT method.</td>
<td><code>router.report('/report', handler)</code></td>
</tr>
<tr>
<td><code>search()</code></td>
<td>Registers a route for the SEARCH method.</td>
<td><code>router.search('/search', handler)</code></td>
</tr>
<tr>
<td><code>source()</code></td>
<td>Registers a route for the SOURCE method.</td>
<td><code>router.source('/source', handler)</code></td>
</tr>
<tr>
<td><code>subscribe()</code></td>
<td>Registers a route for the SUBSCRIBE method.</td>
<td><code>router.subscribe('/subscribe', handler)</code></td>
</tr>
<tr>
<td><code>trace()</code></td>
<td>Registers a route for the TRACE method.</td>
<td><code>router.trace('/trace', handler)</code></td>
</tr>
<tr>
<td><code>unbind()</code></td>
<td>Registers a route for the UNBIND method.</td>
<td><code>router.unbind('/unbind', handler)</code></td>
</tr>
<tr>
<td><code>unlink()</code></td>
<td>Registers a route for the UNLINK method.</td>
<td><code>router.unlink('/unlink', handler)</code></td>
</tr>
<tr>
<td><code>unlock()</code></td>
<td>Registers a route for the UNLOCK method.</td>
<td><code>router.unlock('/unlock', handler)</code></td>
</tr>
<tr>
<td><code>unsubscribe()</code></td>
<td>Registers a route for the UNSUBSCRIBE method.</td>
<td><code>router.unsubscribe('/unsubscribe', handler)</code></td>
</tr>
</tbody>
</table>
<p>Example</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// Initialize router</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();

<span class="hljs-comment">// Register GET route</span>
router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;List of users&#x27;</span>);
});

<span class="hljs-comment">// Register POST route</span>
router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User created&#x27;</span>);
});

<span class="hljs-comment">// Register PUT route</span>
router.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/users/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`User <span class="hljs-subst">${req.params.id}</span> updated`</span>);
});

<span class="hljs-comment">// Register DELETE route</span>
router.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;/users/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`User <span class="hljs-subst">${req.params.id}</span> deleted`</span>);
});
</code></pre>
<p>In this example, the <code>Router</code> class is used to define routes for handling different HTTP methods such as GET, POST, PUT, and DELETE. Each route accepts a request (<code>req</code>) and a response (<code>res</code>), allowing handlers to manage incoming requests and send appropriate responses.</p>
<p>Exemple in Application</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> cmmv <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@cmmv/server&#x27;</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">cmmv</span>();
<span class="hljs-keyword">const</span> host = <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>;
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;

app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;pug&#x27;</span>);

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/view&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) {
    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Hey&#x27;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello there!&#x27;</span> });
});

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-title function_">async</span> (req, res) =&gt; {
    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);
});

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/json&#x27;</span>, <span class="hljs-title function_">async</span> (req, res) =&gt; {
    res.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">hello</span>: <span class="hljs-string">&#x27;world&#x27;</span> });
});

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-title function_">async</span> (req, res) =&gt; {
    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User &#x27;</span> + req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);
});

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-title function_">async</span> (req, res) =&gt; {
    res.<span class="hljs-title function_">json</span>(req.<span class="hljs-property">query</span>);
});

app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/test&#x27;</span>, <span class="hljs-title function_">async</span> (req, res) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">body</span>);
    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);
});

app.<span class="hljs-title function_">listen</span>({ host, port });
</code></pre>
<h2>Static</h2><a id="static" title="Static"></a>
<p>The <code>@cmmv/server-static</code> middleware is used to serve static files from a specified directory or directories. It is designed to handle requests for static content such as HTML, CSS, JavaScript, images, or any other assets. The middleware offers several configuration options for file serving behavior, including caching, compression, custom headers, and more.</p>
<p>Once the middleware is initialized, it listens for requests matching the specified prefix and serves files from the root directory (or multiple directories) as configured.</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Type</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>root</code></td>
<td>Specifies the root directory (or directories) from which static files will be served.</td>
<td><code>string</code> or <code>string[]</code></td>
<td><code>undefined</code> (Required)</td>
</tr>
<tr>
<td><code>prefix</code></td>
<td>URL prefix for serving static files. Files will be served from <code>prefix + path</code> (e.g., <code>/static/myfile.js</code>).</td>
<td><code>string</code></td>
<td><code>'/'</code></td>
</tr>
<tr>
<td><code>maxAge</code></td>
<td>Sets the Cache-Control max-age directive in milliseconds. Determines how long files should be cached by the client.</td>
<td><code>number</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>cacheControl</code></td>
<td>Enables or disables the Cache-Control header. When enabled, cache headers will be automatically set based on the <code>maxAge</code> option.</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>dotfiles</code></td>
<td>Defines how to handle dotfiles (files starting with <code>.</code>). Options are <code>'allow'</code>, <code>'deny'</code>, or <code>'ignore'</code>.</td>
<td><code>'allow'</code>, <code>'deny'</code>, <code>'ignore'</code></td>
<td><code>'allow'</code></td>
</tr>
<tr>
<td><code>serverDotfiles</code></td>
<td>If enabled, the server will serve dotfiles from the root directory.</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>index</code></td>
<td>Specifies the default file to serve when a directory is requested. Can be a string (e.g., <code>'index.html'</code>) or <code>false</code> to disable index file serving.</td>
<td><code>string</code> or <code>boolean</code></td>
<td><code>'index.html'</code></td>
</tr>
<tr>
<td><code>fallthrough</code></td>
<td>When <code>true</code>, allows requests to fall through to the next middleware if a file is not found. If <code>false</code>, a 404 error will be returned.</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>redirect</code></td>
<td>Redirects requests to directories that don’t end with a <code>/</code> by adding a trailing slash.</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>immutable</code></td>
<td>When set to <code>true</code>, serves files with the <code>Cache-Control: immutable</code> directive, indicating that the files will never change.</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>lastModified</code></td>
<td>Enables or disables the Last-Modified header. When enabled, it sets the Last-Modified header based on the file’s last modified time.</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>etag</code></td>
<td>Enables or disables the generation of ETag headers, which can be used for cache validation.</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>extensions</code></td>
<td>File extensions to try when a file is not found (e.g., serving <code>file.html</code> when the request is for <code>file</code>). Can be an array of strings.</td>
<td><code>string[]</code> or <code>boolean</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>acceptRanges</code></td>
<td>Enables support for HTTP range requests, useful for media streaming.</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>preCompressed</code></td>
<td>If <code>true</code>, the middleware will attempt to serve pre-compressed files (e.g., <code>.br</code> or <code>.gz</code> files) if available.</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>allowedPath</code></td>
<td>A function that can be used to filter or restrict access to specific paths. The function receives <code>pathname</code>, <code>root</code>, and <code>req</code> as parameters and returns <code>true</code> to allow the path or <code>false</code> to reject it.</td>
<td><code>Function</code></td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>setHeaders</code></td>
<td>A custom function to set headers for the response. It receives <code>res</code>, <code>path</code>, and <code>stat</code> as parameters and can modify headers before the response is sent.</td>
<td><code>Function</code></td>
<td><code>null</code></td>
</tr>
</tbody>
</table>
<p>This middleware is not compatible with Express because its internal workings differ significantly from Express’s static file server. One major change is the removal of directory listing support. Instead, the middleware verifies existing files and creates routes at the application’s startup, resulting in improved efficiency.</p>
<p>It leverages <a href="https://github.com/fastify/send" target="_blank" rel="nofollow"><code>@fastify/send</code></a> and <a href="https://github.com/fastify/accept-negotiator" target="_blank" rel="nofollow"><code>@fastify/accept-negotiator</code></a> to deliver files efficiently. Additionally, it supports add-ons like <code>@cmmv/etag</code> and <code>@cmmv/compression</code> for enhanced static file delivery, offering cache control through the use of <code>lastModified</code> and <code>ETag</code> headers. These features provide a more optimized and performant static file server compared to traditional approaches.</p>
<h2>JSON</h2><a id="json" title="JSON"></a>
<p>The <code>@cmmv/body-parser</code> middleware in cmmv-server serves as a built-in function designed to handle incoming requests with JSON payloads. Similar to Express, this middleware parses the request body and attaches the parsed data to the <code>req.body</code> object, making it easily accessible for further processing.</p>
<p>This middleware specifically parses JSON data, and only processes requests where the <code>Content-Type: application/json</code> or <code>application/vnd.api+json</code> header matches the specified type option. It supports any Unicode encoding and can automatically inflate compressed requests using gzip or deflate.</p>
<p>After the middleware runs, the parsed JSON data is available in <code>req.body</code>. If there’s no body to parse, the <code>Content-Type</code> doesn’t match, or an error occurs, req.body will be an empty object (<code>{}</code>).</p>
<p>Since <code>req.body</code> is populated from user-provided input, it is important to note that all properties and values in the object are untrusted. They should be carefully validated before being used. For instance, attempting to access <code>req.body.foo.toString()</code> could result in errors if <code>foo</code> is undefined, not a string, or if the <code>toString</code> method has been overridden or replaced by malicious input.</p>
<p>The following table outlines the options available for configuring this middleware, offering customization over its behavior to suit various application needs.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
<th>Type</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>inflate</code></td>
<td>Enables or disables handling deflated (compressed) bodies. When disabled, deflated bodies are rejected.</td>
<td>Boolean</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>limit</code></td>
<td>Controls the maximum request body size. If this is a number, the value specifies the number of bytes; if it is a string, the value is passed to the <code>bytes</code> library for parsing.</td>
<td>Mixed</td>
<td><code>&quot;100kb&quot;</code></td>
</tr>
<tr>
<td><code>reviver</code></td>
<td>The <code>reviver</code> option is passed directly to <code>JSON.parse</code> as the second argument. It allows custom transformation of parsed JSON data. More details can be found in the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#using_the_reviver_parameter" target="_blank" rel="nofollow">MDN documentation on JSON.parse</a>.</td>
<td>Function</td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>strict</code></td>
<td>Enables or disables only accepting arrays and objects as valid JSON. When disabled, the middleware will accept anything that <code>JSON.parse</code> accepts.</td>
<td>Boolean</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>type</code></td>
<td>Determines the media type the middleware will parse. This can be a string, array of strings, or a function. If not a function, the value is passed directly to the <code>type-is</code> library and can be an extension (e.g., <code>json</code>), a MIME type (e.g., <code>application/json</code>), or a wildcard MIME type (e.g., <code>*/json</code>). If a function, it is called as <code>fn(req)</code> and parses when it returns <code>true</code>.</td>
<td>Mixed</td>
<td><code>&quot;application/json&quot;</code></td>
</tr>
<tr>
<td><code>verify</code></td>
<td>If provided, this function is called as <code>verify(req, res, buf, encoding)</code>, where <code>buf</code> is the raw request body. The parsing can be aborted by throwing an error from within this function.</td>
<td>Function</td>
<td><code>undefined</code></td>
</tr>
</tbody>
</table>
<h2>Raw</h2><a id="raw" title="Raw"></a>
<p>This middleware processes incoming request payloads and converts them into a Buffer, leveraging functionality inspired by <code>body-parser</code>. It is designed specifically to handle bodies as Buffers and only processes requests where the <code>Content-Type: application/octet-stream</code> or <code>application/vnd+octets</code> header matches the defined type option.</p>
<p>The parser is capable of handling any Unicode encoding and supports automatic decompression for gzip and deflate encoded requests.</p>
<p>After the middleware runs, a Buffer containing the parsed data is assigned to the <code>req.body</code> property. If no body is found, the <code>Content-Type</code> doesn’t match, or an error occurs, <code>req.body</code> will either default to an empty object ({}) or remain unchanged if another parser has already processed it.</p>
<p>Since <code>req.body</code> is populated based on user input, it is crucial to validate any properties and values before using them. For example, calling <code>req.body.toString()</code> might lead to errors if <code>req.body</code> has been altered by multiple parsers. It is highly recommended to verify that <code>req.body</code> is a Buffer before performing any buffer-specific operations.</p>
<p>The following table provides an overview of the optional configuration options:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
<th>Type</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>inflate</code></td>
<td>Enables or disables handling deflated (compressed) bodies. When disabled, deflated bodies are rejected.</td>
<td>Boolean</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>limit</code></td>
<td>Controls the maximum request body size. If this is a number, it specifies the number of bytes. If it is a string, the value is passed to the <code>bytes</code> library for parsing.</td>
<td>Mixed</td>
<td><code>&quot;100kb&quot;</code></td>
</tr>
<tr>
<td><code>type</code></td>
<td>Determines the media type the middleware will parse. This can be a string, array of strings, or a function. If it’s not a function, it’s passed to the <code>type-is</code> library and can be an extension (e.g., <code>bin</code>), a MIME type (e.g., <code>application/octet-stream</code>), or a wildcard MIME type (e.g., <code>application/*</code>).</td>
<td>Mixed</td>
<td><code>&quot;application/octet-stream&quot;</code></td>
</tr>
<tr>
<td><code>verify</code></td>
<td>A function called as <code>verify(req, res, buf, encoding)</code> where <code>buf</code> is the raw request body and <code>encoding</code> is its encoding. Throwing an error from this function aborts the parsing process.</td>
<td>Function</td>
<td><code>undefined</code></td>
</tr>
</tbody>
</table>
<h2>Text</h2><a id="text" title="Text"></a>
<p>This middleware processes incoming request payloads by converting them into a string, utilizing functionality from the <code>body-parser</code> module.</p>
<p>It provides middleware that parses all bodies as strings, only processing requests where the <code>Content-Type: text/plain</code> header aligns with the specified type. It handles various Unicode encodings and supports automatic decompression of gzip and deflate encodings.</p>
<p>After the middleware runs, a new string representation of the parsed data is assigned to the <code>req.body</code> object. If there is no body to parse, the Content-Type does not match, or an error occurs, <code>req.body</code> will default to an empty object (<code>{}</code>).</p>
<p>Since the structure of req.body is based on user input, it is important to treat it as untrusted. Each property and value must be validated before use. For instance, attempting to call <code>req.body.trim()</code> could lead to errors if req.body is not a string. Therefore, it’s advisable to ensure that <code>req.body</code> is a string before using string methods.</p>
<p>The following table outlines the available configuration options:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
<th>Type</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>defaultCharset</code></td>
<td>Specifies the default character set for the text content when the charset is not included in the <code>Content-Type</code> header of the request.</td>
<td>String</td>
<td><code>&quot;utf-8&quot;</code></td>
</tr>
<tr>
<td><code>inflate</code></td>
<td>Controls whether or not compressed (deflated) request bodies should be handled. If disabled, compressed bodies will be rejected.</td>
<td>Boolean</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>limit</code></td>
<td>Sets the maximum allowed size for the request body. When provided as a number, the value is treated as the number of bytes. If provided as a string, it is parsed using the <code>bytes</code> library.</td>
<td>Mixed</td>
<td><code>&quot;100kb&quot;</code></td>
</tr>
<tr>
<td><code>type</code></td>
<td>Defines the media type the middleware should parse. This option can be a string, an array of strings, or a function. If not a function, the value is passed to the <code>type-is</code> library and can be an extension (e.g., <code>txt</code>), a MIME type (e.g., <code>text/plain</code>), or a wildcard pattern (e.g., <code>text/*</code>). If a function, it is called as <code>fn(req)</code> and the request is parsed if it returns a truthy value.</td>
<td>Mixed</td>
<td><code>&quot;text/plain&quot;</code></td>
</tr>
<tr>
<td><code>verify</code></td>
<td>If provided, this function is invoked as <code>verify(req, res, buf, encoding)</code>, where <code>buf</code> is the raw request body in Buffer form, and <code>encoding</code> is the encoding of the request. Parsing can be stopped by throwing an error within this function.</td>
<td>Function</td>
<td><code>undefined</code></td>
</tr>
</tbody>
</table>
<h2>Urlencoded</h2><a id="urlencoded" title="Urlencoded"></a>
<p>This middleware is designed to parse incoming requests that contain urlencoded payloads. It is based on the functionality provided by body-parser.</p>
<p>The middleware only processes urlencoded bodies, specifically looking for requests where the <code>Content-Type: application/x-www-form-urlencoded</code> header matches the specified type option. This parser accepts bodies encoded in UTF-8 and supports automatic decompression for requests compressed with gzip or deflate.</p>
<p>After the middleware processes a request, it populates the req.body object with the parsed data. If no body is found, the Content-Type doesn’t match, or an error occurs, <code>req.body</code> will be set to an empty object ({}). The object will contain key-value pairs, where values can either be strings or arrays (when extended: false), or any data type (when extended: true).</p>
<p>Since <code>req.body</code> is populated based on user input, it is important to validate all properties and values before using them. For example, calling <code>req.body.foo.toString()</code> might cause errors if foo is not a string, or if it is undefined. Therefore, it is advisable to check the type of <code>req.body</code> values before performing any operations on them.</p>
<p>The following table outlines the available configuration options for the middleware:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
<th>Type</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>extended</code></td>
<td>Allows you to choose between parsing URL-encoded data with the <code>querystring</code> library (when <code>false</code>) or the <code>qs</code> library (when <code>true</code>). The “extended” syntax allows for more complex objects and arrays to be encoded into URL-encoded format.</td>
<td>Boolean</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>inflate</code></td>
<td>Enables or disables support for handling compressed (deflated) request bodies. If disabled, compressed bodies will be rejected.</td>
<td>Boolean</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>limit</code></td>
<td>Sets the maximum allowed size for the request body. If provided as a number, it specifies the number of bytes. If provided as a string, it will be parsed by the <code>bytes</code> library.</td>
<td>Mixed</td>
<td><code>&quot;100kb&quot;</code></td>
</tr>
<tr>
<td><code>parameterLimit</code></td>
<td>Controls the maximum number of parameters that can be present in the URL-encoded data. If the request exceeds this limit, an error will be thrown.</td>
<td>Number</td>
<td><code>1000</code></td>
</tr>
<tr>
<td><code>type</code></td>
<td>Defines which media types the middleware will process. This can be specified as a string, array of strings, or a function. If not a function, this value is passed to the <code>type-is</code> library and can be an extension (e.g., <code>urlencoded</code>), a MIME type (e.g., <code>application/x-www-form-urlencoded</code>), or a wildcard pattern.</td>
<td>Mixed</td>
<td><code>&quot;application/x-www-form-urlencoded&quot;</code></td>
</tr>
<tr>
<td><code>verify</code></td>
<td>A function that is invoked as <code>verify(req, res, buf, encoding)</code>, where <code>buf</code> is the raw request body in Buffer form. Throwing an error from this function will stop the parsing process.</td>
<td>Function</td>
<td><code>undefined</code></td>
</tr>
</tbody>
</table>
