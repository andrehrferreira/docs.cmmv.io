[
    {
        "objectID": "index",
        "url": "/index.html",
        "content": "Contract-Model-Model-View (CMMV) A minimalistic framework for building scalable and modular applications using TypeScript contracts. Introduction CMMV (Contract-Model-Model-View) is a minimalistic framework designed to streamline the development of scalable and modular applications using TypeScript. By combining the power of contracts with a modular architecture, CMMV allows developers to define their entire application structure, from ORM entities to REST controllers and WebSocket endpoints, in a clear and maintainable way. The project is divided into two main components: Core System: The heart of CMMV, written in TypeScript and running on Node.js, is responsible for managing contracts, generating code, integrating with databases, and handling server-side operations. This component handles everything from parsing and code generation to integration with external services like cloud servers and databases. Backend: The CMMV backend is inspired by NestJS in terms of structure and organization, using a similar format of decorators, services, controllers, and other architectural patterns. This allows for a familiar development experience for those who already use NestJS, making it easier to create scalable and organized applications with a modular and object-oriented approach. Some implementations are quite different, especially when it comes to context and the need for dependency injection. Frontend: CMMV utilizes its own reactivity system, inspired by Vue 3 as the base framework. However, in the future, support for other frameworks such as React, Angular, and Vue will be available, even though their use is not recommended due to potential performance reduction and SEO issues. This approach simplifies the process of creating, managing, and deploying applications while offering optimal performance. CMMV draws inspiration from a wide range of technologies and concepts, blending ideas from game development (e.g., Unreal Engine’s Blueprints), component-based architectures (e.g., Delphi), and modern web development practices. It challenges traditional paradigms of web and application development, aiming to make the creation of complex systems as intuitive as possible. This project reflects over 20 years of experience in different languages and frameworks, with influences from Delphi, Unity, Unreal, C#, C++, JavaScript, Node.js, TypeScript, VSCode. We hope you find CMMV as exciting and powerful as we do. It’s the culmination of nearly a decade of work and passion for simplifying and improving the development process. Why CMMV? With over 20 years of experience in the tech industry as a programmer, I’ve developed various systems and projects used by millions of users. In 2020, I was working on my largest project to date, which was built on the following stack: backend using Node.js, TypeScript, NestJS, Nuxt.js, Redis, MongoDB, Elasticsearch, and RabbitMQ; frontend with Vue.js and Tailwind CSS; testing with Mocha, ESLint, and GitLab CI; infrastructure managed with Kubernetes and Nginx, and business intelligence powered by Grafana, Kafka, and IndexDB; along with a Flutter-based mobile app. Let’s dive into the problems we faced in this setup. First, the NestJS API, as more controllers and gateways were added, became increasingly difficult to manage and slowed down significantly, primarily due to dependency injection. Module management turned into a bureaucratic nightmare. Although the final application performed well, development became cumbersome. Furthermore, Nuxt’s SSR (server-side rendering) required integration, which often led to issues due to CORS policies. Communication between applications occurred via HTTP, and although NestJS supported RPC, Nuxt.js required custom proxies to implement WebSockets. Using Protobuf in the frontend presented additional challenges, and generating RPC controllers with Protoc resulted in a bloated codebase, making the application even heavier. Second, Nuxt.js, while capable of SSR, still relied on proxies with APIs to load data since it ran on a Vite-based implementation. Static page generation at scale, with thousands of pages, became an unattainable task. We tried, but the time required for page generation was prohibitive. Using standard SSR, with the proxy API and HTTP+JSON communication, significantly increased the TTFB (Time to First Byte), making optimization challenging. Only by delivering content directly through a CDN could we mitigate these delays, but even then, the page load was too slow for ideal SEO. Additionally, Nuxt.js generated numerous JavaScript bundles and data files to supplement frontend data binding, increasing page load and making SEO optimization a constant battle. It may seem counterintuitive to combine API and SSR into the same application due to competing processes, but consider that it’s much simpler to create a single load balancer that serves both frontend and backend. With direct integration, SSR eliminates latency when fetching data—excellent for reducing page load times and generating static pages. When well-integrated with Redis cache and efficient database queries, SSR can be nearly as fast as pre-rendered static pages. Moreover, this architecture simplifies integrations like internationalization, structured data, and sitemaps, making them much easier to manage and serve. Finally, the reduction in page onload time, which is also considered by search engines, is crucial. While Vue is an excellent tool, componentization in the frontend poses performance challenges due to potential deep coupling between components. Even with state management, critical issues related to element reactivity can lead to cascading update flows, which may either freeze the app or cause infinite loops. Avoiding such pitfalls requires a solid understanding of the underlying framework. Considering all these factors, I created CMMV (Contract-Model-Model-View). Initially, the goal was to develop a complete solution that would meet my development needs while maintaining the familiar syntax of NestJS, Vue, etc., but resolving the problems that have plagued me over the years and hampered development. After considering these factors, I created CMMV (Contract-Model-Model-View). My goal was not to compete with or replace any of the mentioned tools. All the technologies I’ve mentioned are of excellent quality and come highly recommended. They have large communities and are suitable for most projects. However, I had unique challenges in my projects, particularly around handling high volumes of traffic and the need for the best possible SEO performance. Despite my best efforts with my previous stack, the results were still not satisfactory for my specific needs. CMMV was born out of this necessity to address these exceptional requirements. André Ferreira (CEO)",
        "hierarchy": {
            "lvl0": "Introduction",
            "lvl1": "Why CMMV?",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "modules/scheduling",
        "url": "/modules/scheduling.html",
        "content": "Scheduling The @cmmv/scheduling package provides a simple way to schedule tasks in your CMMV application using cron patterns. This module is built using the cron library, and the @Cron decorator allows you to easily schedule methods to run at specific intervals. To install the scheduling module, run the following command: npm install @cmmv/scheduling Usage The @Cron decorator is used to define methods that should be scheduled according to a cron pattern. The scheduling is powered by the cron library, which provides flexible and powerful cron scheduling capabilities. After installing the package, you can use the @Cron decorator and the SchedulingService in your project: import { Cron } from &#x27;@cmmv/scheduling&#x27;; import { Logger } from &#x27;@cmmv/core&#x27;; export class TaskService { private logger: Logger = new Logger(&#x27;TaskService&#x27;); @Cron(&#x27;*/5 * * * * *&#x27;) // Runs every 5 seconds handleTask() { this.logger.log(&#x27;Task executed every 5 seconds&#x27;); } } Setting Ensure that the SchedulingService is initialized during the startup of your application. This will register and start all the scheduled tasks defined with the @Cron decorator. require(&#x27;dotenv&#x27;).config(); import { Application } from &#x27;@cmmv/core&#x27;; import { ExpressAdapter, ExpressModule } from &#x27;@cmmv/http&#x27;; import { WSModule, WSAdapter } from &#x27;@cmmv/ws&#x27;; ... import { SchedulingModule, SchedulingService } from &#x27;@cmmv/scheduling&#x27;; Application.create({ httpAdapter: ExpressAdapter, wsAdapter: WSAdapter, modules: [ ... SchedulingModule ], services: [..., SchedulingService] }); Decorator The @Cron decorator is used to schedule a method to run based on a cron pattern. It accepts a cron expression as its argument, which defines the schedule. @Cron(&#x27;*/5 * * * * *&#x27;) // Runs every 5 seconds handleTask() { this.logger.log(&#x27;Task executed every 5 seconds&#x27;); } The cron patterns follow the standard format used by the cron library: * * * * * * ┬ ┬ ┬ ┬ ┬ ┬ │ │ │ │ │ │ │ │ │ │ │ └ Day of the week (0 - 7) (Sunday=0 or 7) │ │ │ │ └───── Month (1 - 12) │ │ │ └────────── Day of the month (1 - 31) │ │ └─────────────── Hour (0 - 23) │ └──────────────────── Minute (0 - 59) └───────────────────────── Second (0 - 59, optional) Some Sample Cron Patterns Here are a few examples of cron patterns you can use with the @Cron decorator: * * * * * * – Runs every second */5 * * * * * – Runs every 5 seconds 0 0 * * * * – Runs every hour 0 0 12 * * * – Runs every day at noon 0 0 1 1 * – Runs at midnight on January 1st The @cmmv/scheduling module provides a powerful and flexible way to schedule tasks in a CMMV application using cron patterns. The @Cron decorator makes it easy to define when certain methods should run, and the SchedulingService ensures these tasks are properly managed and executed at runtime.",
        "hierarchy": {
            "lvl0": "Scheduling",
            "lvl1": "Usage",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "modules/cache",
        "url": "/modules/cache.html",
        "content": "Cache The @cmmv/cache module integrates with cache-manager to provide in-memory cache management. By default, it includes support for Redis using the @tirke/node-cache-manager-ioredis package, but it also supports other cache stores that are compatible with cache-manager. To install the @cmmv/cache module, use npm: $ npm install @cmmv/cache If you’re planning to use Redis or other stores, you’ll need to install the appropriate package based on the cache store you intend to use. Supported Cache Stores and Drivers cache-manager supports various cache stores, and you can configure your store based on your requirements. Here are the supported stores and their respective drivers: Redis: Github $ npm install @tirke/node-cache-manager-ioredis Memcached: Github $ npm install cache-manager-memcached-store MongoDB: Github $ npm install cache-manager-mongodb Filesystem Binary: Github $ npm install cache-manager-fs-binary Configuration module.exports = { // Other configurations cache: { store: &quot;@tirke/node-cache-manager-ioredis&quot;, getter: &quot;ioRedisStore&quot;, host: &quot;localhost&quot;, port: 6379, ttl: 600 // Cache TTL (Time-to-Live) in seconds }, } store: Defines the cache store type (cache-manager-redis in this case). host: Specifies the Redis host. port: Specifies the Redis port. ttl: Defines the default time-to-live for cache entries (in seconds). To find out all the possible configurations, visit NPM Cache Decorator In this example, we demonstrate how to manually implement caching using the @cmmv/cache module in a controller generated by @cmmv/http. Caching can be added at various levels, including for specific endpoints or manually after certain operations, like adding or updating records. Controller: TaskController is responsible for handling requests related to tasks. Cache Decorator: The @Cache decorator is used to cache responses automatically for GET endpoints. In this case, task:getAll and task:{id} are cached for 300 seconds with compression. CacheService: For POST, PUT, and DELETE operations, the cache is updated or removed manually using the CacheService API. // Generated automatically by CMMV import { Telemetry } from &quot;@cmmv/core&quot;; import { Cache, CacheService } from &quot;@cmmv/cache&quot;; import { Controller, Get, Post, Put, Delete, Queries, Param, Body, Request } from &#x27;@cmmv/http&#x27;; import { TaskService } from &#x27;../services/task.service&#x27;; import { Task } from &#x27;../models/task.model&#x27;; @Controller(&#x27;task&#x27;) export class TaskController { constructor(private readonly taskservice: TaskService) {} // GET All Tasks with Cache @Get() @Cache(&quot;task:getAll&quot;, { ttl: 300, compress: true }) async getAll(@Queries() queries: any, @Request() req): Promise&lt;Task[]&gt; { Telemetry.start(&#x27;TaskController::GetAll&#x27;, req.requestId); let result = await this.taskservice.getAll(queries, req); Telemetry.end(&#x27;TaskController::GetAll&#x27;, req.requestId); return result; } // GET Task by ID with Cache @Get(&#x27;:id&#x27;) @Cache(&quot;task:{id}&quot;, { ttl: 300, compress: true }) async getById(@Param(&#x27;id&#x27;) id: string, @Request() req): Promise&lt;Task&gt; { Telemetry.start(&#x27;TaskController::GetById&#x27;, req.requestId); let result = await this.taskservice.getById(id, req); Telemetry.end(&#x27;TaskController::GetById&#x27;, req.requestId); return result; } // POST (Add Task) and Update Cache @Post() async add(@Body() item: Task, @Request() req): Promise&lt;Task&gt; { Telemetry.start(&#x27;TaskController::Add&#x27;, req.requestId); let result = await this.taskservice.add(item, req); // Cache the result of the newly created task CacheService.set(`task:${result.id}`, JSON.stringify(result), 300); Telemetry.end(&#x27;TaskController::Add&#x27;, req.requestId); return result; } // PUT (Update Task) and Update Cache @Put(&#x27;:id&#x27;) async update( @Param(&#x27;id&#x27;) id: string, @Body() item: Task, @Request() req ): Promise&lt;Task&gt; { Telemetry.start(&#x27;TaskController::Update&#x27;, req.requestId); let result = await this.taskservice.update(id, item, req); // Update the cache with the updated task CacheService.set(`task:${result.id}`, JSON.stringify(result), 300); Telemetry.end(&#x27;TaskController::Update&#x27;, req.requestId); return result; } // DELETE (Remove Task) and Clear Cache @Delete(&#x27;:id&#x27;) async delete( @Param(&#x27;id&#x27;) id: string, @Request() req ): Promise&lt;{ success: boolean, affected: number }&gt; { Telemetry.start(&#x27;TaskController::Delete&#x27;, req.requestId); let result = await this.taskservice.delete(id, req); // Remove the deleted task from the cache CacheService.del(`task:${id}`); Telemetry.end(&#x27;TaskController::Delete&#x27;, req.requestId); return result; } } Caching on GET Requests: Automatic Caching: The @Cache decorator is applied to the getAll and getById methods. Cached results are automatically stored and retrieved based on the key pattern, reducing database load and improving performance. Cache Key: Cache keys are defined as task:getAll for retrieving all tasks, and task:{id} for retrieving a task by ID. TTL (Time-to-Live): The cached results are valid for 300 seconds. Manual Caching for POST, PUT, and DELETE: For POST (creating a new task) and PUT (updating a task), the CacheService.set method is used to manually update the cache with the new or updated task. For DELETE (removing a task), the CacheService.del method is used to remove the corresponding cache entry after the task is deleted. Telemetry: Tracks and logs the execution of each method, useful for performance monitoring. This setup optimizes response time by caching frequently accessed data while ensuring that cache entries are updated or cleared when data is modified. Contract Settings The @cmmv/cache module provides the Cache decorator, which can be applied to any controller, gateway, or specific methods. This decorator is useful for automatically caching responses for specific routes. In the following example, cache properties are added to a contract using the @Contract decorator. This enables caching for the associated controller and gateway routes automatically generated by the transpiler. import { AbstractContract, Contract, ContractField } from &#x27;@cmmv/core&#x27;; @Contract({ controllerName: &#x27;Task&#x27;, protoPath: &#x27;src/protos/task.proto&#x27;, protoPackage: &#x27;task&#x27;, cache: { key: &quot;task:&quot;, // Cache key prefix ttl: 300, // Time-to-live (in seconds) compress: true // Enable compression for stored data } }) export class TasksContract extends AbstractContract { @ContractField({ protoType: &#x27;string&#x27;, unique: true, validations: [ { type: &#x27;IsString&#x27;, message: &#x27;Invalid label&#x27;, }, { type: &#x27;IsNotEmpty&#x27;, message: &#x27;Invalid label&#x27;, }, ], }) label: string; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false, validations: [ { type: &#x27;IsBoolean&#x27;, message: &#x27;Invalid checked type&#x27;, }, ], }) checked: boolean; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false, validations: [ { type: &#x27;IsBoolean&#x27;, message: &#x27;Invalid removed type&#x27;, }, ], }) removed: boolean; } Cache Properties key: A prefix for the cache key. In the example above, it is &quot;task:&quot;. For a getAll request, the cached result will be stored as task:getAll. ttl: The time-to-live for cached data. After 300 seconds, the cache entry will expire. compress: Enables compression of the data before storing it in the cache to reduce memory usage. If you need more advanced caching strategies or custom store integrations, you can customize the cache settings in the .cmmv.config.js file or extend the existing cache functionalities within your project. For example, you could add custom cache strategies like memory caching, database caching, or even multi-level caching. Controllers When the @cmmv/cache module is included in the project, the automatically generated controllers from @cmmv/http are modified to include caching functionalities. The caching configuration is defined directly in the contract using the cache property. Here’s how the controller is altered: import { AbstractContract, Contract, ContractField } from &#x27;@cmmv/core&#x27;; @Contract({ controllerName: &#x27;Task&#x27;, protoPath: &#x27;src/protos/task.proto&#x27;, protoPackage: &#x27;task&#x27;, cache: { key: &quot;task:&quot;, ttl : 300, compress: true } }) export class TasksContract extends AbstractContract { @ContractField({ protoType: &#x27;string&#x27;, unique: true, validations: [ { type: &#x27;IsString&#x27;, message: &#x27;Invalid label&#x27;, }, { type: &#x27;IsNotEmpty&#x27;, message: &#x27;Label cannot be empty&#x27;, }, ], }) label: string; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false, validations: [ { type: &#x27;IsBoolean&#x27;, message: &#x27;Checked value must be a boolean&#x27;, }, ], }) checked: boolean; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false, validations: [ { type: &#x27;IsBoolean&#x27;, message: &#x27;Removed value must be a boolean&#x27;, }, ], }) removed: boolean; } Based on the above contract with cache configuration, the generated controller will include caching logic using the @Cache decorator from @cmmv/cache. Here’s an example of how the controller is generated: // Generated automatically by CMMV import { Telemetry } from &quot;@cmmv/core&quot;; import { Cache, CacheService } from &quot;@cmmv/cache&quot;; import { Controller, Get, Post, Put, Delete, Queries, Param, Body, Request } from &#x27;@cmmv/http&#x27;; import { TaskService } from &#x27;../services/task.service&#x27;; import { Task } from &#x27;../models/task.model&#x27;; @Controller(&#x27;task&#x27;) export class TaskController { constructor(private readonly taskservice: TaskService) {} @Get() @Cache(&quot;task:getAll&quot;, { ttl: 300, compress: true }) async getAll(@Queries() queries: any, @Request() req): Promise&lt;Task[]&gt; { Telemetry.start(&#x27;TaskController::GetAll&#x27;, req.requestId); let result = await this.taskservice.getAll(queries, req); Telemetry.end(&#x27;TaskController::GetAll&#x27;, req.requestId); return result; } @Get(&#x27;:id&#x27;) @Cache(&quot;task:{id}&quot;, { ttl: 300, compress: true }) async getById(@Param(&#x27;id&#x27;) id: string, @Request() req): Promise&lt;Task&gt; { Telemetry.start(&#x27;TaskController::GetById&#x27;, req.requestId); let result = await this.taskservice.getById(id, req); Telemetry.end(&#x27;TaskController::GetById&#x27;, req.requestId); return result; } @Post() async add(@Body() item: Task, @Request() req): Promise&lt;Task&gt; { Telemetry.start(&#x27;TaskController::Add&#x27;, req.requestId); let result = await this.taskservice.add(item, req); CacheService.set(`task:${result.id}`, JSON.stringify(result), 300); Telemetry.end(&#x27;TaskController::Add&#x27;, req.requestId); return result; } @Put(&#x27;:id&#x27;) async update( @Param(&#x27;id&#x27;) id: string, @Body() item: Task, @Request() req ): Promise&lt;Task&gt; { Telemetry.start(&#x27;TaskController::Update&#x27;, req.requestId); let result = await this.taskservice.update(id, item, req); CacheService.set(`task:${result.id}`, JSON.stringify(result), 300); Telemetry.end(&#x27;TaskController::Update&#x27;, req.requestId); return result; } @Delete(&#x27;:id&#x27;) async delete( @Param(&#x27;id&#x27;) id: string, @Request() req ): Promise&lt;{ success: boolean, affected: number }&gt; { Telemetry.start(&#x27;TaskController::Delete&#x27;, req.requestId); let result = await this.taskservice.delete(id, req); CacheService.del(`task:${id}`); Telemetry.end(&#x27;TaskController::Delete&#x27;, req.requestId); return result; } } Cache Decorator: The @Cache decorator is added to methods like getAll and getById based on the cache configuration provided in the contract. This decorator automatically caches the results for the specified time (ttl) and applies compression (compress) if configured. @Cache(&quot;task:getAll&quot;, { ttl: 300, compress: true }): This line configures caching for the getAll method, where the cache key is task:getAll, with a TTL of 300 seconds, and compresses the cached data. Manual Cache Management: In add, update, and delete methods, manual cache management is applied. The CacheService.set and CacheService.del methods are used to update or delete cached data. CacheService.set(&quot;task:{id}&quot;, JSON.stringify(result), 300): Manually sets the cache for a specific task after adding or updating it. CacheService.del(&quot;task:{id}&quot;): Deletes the cache for a specific task after it is deleted. Dynamic Cache Keys: The cache keys are dynamic, as shown in the getById, add, update, and delete methods, where the task ID is part of the cache key. The @cmmv/cache module enhances the generated controllers by adding automatic and manual caching capabilities based on the contract’s cache configuration. The @Cache decorator is applied to methods where needed, and the CacheService is used to manage cache entries for specific tasks or resources. This ensures better performance by reducing redundant database queries or service calls. Gateways When the @cmmv/cache module is present in the project, gateways generated by the @cmmv/ws module are modified to include caching functionality. The cache configuration can be defined in the contract and impacts how RPC messages are handled. Cache Decorator: The @Cache decorator is applied to message handlers in the gateway, enabling automatic caching of responses. The cache key, TTL (time-to-live), and compression options are based on the configuration from the contract. Manual Cache Management: Cache entries are manually updated or deleted when new data is added or modified, ensuring that the cache remains consistent with the latest data. // Generated automatically by CMMV import { Rpc, Message, Data, Socket, RpcUtils } from &quot;@cmmv/ws&quot;; import { plainToClass } from &#x27;class-transformer&#x27;; import { TaskEntity } from &#x27;../entities/task.entity&#x27;; import { Cache, CacheService } from &quot;@cmmv/cache&quot;; // Cache module import { AddTaskRequest, UpdateTaskRequest, DeleteTaskRequest } from &quot;../protos/task&quot;; import { TaskService } from &#x27;../services/task.service&#x27;; @Rpc(&quot;task&quot;) export class TaskGateway { constructor(private readonly taskservice: TaskService) {} @Message(&quot;GetAllTaskRequest&quot;) @Cache(&quot;task:getAll&quot;, { ttl: 300, compress: true }) // Cache decorator async getAll(@Socket() socket) { const items = await this.taskservice.getAll(); const response = await RpcUtils.pack( &quot;task&quot;, &quot;GetAllTaskResponse&quot;, items ); socket.send(response); } @Message(&quot;AddTaskRequest&quot;) async add(@Data() data: AddTaskRequest, @Socket() socket) { const entity = plainToClass(TaskEntity, data.item); const result = await this.taskservice.add(entity); const response = await RpcUtils.pack( &quot;task&quot;, &quot;AddTaskResponse&quot;, { item: result, id: result.id } ); CacheService.set(// Manual cache update `task:${result.id}`, JSON.stringify(result), 300 ); socket.send(response); } @Message(&quot;UpdateTaskRequest&quot;) async update(@Data() data: UpdateTaskRequest, @Socket() socket) { const entity = plainToClass(TaskEntity, data.item); const result = await this.taskservice.update(data.id, entity); const response = await RpcUtils.pack( &quot;task&quot;, &quot;UpdateTaskResponse&quot;, { item: result, id: result.id } ); CacheService.set(// Manual cache update `task:${result.id}`, JSON.stringify(result), 300 ); socket.send(response); } @Message(&quot;DeleteTaskRequest&quot;) async delete(@Data() data: DeleteTaskRequest, @Socket() socket) { const result = (await this.taskservice.delete(data.id)).success; const response = await RpcUtils.pack( &quot;task&quot;, &quot;DeleteTaskResponse&quot;, { success: result, id: data.id } ); CacheService.del(`task:${data.id}`); // Cache deletion socket.send(response); } } Automatic Caching: The @Cache decorator is applied to message handlers to cache responses based on the contract configuration. Manual Cache Management: Cache entries are manually updated or deleted when data is added, updated, or deleted, ensuring consistency. Performance Improvement: Cached responses reduce the need for repeated service calls, improving the performance of RPC interactions.",
        "hierarchy": {
            "lvl0": "Cache",
            "lvl1": "Configuration",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "modules/authentication",
        "url": "/modules/authentication.html",
        "content": "Authentication The @cmmv/auth module provides a set of features to handle authentication in your application. It supports both HTTP and WebSocket-based authentication and can be easily integrated into any @cmmv based application. Installation To install the @cmmv/auth module, run the following command: $ npm install @cmmv/auth Integrating Once installed, you can integrate the @cmmv/auth module into your application as shown below. This example demonstrates the basic setup of a CMMV application that includes the @cmmv/auth module for handling authentication. require(&#x27;dotenv&#x27;).config(); import { Application } from &#x27;@cmmv/core&#x27;; import { ExpressAdapter, ExpressModule } from &#x27;@cmmv/http&#x27;; import { ProtobufModule } from &#x27;@cmmv/protobuf&#x27;; import { WSModule, WSAdapter } from &#x27;@cmmv/ws&#x27;; import { ViewModule } from &#x27;@cmmv/view&#x27;; ... import { AuthModule } from &#x27;@cmmv/auth&#x27;; Application.create({ httpAdapter: ExpressAdapter, wsAdapter: WSAdapter, modules: [ ExpressModule, ProtobufModule, WSModule, ViewModule, RepositoryModule, AuthModule, // Add the AuthModule ], services: [ // Add your custom services here ], contracts: [ // Add your contracts here ], }); Configuration The .cmmv.config.js file is the central configuration file for your CMMV application, which allows you to set up different settings related to the server, authentication, and other modules. Below is a detailed explanation of the configuration options relevant to the @cmmv/auth module: module.exports = { env: process.env.NODE_ENV, server: { session: { enabled: true, // Enable session support options: { // Name of the session cookie sessionCookieName: process.env.SESSION_COOKIENAME || &quot;cmmv-session&quot;, // Secret for signing the session ID cookie secret: process.env.SESSION_SECRET || &quot;secret&quot;, // Prevents session being saved back to the session store resave: false, // Forces a session to be saved, even if it’s uninitialized saveUninitialized: false, cookie: { // Ensures the browser only sends the cookie over HTTPS secure: true, // The max age (in milliseconds) for the session cookie maxAge: 60000 } } } }, // Authentication settings for @cmmv/auth auth: { // Enable local registration (email/password) localRegister: true, // Enable local login (email/password) localLogin: true, // Secret key for signing JWT tokens jwtSecret: process.env.JWT_SECRET || &quot;secret&quot;, // Token expiration time in seconds (1 hour) expiresIn: 60 * 60, google: { // Google OAuth client ID clientID: process.env.GOOGLE_CLIENT_ID, // Google OAuth client secret clientSecret: process.env.GOOGLE_CLIENT_SECRET, // URL to redirect after Google login callbackURL: &quot;http://localhost:3000/auth/google/callback&quot; } }, }; Generated The @cmmv/auth module is responsible for generating the necessary files for authentication in a CMMV-based application. This includes protocol buffers (proto files), TypeScript definitions, service implementations, and controllers. If the @cmmv/ws module is installed, it will also generate the WebSocket gateway for handling authentication events. Below are the key components that are generated by this module: src/protos/auth.proto This .proto file defines the User, LoginRequest, LoginResponse, RegisterRequest, RegisterResponse messages, and the AuthService service with two RPC methods, Login and Register. // Generated automatically by CMMV syntax = &quot;proto3&quot;; package auth; message User { string username = 1; string password = 2; string googleId = 3; string groups = 4; } message LoginRequest { string username = 1; string password = 2; } message LoginResponse { bool success = 1; string token = 2; string message = 3; } message RegisterRequest { string username = 1; string email = 2; string password = 3; } message RegisterResponse { bool success = 1; string message = 3; } service AuthService { rpc Login (LoginRequest) returns (LoginResponse); rpc Register (RegisterRequest) returns (RegisterResponse); } src/protos/auth.d.ts This file provides TypeScript interfaces that mirror the .proto definitions, making it easier to work with the data structures in your application. // Generated automatically by CMMV export namespace User { export type username = string; export type password = string; export type googleId = string; export type groups = string; } export interface LoginRequest { username: string; password: string; } export interface LoginResponse { success: boolean; token: string; message: string; } export interface RegisterRequest { username: string; email: string; password: string; } export interface RegisterResponse { success: boolean; message: string; } src/services/auth.services.ts The service handles the core logic for user authentication, such as logging in and registering users. It makes use of class-validator for validation and class-transformer for transforming the incoming data into a User object. // Generated automatically by CMMV import * as jwt from &#x27;jsonwebtoken&#x27;; import { validate } from &#x27;class-validator&#x27;; import { plainToClass } from &#x27;class-transformer&#x27;; import { Telemetry, Service, AbstractService, Config } from &quot;@cmmv/core&quot;; import { Repository } from &#x27;@cmmv/repository&#x27;; import { User, IUser } from &#x27;../models/user.model&#x27;; import { LoginRequest, LoginResponse, RegisterRequest, RegisterResponse } from &#x27;../protos/auth&#x27;; import { UserEntity } from &#x27;../entities/user.entity&#x27;; @Service(&quot;auth&quot;) export class AuthService extends AbstractService { public async login( payload: LoginRequest, req?: any, res?: any, session?: any ): Promise&lt;{ result: LoginResponse, user: any }&gt; { Telemetry.start(&#x27;AuthService::login&#x27;, req?.requestId); const jwtToken = Config.get&lt;string&gt;(&quot;auth.jwtSecret&quot;); const expiresIn = Config.get&lt;number&gt;(&quot;auth.expiresIn&quot;, 60 * 60); const sessionEnabled = Config.get&lt;boolean&gt;( &quot;server.session.enabled&quot;, true ); const cookieName = Config.get&lt;string&gt;( &quot;server.session.options.sessionCookieName&quot;, &quot;token&quot; ); const cookieTTL = Config.get&lt;number&gt;( &quot;server.session.options.cookie.maxAge&quot;, 24 * 60 * 60 * 100 ); const cookieSecure = Config.get&lt;boolean&gt;( &quot;server.session.options.cookie.secure&quot;, process.env.NODE_ENV !== &#x27;dev&#x27; ); const userValidation = plainToClass(User, payload, { exposeUnsetFields: true, enableImplicitConversion: true }); const user = await Repository.findBy(UserEntity, userValidation);; if (!user) { return { result: { success: false, token: &quot;&quot;, message: &quot;Invalid credentials&quot; }, user: null }; } const token = jwt.sign({ id: user.id, username: payload.username }, jwtToken, { expiresIn }); res.cookie(cookieName, `Bearer ${token}`, { httpOnly: true, secure: cookieSecure, sameSite: &#x27;strict&#x27;, maxAge: cookieTTL }); if(sessionEnabled){ session.user = { username: payload.username, token: token, }; session.save(); } Telemetry.end(&#x27;AuthService::login&#x27;, req?.requestId); return { result: { success: true, token, message: &quot;Login successful&quot; }, user }; } public async register( payload: RegisterRequest, req?: any ): Promise&lt;RegisterResponse&gt; { Telemetry.start(&#x27;AuthService::register&#x27;, req?.requestId); const jwtToken = Config.get(&quot;auth.jwtSecret&quot;); const newUser = plainToClass(User, payload, { exposeUnsetFields: true, enableImplicitConversion: true }); const errors = await validate(newUser, { skipMissingProperties: true }); if (errors.length &gt; 0) { console.error(errors); Telemetry.end(&#x27;AuthService::register&#x27;, req?.requestId); return { success: false, message: JSON.stringify(errors[0].constraints) }; } else { try{ const result = await Repository.insert&lt;UserEntity&gt;( UserEntity, newUser ); Telemetry.end(&#x27;AuthService::register&#x27;, req?.requestId); return (result) ? { success: true, message: &quot;User registered successfully!&quot; } : { success: false, message: &quot;Error trying to register new user&quot; }; } catch(e){ console.error(e); Telemetry.end(&#x27;AuthService::register&#x27;, req?.requestId); return { success: false, message: e.message }; } } } } src/controllers/auth.controller.ts This controller is responsible for handling authentication-related HTTP requests. It includes endpoints for logging in, registering, and retrieving the current user’s information. // Generated automatically by CMMV import { Config } from &quot;@cmmv/core&quot;; import { Auth } from &quot;@cmmv/auth&quot;; import { Controller, Post, Body, Req, Res, Get, Session } from &quot;@cmmv/http&quot;; import { AuthService } from &#x27;../services/auth.service&#x27;; import { LoginRequest, LoginResponse, RegisterRequest, RegisterResponse } from &#x27;../protos/auth&#x27;; @Controller(&quot;auth&quot;) export class AuthController { constructor(private readonly authService: AuthService) {} @Get(&quot;user&quot;) @Auth() // Uses the Auth decorator for authorization async user(@Req() req) { return req.user; } @Post(&quot;login&quot;) async login( @Body() payload: LoginRequest, @Req() req, @Res() res, @Session() session ): Promise&lt;LoginResponse&gt; { const { result } = await this.authService.login( payload, req, res, session ); return result; } @Post(&quot;register&quot;) async register( @Body() payload: RegisterRequest ): Promise&lt;RegisterResponse&gt; { return await this.authService.register(payload); } } src/gateways/auth.gateway.ts When @cmmv/ws is installed, a WebSocket gateway is generated to handle authentication events in real-time. // Generated automatically by CMMV import { Rpc, Message, Data, Socket, RpcUtils } from &quot;@cmmv/ws&quot;; import { AuthService } from &#x27;../services/auth.service&#x27;; import { LoginRequest, RegisterRequest } from &quot;../protos/auth&quot;; @Rpc(&quot;auth&quot;) export class AuthGateway { constructor(private readonly authService: AuthService) {} @Message(&quot;LoginRequest&quot;) async login(@Data() data: LoginRequest, @Socket() socket) { try{ const { result } = await this.authService.login(data); const response = await RpcUtils.pack( &quot;auth&quot;, &quot;LoginResponse&quot;, result ); if(response) socket.send(response); } catch(e){ return null; } } @Message(&quot;RegisterRequest&quot;) async register(@Data() data: RegisterRequest, @Socket() socket) { try{ const result = await this.authService.register(data); const response = await RpcUtils.pack( &quot;auth&quot;, &quot;RegisterResponse&quot;, result ); if(response) socket.send(response); } catch(e){ return null; } } } Decorator The @Auth decorator is designed to enforce authentication and authorization on specific routes within an application. It provides middleware functionality that checks if a user is authenticated by verifying a JWT (JSON Web Token) and optionally validates that the user has the required roles to access the route. This decorator is used in conjunction with route handlers to protect specific endpoints. It validates the existence of a JWT token and, if provided, checks whether the token’s payload includes the necessary roles to access the route. Token Location: The middleware first checks for the JWT token in the request cookies (using a configurable cookie name) or in the Authorization header. If no token is found, it returns a 401 Unauthorized response. Token Verification: If a token is found, it verifies the token using the secret stored in the configuration (auth.jwtSecret). If the token is invalid or expired, the middleware returns a 401 Unauthorized response. Role Validation: If roles are specified, the middleware checks if the token’s payload includes the required roles. If the user does not have the appropriate roles, the middleware returns a 403 Forbidden response. User Information: Upon successful validation, the decoded token (which typically includes user information such as user ID, username, and roles) is attached to the req.user object for further use in the route handler. import { Controller, Get, Req } from &#x27;@cmmv/http&#x27;; import { Auth } from &#x27;@cmmv/auth&#x27;; @Controller(&#x27;user&#x27;) export class UserController { // Protects the route, checks for valid JWT @Get(&#x27;profile&#x27;) @Auth() async getProfile(@Req() req) { return req.user; // Access the authenticated user&#x27;s info } // Protects the route, checks for valid JWT and admin role @Get(&#x27;admin&#x27;) @Auth([&#x27;admin&#x27;]) async getAdminDashboard(@Req() req) { return `Welcome admin ${req.user.username}`; } } roles?: (Optional) An array of roles that a user must have to access the route. If no roles are provided, only authentication is required (i.e., a valid JWT). If roles are specified, the user must possess at least one of the provided roles. @Auth([&#x27;admin&#x27;, &#x27;moderator&#x27;]) Configuration Dependencies JWT Secret: The decorator uses the secret specified in the configuration (auth.jwtSecret) to verify the token. Session Cookie Name: By default, the token is checked in a cookie with the name specified in server.session.options.sessionCookieName. If no token is found in the cookie, it checks the Authorization header. The decorator adds the authentication and authorization middleware to the route’s metadata. This middleware is processed before the route handler is executed, ensuring that unauthorized users are blocked before any business logic is reached.",
        "hierarchy": {
            "lvl0": "Authentication",
            "lvl1": "Installation",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "modules/repository",
        "url": "/modules/repository.html",
        "content": "Repository The @cmmv/repository module is designed to work alongside the @cmmv/core framework and is built using TypeORM. This module automatically generates entities based on defined contracts and extends the service layer for handling CRUD operations with the configured database. Below, we provide detailed information on installation, usage, and features of this module. Installation To use the @cmmv/repository module in your project, you can install it via npm: $ npm install @cmmv/repository In addition to installing the @cmmv/repository module, depending on the database type you are using, you will need to install the respective database driver. Supported Databases and Drivers TypeORM supports multiple database systems, and each system requires the appropriate npm package to function correctly. Here is a list of supported databases along with the corresponding driver to install: SQLite: NPM $ npm install sqlite3 MySQL / MariaDB: NPM $ npm install mysql2 PostgreSQL: NPM $ npm install pg Microsoft SQL Server: NPM $ npm install mssql Oracle: NPM $ npm install oracledb MongoDB: NPM $ npm install mongodb Once you install the module and the corresponding database driver, you can configure your database connection in the .cmmv.config.js file. TypeORM will automatically use the appropriate driver based on the configuration. Purpose The @cmmv/repository module simplifies the process of integrating database entities and services for CRUD operations by leveraging contracts defined using @cmmv/core. It automatically transpiles contracts into TypeORM entities and provides a standardized way to manage interactions with the database. Automatic Entity Generation: Based on the contracts defined in your project, the module transpiles the contract definitions into TypeORM entities. CRUD Service: The module generates CRUD operations for the entities without needing to manually implement services, allowing easy data management. TypeORM Integration: Full integration with TypeORM, making it easier to work with a variety of databases, such as PostgreSQL, MySQL, SQLite, etc. Contract-Based: Using contracts defined with @cmmv/core, the module automatically generates both the database schema and the CRUD service layer. /src/contract/task.contract.ts import { AbstractContract, Contract, ContractField } from &#x27;@cmmv/core&#x27;; @Contract({ controllerName: &#x27;Task&#x27;, protoPath: &#x27;src/protos/task.proto&#x27;, protoPackage: &#x27;task&#x27;, }) export class TasksContract extends AbstractContract { @ContractField({ protoType: &#x27;string&#x27;, unique: true, }) label: string; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false, }) checked: boolean; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false, }) removed: boolean; } This contract defines the fields and structure for the Task entity, which will be transpiled into a database entity by the @cmmv/repository module. Once the contract is defined, the @cmmv/repository module transpiles the contract into a TypeORM entity. Below is an example of an automatically generated entity (task.entity.ts): // Generated automatically by CMMV import { Entity, PrimaryGeneratedColumn, Column, Index } from &#x27;typeorm&#x27;; import { Task } from &#x27;../models/task.model&#x27;; @Entity(&#x27;task&#x27;) @Index(&quot;idx_task_label&quot;, [&quot;label&quot;], { unique: true }) export class TaskEntity implements Task { @PrimaryGeneratedColumn(&#x27;uuid&#x27;) id: string; @Column({ type: &#x27;varchar&#x27; }) label: string; @Column({ type: &#x27;boolean&#x27;, default: false }) checked: boolean; @Column({ type: &#x27;boolean&#x27;, default: false }) removed: boolean; } The @cmmv/repository module also generates a CRUD service that automatically handles interactions with the database. This service will use the entity generated from the contract to provide standard CRUD methods (create, read, update, delete). // Generated automatically by CMMV import { Telemetry } from &quot;@cmmv/core&quot;; import { AbstractService, Service } from &#x27;@cmmv/http&#x27;; import { Repository } from &#x27;@cmmv/repository&#x27;; import { TaskEntity } from &#x27;../entities/task.entity&#x27;; @Service(&quot;task&quot;) export class TaskService extends AbstractService { public override name = &quot;task&quot;; async getAll(queries?: any, req?: any): Promise&lt;TaskEntity[]&gt; { const instance = Repository.getInstance(); const repository = instance.dataSource.getRepository(TaskEntity); Telemetry.start(&#x27;TaskService::GetAll&#x27;, req?.requestId); let result = await repository.find(); Telemetry.end(&#x27;TaskService::GetAll&#x27;, req?.requestId); return result; } async getById(id: string, req?: any): Promise&lt;TaskEntity&gt; { const instance = Repository.getInstance(); const repository = instance.dataSource.getRepository(TaskEntity); Telemetry.start(&#x27;TaskService::GetById&#x27;, req?.requestId); const item = await repository.findOneBy({ id }); Telemetry.end(&#x27;TaskService::GetById&#x27;, req?.requestId); if (!item) throw new Error(&#x27;Item not found&#x27;); return item; } async add(item: Partial&lt;TaskEntity&gt;, req?: any): Promise&lt;TaskEntity&gt; { const instance = Repository.getInstance(); const repository = instance.dataSource.getRepository(TaskEntity); Telemetry.start(&#x27;TaskService::Add&#x27;, req?.requestId); const result = await repository.save(item); Telemetry.end(&#x27;TaskService::Add&#x27;, req?.requestId); return result; } async update( id: string, item: Partial&lt;TaskEntity&gt;, req?: any ): Promise&lt;TaskEntity&gt; { const instance = Repository.getInstance(); const repository = instance.dataSource.getRepository(TaskEntity); Telemetry.start(&#x27;TaskService::Update&#x27;, req?.requestId); await repository.update(id, item); let result = await repository.findOneBy({ id }); Telemetry.end(&#x27;TaskService::Update&#x27;, req?.requestId); return result; } async delete( id: string, req?: any ): Promise&lt;{ success: boolean, affected: number }&gt; { const instance = Repository.getInstance(); const repository = instance.dataSource.getRepository(TaskEntity); Telemetry.start(&#x27;TaskService::Delete&#x27;, req?.requestId); const result = await repository.delete(id); Telemetry.end(&#x27;TaskService::Delete&#x27;, req?.requestId); return { success: result.affected &gt; 0, affected: result.affected }; } } The @cmmv/repository module significantly simplifies database interaction by automatically generating the necessary entities and services based on predefined contracts. With built-in TypeORM integration, this module streamlines CRUD operations, enabling faster development and easier database management. Settings To ensure that the @cmmv/repository module works correctly with your project, you need to define the database configurations in a .cmmv.config.js file. This file serves as the central configuration for your project, including the repository settings for database interaction. module.exports = { // Other project configurations... repository: { type: &quot;sqlite&quot;, database: &quot;./database.sqlite&quot;, synchronize: true, logging: false, }, }; In this example, the module is configured to use SQLite as the database with automatic synchronization enabled. This means that any changes in your entities will automatically be reflected in the database schema without requiring migrations. For a more detailed list of all available configurations, please visit the TypeORM Data Source Options documentation. There, you will find additional options such as: entities: An array of paths or classes to specify which entities TypeORM should manage. migrations: A path to your migration files. cache: Enable caching of queries. username and password: Credentials for connecting to the database (for database types that require authentication). host and port: For specifying the host and port for databases like PostgreSQL, MySQL, etc. To properly configure the @cmmv/repository module, you need to specify your database connection settings in the .cmmv.config.js file. The example provided shows a typical setup using SQLite, but you can adjust the configuration for other databases like PostgreSQL or MySQL. For further details on possible configurations, refer to the TypeORM documentation.",
        "hierarchy": {
            "lvl0": "",
            "lvl1": "Repository",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "view/components",
        "url": "/view/components.html",
        "content": "Components The CMMV framework introduces a simple yet powerful way to integrate server-side rendered (SSR) components, leveraging a syntax similar to Vue.js. With the @cmmv/view module, components can be created in the /public directory and dynamically imported and used in views. This document outlines the full process of setting up SSR components using CMMV, with examples of how to structure templates, styles, scripts, and integration with views. Example &lt;div scope&gt; &lt;ComponentTeste ref=&quot;componentTest&quot; name=&quot;Test&quot;&gt;&lt;/ComponentTeste&gt; &lt;/div&gt; &lt;script s-setup&gt; import ComponentTeste from &quot;@components/component.cmmv&quot;; export default { layout: &quot;default&quot;, components: { ComponentTeste }, data() { return { test: 123 } }, methods: { addTask() { /*...*/ } } } &lt;/script&gt; /public/components/component.cmmv &lt;template&gt; &lt;div&gt;{{ test }}&lt;/div&gt; &lt;button @click=&quot;test++&quot;&gt;Add&lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { test: 123 } }, mounted() { console.log(&quot;Component mounted&quot;); } } &lt;/script&gt; The component syntax is based on Vue.js, supporting lifecycle methods (created, mounted), reactive data, props, and methods. The component can also use scoped styles with SSR capabilities. For a complete example, see CMMV Reactivity Samples. Data In CMMV components, data is a key feature used to define reactive state within the component. The data function returns an object that holds reactive properties, allowing the component to dynamically update the DOM when the data changes. &lt;template&gt; &lt;div&gt;{{ message }}&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { message: &quot;Hello, World!&quot; }; } }; &lt;/script&gt; When properties defined in data are modified, the DOM updates to reflect those changes automatically. This provides a seamless, reactive user experience similar to Vue.js. Props Components can accept props to make them reusable and flexible: &lt;div scope&gt; &lt;ComponentTemplate ref=&quot;comp&quot; :count=&quot;test&quot;&gt;&lt;/ComponentTemplate&gt; &lt;hr/&gt; &lt;div&gt; Root: {{ test }}&lt;br/&gt; Component Ctx: {{ $refs.comp.count }} &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;module&quot;&gt; import { createApp } from &#x27;../src&#x27;; import ComponentTemplate from &#x27;./componentTemplate.cmmv&#x27;; createApp({ components: { ComponentTemplate }, data(){ return { test: 123 } } }).mount(); &lt;/script&gt; /samples/componentTemplate.cmmv Github &lt;template&gt; &lt;div&gt;{{ count }}&lt;/div&gt; &lt;button @click=&quot;addCount()&quot; class=&quot;btnAdd&quot;&gt;Add&lt;/button&gt; &lt;/template&gt; &lt;style scoped&gt; .btnAdd{ border: 1px solid #CCC; } &lt;/style&gt; &lt;script&gt; export default { props: { count: { type: Number, defaultValue: 0 } }, data(){ return { teste: &quot;&quot; } }, created(){ //console.log(&quot;created&quot;) }, mounted(){ //console.log(&quot;mounted&quot;) }, methods: { addCount(){ this.count++; this.emit(&quot;count&quot;, this.count) } } } &lt;/script&gt; Methods In CMMV components, methods are essential for handling user interactions and performing dynamic logic. Methods are defined in the script block of a component and can be used for a wide variety of purposes, such as updating data, making HTTP requests, and triggering other component actions. To define a method in a CMMV component, you include a methods property in the default export. Methods can be directly called from the template using event bindings (e.g., @click). &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;incrementCount&quot;&gt;Add&lt;/button&gt; &lt;p&gt;Count: {{ count }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { count: 0 }; }, methods: { incrementCount() { this.count++; } } }; &lt;/script&gt; Created The created lifecycle hook in CMMV is executed after the component’s instance is created but before it is mounted to the DOM. This is a useful hook for performing logic such as data fetching, initializing variables, or triggering certain actions before the template is rendered. export default { data() { return { message: &quot;Initial Message&quot; }; }, created() { console.log(&quot;Component has been created!&quot;); this.fetchData(); }, methods: { fetchData() { this.message = &quot;Updated Message!&quot;; } } } The created hook provides an early entry point to execute logic before the template is rendered, making it useful for initializing data or state in a component. Mounted The mounted lifecycle hook is executed after the component has been inserted into the DOM. This hook is ideal for actions that require direct interaction with the rendered DOM or for starting processes that rely on the component being present in the document. export default { data() { return { count: 0 }; }, mounted() { console.log(&quot;Component has been mounted!&quot;); this.initializeCounter(); }, methods: { initializeCounter() { // Interact with DOM or start operations setInterval(() =&gt; { this.count++; }, 1000); } } } The mounted hook is essential when you need to ensure that your component is fully loaded into the DOM before interacting with it, making it useful for DOM manipulations, setting up event listeners, or initializing components that rely on third-party libraries or services. Slot Slots in CMMV allow you to pass custom content from the parent scope into the child component. They can be dynamically updated using data from the parent component. &lt;ComponentTemplate ref=&quot;comp&quot; :count=&quot;test&quot;&gt; &lt;template c-slot=&quot;{ count }&quot;&gt; Component value: {{ count }} &lt;/template&gt; &lt;/ComponentTemplate&gt; In this example, the c-slot directive is used to pass the slot content, making the parent’s count data available inside the ComponentTemplate. The parent scope can dynamically change the slot content, reflecting the updated values inside the child component. The slot in the component is rendered like this: &lt;slot :count=&quot;count&quot;&gt;&lt;/slot&gt; Rendering &lt;div ref=&quot;comp&quot; count=&quot;123&quot;&gt; Component value: 123 &lt;/div&gt; Named Slots: Slots can be given names for better organization. Reactivity: Slots update reactively with changes in parent data. Scoped Slots: Scoped slots provide the ability to pass data from the child component to the parent for rendering custom content.",
        "hierarchy": {
            "lvl0": "Components",
            "lvl1": "Example",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "view/styles",
        "url": "/view/styles.html",
        "content": "Styles The new styling feature in @cmmv/view allows developers to define theme-specific styles that can be dynamically switched on the frontend. The system maps JSON files from the /public/styles directory, which contain the style rules, and makes them accessible in the frontend for easy theme management. To create a custom style, define a .style.json file in /public/styles. Each key-value pair represents a style class, and you can create multiple themes by appending a suffix (e.g., .dark) to the keys. docs.style.json { &quot;app&quot;: &quot;bg-gray-200&quot;, &quot;app.dark&quot;: &quot;bg-gray-900&quot;, &quot;title&quot;: &quot;ml-2 text-lg text-slate-800 font-semibold&quot;, &quot;title.dark&quot;: &quot;ml-2 text-lg text-gray-200 font-semibold&quot;, &quot;mainText&quot;: &quot;text-slate-800 relative text-white mb-20 context-html&quot;, &quot;mainText.dark&quot;: &quot;text-gray-200 relative text-white mb-20 context-html&quot;, &quot;sideMenu&quot;: &quot;w-60 fixed z-40 overflow-auto text-slate-800 ...&quot;, &quot;sideMenu.dark&quot;: &quot;w-60 fixed z-40 overflow-auto text-white ...&quot; } Accessing In your HTML, you can access the defined styles by referencing the style file and keys. The styles object is automatically made available, and the theme-specific classes are applied based on the current theme. &lt;div class=&quot;w-60&quot;&gt; &lt;a href=&quot;/&quot; title=&quot;CMMV - Contract Model Model View Framework&quot; class=&quot;text-white ml-4 flex items-center&quot; &gt; &lt;img src=&quot;/assets/favicon/favicon-32x32.png&quot; alt=&quot;CMMV Logo&quot; height=&quot;32&quot; width=&quot;32&quot; &gt; &lt;span :class=&quot;$style.docs.title&quot;&gt;CMMV&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; Switching The system allows switching between themes (e.g., default, dark). When a theme is changed, all relevant classes with the suffix (e.g., .dark) are applied automatically. toggleTheme() { this.$style.switch( (this.$style.theme === &quot;default&quot;) ? &quot;dark&quot; : &quot;default&quot; ); } JSON File Structure: The JSON defines style classes for different components. Theme-specific classes are suffixed with .dark, .light, etc. Frontend Access: Styles are accessed through styles.[filename].[key] in the frontend. Dynamic Switching: Theme switching is done programmatically, and the system handles the replacement of style classes based on the active theme. No Subindices Support: Nested JSON subindices are not supported, meaning that each key-value pair must be a flat entry. Management The theme selection in @cmmv/view is handled automatically by the framework, saving the user’s preference in localStorage and retrieving it upon page load. This enables the system to maintain consistent styling based on the user’s previous choice, without manual intervention. You can check the current theme directly in your template using $style.theme. For example, to integrate with a component like DocSearch that requires a theme setting, you can update the HTML tag with the data-theme attribute: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; :data-theme=&#x27;$style.theme&#x27; scope&gt; &lt;head&gt; &lt;headers/&gt; &lt;/head&gt; &lt;/html&gt; This ensures that the correct theme is applied across components like search bars and other elements that require theme awareness. This implementation of dynamic themes in @cmmv/view provides a streamlined approach to managing multiple themes without needing additional plugins, Tailwind extensions, or complex CSS rules. By utilizing .style.json files, developers can easily define theme-specific styles, reducing the amount of code and ensuring consistent theme switching. While it’s possible to achieve similar results using CSS variables, this method simplifies the process, eliminating the need for custom view logic or CSS management for theme switching, making it intuitive and efficient. Support for Nested Styles: Introducing support for nested JSON indices could allow for more complex style structures and better organization. CSS Variable Integration: An option to integrate with CSS variables can complement the theme system, offering finer control over dynamic theming. Theme Preloading: Allow theme preloading based on system preferences (e.g., dark mode based on OS settings) to enhance user experience. Advanced Animations: Adding built-in transitions for theme switching could improve UX when toggling between light and dark modes. Component In addition to the previously discussed style system, CMMV introduces the $style property within components, allowing scoped styles to be accessed directly. This feature enables developers to define and reference styles within the component’s data model, facilitating style management within templates. &lt;template&gt; &lt;div :class=&quot;$style.themeSwitch.container&quot;&gt;{{ test }}&lt;/div&gt; &lt;button @click=&quot;test++&quot;&gt;Add&lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return { test: 123 } } } &lt;/script&gt; This allows more intuitive style handling, making styles accessible directly within the component context.",
        "hierarchy": {
            "lvl0": "Styles",
            "lvl1": "Accessing",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "view/views",
        "url": "/view/views.html",
        "content": "Views Views in CMMV are HTML files located in the /public/views/ directory, typically with the .html extension. They can either be rendered by controllers or accessed directly based on the URL path. For example, a request to http://localhost:3000/docs will automatically map to /public/views/docs/index.html. The index.html file can also include other views through the include directive, allowing for modular view components. Here is an example of a view structure using the docs section of the application. docs/index.html Code &lt;div id=&quot;app&quot; s:docs=&quot;docs&quot; c-cloak&gt; &lt;nav class=&quot;navbar bg-neutral-800 h-16 top-0 w-full fixed ...&quot; &gt; &lt;div class=&quot;max-w-8xl mx-auto flex container items-center&quot;&gt; &lt;button id=&quot;menu-toggle&quot; class=&quot;text-white text-2xl p-2 lg:hidden ml-2&quot; &gt; &lt;i class=&quot;fa-solid fa-bars&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;div class=&quot;w-60&quot;&gt; &lt;a href=&quot;/&quot; title=&quot;CMMV - Contract Model Model View Framework&quot; class=&quot;text-white ml-4 flex items-center&quot; &gt; &lt;img src=&quot;/assets/favicon/favicon-32x32.png&quot; alt=&quot;CMMV Logo&quot; height=&quot;32&quot; width=&quot;32&quot; class=&quot;w-[32px] h-auto&quot; &gt; &lt;span class=&quot;ml-2 text-lg font-semibold&quot;&gt;CMMV&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;justify-between w-full text mr-2&quot;&gt; &lt;div class=&quot;relative text-right ...&quot;&gt; &lt;div id=&quot;docsearch&quot; class=&quot;dark&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;justify-between align-middle ...&quot;&gt; &lt;a href=&quot;https://github.com/andrehrferreira/cmmv&quot; title=&quot;Github&quot; target=&quot;_blank&quot; class=&quot;text-2xl p-2 hover:text-neutral-300&quot; &gt; &lt;i class=&quot;fa-brands fa-github&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class=&quot;flex flex-wrap mx-auto&quot;&gt; &lt;div id=&quot;sidebar-menu&quot; class=&quot;w-60 fixed z-40 overflow-auto leftbar ...&quot; c-cloak &gt; &lt;!-- include(&#x27;public/views/docs/navbar&#x27;) --&gt; &lt;/div&gt; &lt;div class=&quot;mt-20 ml-64 text-justify relative&quot;&gt; &lt;!-- include(&#x27;public/views/docs/anchors&#x27;); --&gt; &lt;div class=&quot;lg:pl-[19.5rem] m-4 p-4 px-20 max-w-3x1 mx-auto ...&quot; :class=&quot;{&#x27;w-full&#x27;: docs.anchors.length &lt; 3}&quot; &gt; &lt;div class=&quot;relative text-white mb-20 context-html&quot;&gt; &lt;div c-html=&quot;docs.index&quot; s-data=&quot;docs.index&quot;&gt;&lt;/div&gt; &lt;div class=&quot;absolute top-0 right-0&quot;&gt; &lt;a :href=&quot;`https://github.com/...`&quot; target=&quot;_blank&quot; title=&quot;Suggest change&quot; &gt; &lt;i class=&quot;fa-solid fa-pen-to-square fa-lg&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; docs/navbar.html Code &lt;ul class=&quot;p-4 select-none top-16&quot; c-cloak c-show=&quot;docs&quot;&gt; &lt;s-for c-for=&quot;(item, key) in docs.navbar&quot; render-tag=&quot;li&quot;&gt; &lt;div c-show=&quot;item&quot; class=&quot;flex hover:text-blue-700 itemRoot text-white&quot; :id=&quot;item?.name.replace(/\\s/,&#x27;_&#x27;)&quot; :data-opened=&quot;false&quot; @click.stop=&quot;navbar[item?.name.replace(/\\s/, `_`)] = toggle(...&quot;&gt; &lt;div class=&quot;flex flex-1 font-bold ...&quot;&gt; &lt;h3 c-if=&quot;item &amp;&amp; item?.isDir&quot; class=&quot;text-white&quot; &gt;{{ item?.name }}&lt;/h3&gt; &lt;span c-else class=&quot;text-white&quot;&gt;{{ item?.name }}&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;justify-between cursor-pointer&quot; c-if=&quot;item?.isDir&quot;&gt; &lt;i :class=&quot;navbar[item?.name....&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;ul c-if=&quot;item &amp;&amp; item.children &amp;&amp; item.children.length &gt; 0&quot; :id=&quot;`${item?.name.replace(/\\s/, `_`)}_contents`&quot; class=&quot;p-4 py-1 text-md mb-4&quot; :style=&quot;(navbar[item?.name.replace(/\\s/, `_`)]) ? &#x27;&#x27; : ...&quot;&gt; &lt;li c-for=&quot;(child) in item.children&quot;&gt; &lt;div class=&quot;hover:text-...&quot; style=&quot;font-size: 12px&quot;&gt; &lt;a :href=&quot;child.uri&quot; class=&quot;text-base&quot;&gt;{{ child.name }}&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/s-for&gt; &lt;/ul&gt; Views are mapped based on the URL path. When a request is made to a specific path like /docs, the system automatically looks for /public/views/docs/index.html. If found, it is rendered; otherwise, a 404 error is returned. Include Directive The include directive allows the inclusion of other view files, enabling modularity in views. For example, docs/index.html includes docs/navbar.html using: &lt;!-- include(&#x27;public/views/docs/navbar&#x27;) --&gt; This approach lets you reuse components like headers, footers, and sidebars across different views. Setup and Data Binding View components can be controlled using the s-setup directive. However, at the moment, only the index.html (or root view) can use the s-setup tag for setting up scripts, meta tags, or other configurations. Any setups added in subcomponents are ignored. This means that data or configurations must be passed from the top-level view. Exemple: &lt;script s-setup&gt; export default { layout: &quot;default&quot;, data(){ return { navbar: [] } }, async mounted() { this.loadState(); }, methods: { loadState(){ this.navbar = JSON.parse( localStorage.getItem(&#x27;navbarState&#x27;) ) || {}; return this.navbar; }, saveState(state) { localStorage.setItem(&#x27;navbarState&#x27;, JSON.stringify(state)); }, toggle(isOpened, itemName) { isOpened = !isOpened; const currentState = this.loadState(); currentState[itemName] = isOpened; this.saveState(currentState); return isOpened; } } } &lt;/script&gt; CMMV introduces a concept of setup scripts in the views, similar to what you may find in frameworks like Vue.js and Nuxt.js. This concept allows dynamic configuration of headers, structured data, and enables binding data to the frontend. Additionally, setup scripts provide lifecycle hooks, such as mounted and created, which are executed when the frontend is loaded. Dynamic Layout The layout property allows you to specify the layout that the view will use. In this example, the layout is set to &quot;default&quot;, meaning the view will inherit and render within a base layout, often defined in /public/templates. layout: &quot;default&quot; Lifecycle Hooks CMMV’s setup scripts provide lifecycle hooks similar to Vue.js. These lifecycle hooks allow you to control code execution at different stages of the component’s lifecycle: mounted: Runs when the view is fully mounted on the DOM. Typically used for tasks like DOM manipulation or API requests. created: Can be used to execute code as soon as the view is created, before it is mounted to the DOM. async mounted() { this.loadState(); } Data Property You can define the data() function to return an object that holds reactive data, which can be bound to the view. This data will be automatically updated when modified. data() { return { navbar: [] } } In this example, navbar is initialized as an empty array and is later populated using the loadState() method. Methods Setup scripts allow the inclusion of methods that are accessible in the view’s scope. These methods are incorporated into the framework’s context and can be used within the template or as event handlers for UI interactions. methods: { loadState() { this.navbar = JSON.parse(localStorage.getItem(&#x27;navbarState&#x27;)) || {}; return this.navbar; }, saveState(state) { localStorage.setItem(&#x27;navbarState&#x27;, JSON.stringify(state)); }, toggle(isOpened, itemName) { isOpened = !isOpened; const currentState = this.loadState(); currentState[itemName] = isOpened; this.saveState(currentState); return isOpened; } } Headers The setup script can also be used to dynamically configure headers and scripts for the view. By using properties like head, you can define meta tags, links (e.g., for stylesheets), and other elements dynamically: head: { meta: [ { name: &quot;description&quot;, content: &quot;CMMV Todolist sample&quot; }, { name: &quot;keywords&quot;, content: &quot;cmmv, contract model, websocket&quot; } ], link: [ { rel: &quot;stylesheet&quot;, href: &quot;/assets/styles/todo.css&quot; }, { rel: &quot;canonical&quot;, href: &quot;https://cmmv.io&quot; }, ] } Data Binding The setup provides data and methods that are directly accessible for data binding on the frontend. This allows seamless interaction with UI components and dynamic updates. For example: &lt;div c-html=&quot;docs.index&quot; s-data=&quot;docs.index&quot;&gt;&lt;/div&gt; This binds the docs.index content to the HTML, enabling dynamic rendering based on the state of docs.index.",
        "hierarchy": {
            "lvl0": "Views",
            "lvl1": "Include Directive",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "view/templates",
        "url": "/view/templates.html",
        "content": "Templates CMMV provides a flexible templating system, allowing you to configure master page templates for modular views. This setup helps create reusable layouts across your application, streamlining the structure and ensuring consistency in specific views. A master page template defines the base HTML layout of your views and is stored in the /public/templates directory. It serves as a foundation where dynamic content, headers, and scripts are injected. The structure follows a consistent format that looks like this: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; data-theme=&#x27;dark&#x27; class=&quot;dark&quot;&gt; &lt;head&gt; &lt;headers/&gt; &lt;/head&gt; &lt;body scope&gt; &lt;slot/&gt; &lt;scripts/&gt; &lt;/body&gt; &lt;/html&gt; Key Elements &lt;headers/&gt; Tag: This tag is used to inject all processed headers from the @cmmv/view module, which may include metadata, stylesheets, and other elements configured within your views or globally. These headers come from your .cmmv.config.js or from custom settings defined in each view. &lt;slot/&gt; Tag: The &lt;slot/&gt; element acts as a placeholder for the main content of your view. When rendering a view, the content of that view is dynamically injected into the slot. &lt;scripts/&gt; Tag: This tag handles the inclusion of JavaScript files configured in your .cmmv.config.js or directly within the view itself. This ensures that all required client-side scripts are included in the final rendering of the page. Other Custom Tags: Any additional tags or attributes you define in your template will be preserved during the rendering process. Ensure that all external resources (links, scripts) include the nonce=&quot;{ nonce }&quot; attribute or s-attr=&quot;nonce&quot; for security, as required by the Content Security Policy (CSP) settings in CMMV. All master page templates are stored in the /public/templates directory. Here’s an example of a possible directory structure: /public /templates /default.html /admin.html /dashboard.html Defining a View In your view, you can configure which master template to use. This is done in the s-setup section of the view. Here’s an example of a view configuration that uses a custom layout and injects scripts: &lt;script s-setup&gt; export default { layout: &quot;admin&quot;, // Reference to the /public/templates/admin.html file head: { meta: [ { name: &quot;description&quot;, content: &quot;Admin Panel&quot; }, { name: &quot;keywords&quot;, content: &quot;admin, cmmv, dashboard&quot; } ], link: [ { rel: &quot;stylesheet&quot;, href: &quot;/assets/styles/admin.css&quot; }, { rel: &quot;canonical&quot;, href: &quot;https://admin.cmmv.io&quot; } ] }, scripts: [ { src: &quot;/assets/js/admin-dashboard.js&quot;, async: true } ] } &lt;/script&gt; The .cmmv.config.js file allows you to manage global JavaScript and stylesheets that should be included in your views. These will be injected into the &lt;scripts/&gt; and &lt;headers/&gt; tags of your master templates. Example .cmmv.config.js: module.exports = { headers: { &quot;Content-Security-Policy&quot;: [ &quot;default-src &#x27;self&#x27;&quot;, &quot;script-src &#x27;self&#x27; &#x27;unsafe-eval&#x27;&quot;, &quot;style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;&quot;, &quot;font-src &#x27;self&#x27;&quot;, &quot;connect-src &#x27;self&#x27;&quot;, &quot;img-src &#x27;self&#x27; data:&quot; ] }, assets: { scripts: [ { src: &quot;/assets/js/main.js&quot;, async: true }, { src: &quot;/assets/js/extra.js&quot;, defer: true } ], styles: [ { rel: &quot;stylesheet&quot;, href: &quot;/assets/css/main.css&quot; } ] } }; After setting up a view with a master template, the rendered page might look like this: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; data-theme=&#x27;dark&#x27; class=&quot;dark&quot;&gt; &lt;head&gt; &lt;meta name=&quot;description&quot; content=&quot;Admin Panel&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;admin, cmmv, dashboard&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/styles/admin.css&quot; nonce=&quot;a1b2c3&quot; /&gt; &lt;link rel=&quot;canonical&quot; href=&quot;https://admin.cmmv.io&quot; /&gt; &lt;/head&gt; &lt;body scope&gt; &lt;!-- Main content of the view --&gt; &lt;div id=&quot;dashboard&quot;&gt; &lt;h1&gt;Welcome to the Admin Dashboard&lt;/h1&gt; &lt;/div&gt; &lt;!-- Scripts --&gt; &lt;script src=&quot;/assets/js/admin-dashboard.js&quot; async nonce=&quot;a1b2c3&quot; &gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; In CMMV, you can modularize your views by defining master page templates located in /public/templates. These templates handle the injection of headers, dynamic content, and scripts through the &lt;headers/&gt;, &lt;slot/&gt;, and &lt;scripts/&gt; tags, respectively. By ensuring that security protocols are maintained with attributes like nonce=&quot;{ nonce }&quot;, your application remains secure while serving assets efficiently. Through this approach, you can create reusable layouts and maintain consistency across different sections of your application, enhancing both development speed and maintainability.",
        "hierarchy": {
            "lvl0": "Templates",
            "lvl1": "Key Elements",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "view/assets",
        "url": "/view/assets.html",
        "content": "Assets In CMMV, it is recommended that all static files, such as JavaScript libraries, CSS, fonts, and images, are served through a Content Delivery Network (CDN). CDNs are optimized for fast and efficient delivery of assets, reducing latency and improving the user experience. However, if you choose to serve these files directly from your application, they must be placed in the /public directory. The @cmmv/http module automatically looks for and serves static files from this directory. If you choose not to use a CDN, place all your static files under the /public directory. This is the directory where @cmmv/http will automatically serve static files like: Bundle By default, the application will generate complementary files, resulting in a final bundle that is necessary if you are using RPC and frontend reactivity. This bundle will be created as /assets/bundle.min.js and must be included in your HTML or template files to ensure the frontend functions correctly. Example .cmmv.config.js Configuration for Assets: module.exports = { ... scripts: [ { type: &quot;text/javascript&quot;, src: &quot;/assets/bundle.min.js&quot;, defer: &quot;defer&quot; }, ... ] }; If you are serving assets locally, ensure your /public directory is structured as follows: /public /assets /styles.css /app.min.js /bundle.min.js /images /logo.png /fonts /custom-font.woff2 /favicon.ico /robots.txt /sitemap.xml /service-worker.js When using these assets in your HTML or templates, you can include the JavaScript bundle and any other static files like this: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;CMMV App&lt;/title&gt; &lt;!-- Include Styles --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/styles.css&quot;&gt; &lt;!-- Favicon --&gt; &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- App Content --&gt; &lt;!-- Include the Bundle --&gt; &lt;script src=&quot;/assets/bundle.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; In CMMV, managing assets is streamlined by recommending the use of CDNs for static files. However, if serving these assets directly from the application, placing them in the /public directory will allow @cmmv/http to handle them automatically. Additionally, the application will generate the necessary frontend bundles for handling reactivity and RPC features, available as /assets/bundle.min.js. All static files are easily accessible from this directory, ensuring a seamless integration with your application.",
        "hierarchy": {
            "lvl0": "Assets",
            "lvl1": "Bundle",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "view/headers",
        "url": "/view/headers.html",
        "content": "Headers In CMMV, you can configure response headers to enhance security, define metadata, or customize the behavior of your web application. This can be achieved in two ways: using the .cmmv.config.js file located in the root of your project or by adding specific configurations directly into the template files for more granular control. The .cmmv.config.js file serves as the global configuration file for your CMMV project. You can set default headers that will apply to all responses from your application by defining the headers object in this file. For example, to configure a Content-Security-Policy and other security-related headers, your .cmmv.config.js might look like this: module.exports = { headers: { &quot;Content-Security-Policy&quot;: [ &quot;default-src &#x27;self&#x27;&quot;, &quot;script-src &#x27;self&#x27; &#x27;unsafe-eval&#x27;&quot;, &quot;style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;&quot;, &quot;font-src &#x27;self&#x27;&quot;, &quot;connect-src &#x27;self&#x27;&quot;, &quot;img-src &#x27;self&#x27; data:&quot; ], &quot;X-Frame-Options&quot;: &quot;DENY&quot;, &quot;X-Content-Type-Options&quot;: &quot;nosniff&quot;, &quot;Referrer-Policy&quot;: &quot;no-referrer&quot;, &quot;Strict-Transport-Security&quot;: &quot;max-age=31536000; ...&quot; } } For more specific configurations, such as adding metadata or setting headers that only apply to a particular route, you can define these directly in your Vue-style template files. In the template’s &lt;script&gt; block, under head, you can configure meta tags, link tags, and other headers: &lt;script s-setup&gt; export default { layout: &quot;default&quot;, head: { meta: [ { name: &quot;description&quot;, content: &quot;CMMV Todolist sample&quot; }, { name: &quot;keywords&quot;, content: &quot;cmmv, contract model, websocket&quot; } ], link: [ { rel: &quot;stylesheet&quot;, href: &quot;/assets/styles/todo.css&quot; }, { rel: &quot;canonical&quot;, href: &quot;https://cmmv.io&quot; }, ], script: [ { src: &quot;https://cdn.jsdelivr.net/npm/some-lib.js&quot;, async: true } ] } ... } &lt;/script&gt; meta: Adds or overrides meta tags in the page’s head, including those for description, keywords, and Content-Security-Policy. link: Used to include external resources like stylesheets or canonical URLs for SEO. script: Enables you to include additional scripts with custom attributes like async or defer. By configuring headers both globally and at the template level, you have full control over the behavior, security, and SEO optimization of your CMMV application. HTTP Module The @cmmv/http module provides an automatic way to manage and optimize the headers that are sent with HTTP responses, reducing the size of unnecessary headers based on the request type (e.g., GET, POST, PUT, or DELETE requests). This built-in functionality ensures that only relevant headers are included, minimizing overhead and improving performance. if (req.method === &#x27;GET&#x27;) { res.setHeader( &#x27;Strict-Transport-Security&#x27;, &#x27;max-age=15552000; includeSubDomains&#x27;, ); res.setHeader(&#x27;X-Content-Type-Options&#x27;, &#x27;nosniff&#x27;); res.setHeader(&#x27;X-Frame-Options&#x27;, &#x27;SAMEORIGIN&#x27;); res.setHeader(&#x27;X-XSS-Protection&#x27;, &#x27;0&#x27;); } Strict-Transport-Security: Ensures that the browser only communicates with the server over HTTPS for the next 180 days (15552000 seconds) and applies this policy to all subdomains. X-Content-Type-Options: Prevents browsers from interpreting files as a different MIME type, which can help prevent attacks. X-Frame-Options: Protects the site from clickjacking attacks by only allowing it to be displayed in a frame of the same origin. X-XSS-Protection: Disables XSS filtering to avoid potential browser-level issues. POST, PUT, DELETE Requests: For these types of requests, the module removes specific headers that are not necessary for write operations, ensuring smaller and more efficient responses. if ([&#x27;POST&#x27;, &#x27;PUT&#x27;, &#x27;DELETE&#x27;].includes(req.method)) { res.removeHeader(&#x27;X-DNS-Prefetch-Control&#x27;); res.removeHeader(&#x27;X-Download-Options&#x27;); res.removeHeader(&#x27;X-Permitted-Cross-Domain-Policies&#x27;); res.removeHeader(&#x27;Strict-Transport-Security&#x27;); res.removeHeader(&#x27;Content-Security-Policy&#x27;); res.removeHeader(&#x27;Cross-Origin-Opener-Policy&#x27;); res.removeHeader(&#x27;Cross-Origin-Resource-Policy&#x27;); res.removeHeader(&#x27;Origin-Agent-Cluster&#x27;); res.removeHeader(&#x27;Referrer-Policy&#x27;); } X-DNS-Prefetch-Control: Reduces DNS prefetching, which is not needed in POST requests. X-Download-Options: Typically used for file downloads; unnecessary for most write operations. X-Permitted-Cross-Domain-Policies: Restricts which domain policies are sent, but not required for write operations. Strict-Transport-Security: Removed in write requests to allow more flexibility in transport for sensitive operations. Content-Security-Policy: Temporarily disabled for certain write requests. Cross-Origin-Opener-Policy: Removed to allow more flexibility when interacting with cross-origin content. Cross-Origin-Resource-Policy: Ensures more open policies for resource sharing during POST, PUT, or DELETE requests. Origin-Agent-Cluster: Removes restrictions on the agent’s ability to share resources across origins. Referrer-Policy: Not needed for write operations, removed to reduce header size. The @cmmv/http module intelligently manages headers to optimize performance, especially for write operations (POST, PUT, DELETE). For read-only operations (GET), it ensures strong security by setting appropriate headers. This approach reduces the amount of unnecessary data sent with each request, while still adhering to best practices in web security. Additional Modules The @cmmv/http module integrates several essential middleware components to further enhance security, session management, and overall performance. These include cors, helmet, session, and compression, which modify headers and handle certain aspects of HTTP communication. CORS Controls access to resources from different origins by setting appropriate CORS (Cross-Origin Resource Sharing) headers. Effect on Headers: Access-Control-Allow-Origin: Specifies which origins can access the server. Access-Control-Allow-Methods: Lists allowed HTTP methods (e.g., GET, POST). Access-Control-Allow-Headers: Indicates which headers can be used during the actual request. Access-Control-Allow-Credentials: Indicates whether the response to the request can be exposed to the client. Helmet Helmet helps secure the application by setting various HTTP headers that protect against common attacks. Effect on Headers: Content-Security-Policy: Restricts the sources from which the browser can load resources. X-DNS-Prefetch-Control: Disables DNS prefetching to reduce privacy leakage. X-Frame-Options: Protects against clickjacking by controlling whether the page can be embedded in a frame. X-Permitted-Cross-Domain-Policies: Controls Adobe Flash and PDF cross-domain policies. Strict-Transport-Security: Forces secure (HTTPS) connections. X-Download-Options: Prevents browsers from downloading files from your website without authorization. Referrer-Policy: Controls how much referrer information is included with requests. Session Manages user sessions via cookies, storing user authentication state and other session data. Set-Cookie: Sets the session cookie with attributes like HttpOnly, Secure, SameSite, etc. Compression Compresses the HTTP responses using Gzip or Brotli to reduce the size of the response body, speeding up the transmission. Effect on Headers: Content-Encoding: Specifies the type of compression used (e.g., gzip, br). Vary: Instructs the browser to vary the response based on the Accept-Encoding header, which allows the server to return different content based on the client’s compression capabilities. The .cmmv.config.js file in the root of the project allows developers to define and customize security policies, session management, CORS settings, and compression options. These configurations will automatically modify the response headers to meet security and performance requirements. Example .cmmv.config.js Configuration: module.exports = { headers: { &quot;Content-Security-Policy&quot;: [ &quot;default-src &#x27;self&#x27;&quot;, &quot;script-src &#x27;self&#x27; &#x27;unsafe-eval&#x27;&quot;, &quot;style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;&quot;, &quot;font-src &#x27;self&#x27;&quot;, &quot;connect-src &#x27;self&#x27;&quot;, &quot;img-src &#x27;self&#x27; data:&quot; ] }, cors: { origin: &quot;https://example.com&quot;, methods: [&quot;GET&quot;, &quot;POST&quot;], credentials: true }, helmet: { contentSecurityPolicy: { directives: { defaultSrc: [&quot;&#x27;self&#x27;&quot;], scriptSrc: [&quot;&#x27;self&#x27;&quot;, &quot;https://cdn.jsdelivr.net&quot;], styleSrc: [&quot;&#x27;self&#x27;&quot;, &quot;&#x27;unsafe-inline&#x27;&quot;] } } }, session: { secret: &quot;my-secret-key&quot;, resave: false, saveUninitialized: false, cookie: { secure: true, httpOnly: true, sameSite: &#x27;lax&#x27; } }, compression: { level: 6, threshold: 1024 } }; Header Customization The headers can also be set or modified directly within the template setup using the head property. This provides flexibility to add meta tags, canonical links, and other SEO-related settings dynamically per page. &lt;script s-setup&gt; export default { layout: &quot;default&quot;, head: { meta: [ { name: &quot;description&quot;, content: &quot;CMMV Todolist sample&quot; }, { name: &quot;keywords&quot;, content: &quot;cmmv, contract model, websocket&quot; } ], link: [ { rel: &quot;stylesheet&quot;, href: &quot;/assets/styles/todo.css&quot; }, { rel: &quot;canonical&quot;, href: &quot;https://cmmv.io&quot; }, ] }, } &lt;/script&gt; The @cmmv/http module automates essential optimizations to HTTP headers, ensuring security and performance through compression, session management, and protection against common web attacks via middleware like cors, helmet, and compression. This is supplemented by custom configurations defined in the .cmmv.config.js file and template-specific header controls, making the CMMV platform a secure and efficient foundation for web applications.",
        "hierarchy": {
            "lvl0": "Headers",
            "lvl1": "CORS",
            "lvl2": "Header Customization",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "view/directives",
        "url": "/view/directives.html",
        "content": "Directives Preloading data that will be sent directly in HTML is a crucial factor for SEO (Search Engine Optimization). When a search engine analyzes a page, it searches for content that is already rendered in HTML. By ensuring that the essential data of the page is already loaded in HTML, rendering time is reduced and the content is immediately accessible for indexing, improving visibility in search results. CMMV (Contract-Model-Model-View) was designed with this need in mind, optimizing content delivery in a way that prioritizes SEO. The system emulates the traditional MVC (Model-View-Controller) model, widely used by well-known frameworks such as Ruby on Rails, Laravel, or Spring. This is done through SSR (Server-Side Rendering) directives, which allow data to be processed on the server and inserted directly into HTML, without the need for another application or overloading the frontend with complex frameworks. By using SSR directives such as s-data, CMMV ensures that dynamic data is sent in the HTML itself, without relying on AJAX calls or asynchronous loading via JavaScript, which can delay the display of critical content and negatively impact page performance. This makes content instantly available to search engines, improving load time (TTFB) and maximizing the chances of good indexing. This model not only ensures faster loading, but also improves the end-user experience. The user receives a complete page almost instantly, without the need to wait for additional loading or content updates. By centralizing data processing in the backend, CMMV reduces complexity and frontend overhead, eliminating the need for additional configuration or running multiple applications to render and serve dynamic content. In short, CMMV is a modern solution that reuses the best of the traditional MVC model, adapting it to the current scenario of SEO and performance optimization, with a focus on simplicity and efficiency. s-data The s-data directive allows you to directly render server-side data into your HTML templates. This is particularly useful for embedding server-side variables in your HTML without needing additional frontend frameworks or JavaScript. How it Works You declare a variable in the server-side controller and pass it to the view. The s-data directive is responsible for injecting this variable directly into the corresponding HTML element during server-side rendering (SSR). This ensures that the content is pre-rendered, optimizing the page for performance and SEO. View (HTML Template) &lt;div s-data=&quot;datetime&quot;&gt;&lt;/div&gt; In this example, the s-data directive is used on a &lt;div&gt; element to render the datetime variable, which will be provided by the server. Controller res.render(&quot;template&quot;, { datetime: new Date().getTime() }); In the controller, you pass the datetime variable (the current timestamp) as part of the data rendered into the template. Result (Rendered HTML) &lt;div&gt;1725568913552&lt;/div&gt; s-attr The s-attr directive in CMMV allows you to dynamically assign attributes to HTML elements from server-rendered data, similar to how the s-data directive works. However, instead of filling in the content of a tag, it adds or updates an attribute of the element. This is particularly useful for adding security attributes like nonce in &lt;script&gt; or &lt;link&gt; tags, often required by strict Content Security Policies (CSP). View (HTML Template) &lt;div s-attr=&quot;ref&quot;&gt;Content&lt;/div&gt; Controller res.render(&quot;template&quot;, { ref: &quot;ABC&quot; }); Result (Rendered HTML) &lt;div ref=&quot;ABC&quot;&gt;Content&lt;/div&gt; In this case, the s-attr=&quot;ref&quot; directive tells the server to create a ref attribute on the &lt;div&gt; element with the value “ABC”, which is passed from the server-side controller. s-i18n The s-i18n directive is the native internationalization module of the CMMV system. It allows developers to manage and display multilingual content by utilizing locale files. These locale files are stored in the /src/locale directory and should be in JSON format. CMMV provides the ability to define a default language, and it allows for dynamic language switching based on the user session. This is ideal for websites and applications that need to cater to multiple languages. The locale files contain key-value pairs, where the key represents the string identifier and the value is the localized string. For example: /src/locale/en.json { &quot;welcome&quot;: &quot;Welcome to CMMV&quot;, &quot;description&quot;: &quot;CMMV makes development faster and easier.&quot; } /src/locale/pt-br.json { &quot;welcome&quot;: &quot;Bem-vindo ao CMMV&quot;, &quot;description&quot;: &quot;O CMMV torna o desenvolvimento mais rápido e fácil.&quot; } You can use the s-i18n directive in your view templates to render localized strings based on the current language. View (HTML Template) &lt;div s-i18n=&quot;welcome&quot;&gt;&lt;/div&gt; &lt;p s-i18n=&quot;description&quot;&gt;&lt;/p&gt; Result (For English Locale) &lt;div&gt;Welcome to CMMV&lt;/div&gt; &lt;p&gt;CMMV makes development faster and easier.&lt;/p&gt; Configuration In the .cmmv.config.js file, you can configure the i18n settings to define the locale file path and the default language for your application: module.exports = { i18n: { localeFiles: &quot;./src/locale&quot;, // Path to the locale files default: &quot;en&quot; // Default language }, // Other configurations... } s-if The s-if directive is used to conditionally render a block of content based on the evaluation of an expression. If the provided expression evaluates to true, the content within the s-if directive will be rendered. Otherwise, the content will not be displayed. &lt;s-if exp=&quot;todolist.length &gt; 0&quot;&gt; &lt;div&gt;Total Record Loaded SSR: {{ todolist.length }}&lt;/div&gt; &lt;s-else&gt; &lt;div&gt;No records were loaded via SSR&lt;/div&gt; &lt;/s-else&gt; &lt;/s-if&gt; exp: The boolean expression to evaluate. The expression can use variables and logical operators to determine if the block should be displayed. While the s-if directive provides a powerful way to conditionally render content, it should be used with caution due to its potential impact on client-side updates. The content inside an s-if block is removed from the DOM if the expression evaluates to false, and this removal is not automatically updated or re-rendered on the client side after the initial server-side rendering (SSR). Recommendations: Use Case: It is recommended to use s-if primarily for scenarios where server-side conditions determine the content that should be included in the initial HTML. For instance, you might use s-if to load and display data that is available at the time of server rendering, such as user authentication data or initial configuration settings. Avoid Frequent Client-Side Updates: Since s-if removes the content from the DOM based on the initial evaluation, it is not suitable for dynamic client-side content that might change frequently or be updated after the initial load. For content that may need to be dynamically updated based on client-side interactions or data changes, consider using other methods such as client-side rendering techniques or reactive frameworks. By adhering to these recommendations, you can ensure that your use of the s-if directive enhances both the performance and maintainability of your application without unintended side effects. s-for The s-for directive is designed to handle server-side rendering (SSR) of lists and ensure that dynamic data is pre-rendered for improved SEO. This directive, used in conjunction with the c-for directive, allows you to define how data should be rendered on the server and how it should be updated on the client side. It supports pre-rendering content that will be displayed immediately to users and search engines, while also allowing for client-side updates. &lt;s-for c-show=&quot;condition&quot; c-for=&quot;(item, key) in collection&quot; render-tag=&quot;tag-name&quot; &gt; &lt;!-- Content to render --&gt; &lt;/s-for&gt; How It Works The s-for directive pre-renders the list items on the server based on the data provided. This includes evaluating expressions and injecting static content directly into the HTML. The directive ensures that content defined within the s-for block, including variables rendered using {{}}, c-text, c-html, and :, is pre-rendered. On the client side, the c-for directive will take over and handle dynamic updates. This allows the list to be reactive and updated as needed. Input Template: &lt;s-for c-show=&quot;todolist&quot; c-for=&quot;(item, key) in todolist&quot; class=&quot;todo-item&quot; render-tag=&quot;div&quot; &gt; &lt;div class=&quot;todo-item-content&quot;&gt; &lt;input type=&quot;checkbox&quot; c-model=&quot;item.checked&quot; @change=&quot;UpdateTaskRequest(item)&quot; &gt;&lt;/input&gt; &lt;label :class=&quot;{&#x27;todo-item-checked&#x27;: item.checked}&quot; &gt;{{ item.label }}&lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;todo-btn-remove&quot; s-i18n=&quot;remove&quot; @click=&quot;DeleteTaskRequest(item.id)&quot; &gt;&lt;/button&gt; &lt;/s-for&gt; Final Rendered Output: &lt;div c-if=&quot;!loaded &amp;&amp; !todolist&quot;&gt; &lt;div c-show=&quot;todolist&quot; class=&quot;todo-item&quot;&gt; &lt;div class=&quot;todo-item-content&quot;&gt; &lt;input type=&quot;checkbox&quot; c-model=&quot;item.checked&quot; @change=&quot;UpdateTaskRequest(1)&quot; &gt; &lt;label class=&quot;todo-item-checked&quot;&gt;Task 1&lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;todo-btn-remove&quot; @click=&quot;DeleteTaskRequest(1)&quot; &gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div c-else&gt; &lt;div c-show=&quot;todolist&quot; c-for=&quot;(item, key) in todolist&quot; class=&quot;todo-item&quot; &gt; &lt;div class=&quot;todo-item-content&quot;&gt; &lt;input type=&quot;checkbox&quot; c-model=&quot;item.checked&quot; @change=&quot;UpdateTaskRequest(item)&quot; &gt; &lt;label :class=&quot;{&#x27;todo-item-checked&#x27;: item.checked}&quot; &gt;{{ item.label }}&lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;todo-btn-remove&quot; @click=&quot;DeleteTaskRequest(item.id)&quot; &gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; Pre-Rendering: The s-for directive is crucial for SEO as it pre-renders list items with actual data, making the content immediately available for indexing by search engines. Client-Side Update: On the client side, the c-for directive ensures that the content is reactive and can be updated dynamically. Use with Caution: As s-for performs server-side rendering, ensure that the list and its contents are suitable for static pre-rendering. Avoid using it for highly dynamic data that changes frequently on the client side. By combining s-for with c-for, you can leverage server-side rendering for SEO benefits while maintaining dynamic client-side updates. Include The include directive allows the insertion of components or templates from other files into the main layout. This feature is useful for building modular pages, enabling the division of the layout into small, reusable blocks, which optimizes both loading performance and code maintenance. How It Works The include directive is responsible for preloading components on the server side before sending the page to the client. These components are treated as templates, and their inclusion can occur in a cascading manner, meaning that a template can include other templates. However, this behavior is influenced by the caching strategy, ensuring optimal performance by preventing repeated loading of already processed components. &lt;div&gt; &lt;!-- Include the navbar --&gt; &lt;!-- include(&#x27;public/views/docs/navbar&#x27;) --&gt; &lt;!-- Include the footer --&gt; &lt;!-- include(&#x27;public/views/docs/footer&#x27;) --&gt; &lt;/div&gt; When using the include directive, it’s important to consider how data or behavior for each template will be managed. The directive is designed to pre-process components on the server side, so any setup logic needs to be carefully planned. The recommended approach is to execute the setup logic in the main template and avoid cascading setups in included templates. This prevents unnecessary multiple setup executions that could negatively impact performance. To optimize template injection and improve performance, the include directive uses a caching strategy. This means that after the initial loading of a template, its content is cached, and subsequent inclusions will use the already-loaded template. However, if the content needs to be dynamically updated, it’s recommended that the setup be managed in the main template rather than relying on individual setups in each included template. This ensures that changes are centralized and easily managed. Complete Example &lt;div id=&quot;app&quot;&gt; &lt;!-- include(&#x27;public/views/docs/navbar&#x27;) --&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt;Welcome to our site!&lt;/p&gt; &lt;/div&gt; &lt;!-- include(&#x27;public/views/docs/footer&#x27;) --&gt; &lt;/div&gt; &lt;script&gt; export default { data() { return { navbarState: {}, contentData: {} }; }, mounted() { this.loadState(); }, methods: { loadState() { this.navbarState = JSON.parse( localStorage.getItem(&#x27;navbarState&#x27;) ) || {}; this.contentData = { message: &#x27;Dynamically loaded content.&#x27; }; } } }; &lt;/script&gt; Call Services In this implementation, you have a combination of server-side directives for data preloading and the use of the include directive to incorporate reusable components, such as the navbar and other layout elements, into the page. While this pattern works efficiently, it currently lacks support for component-specific setups as seen in frameworks like Nuxt.js. Let’s break down how this approach works and the potential for future enhancements. Server-Side Directive (s:docs) In the main HTML file (index.hhtml), you are using a directive (s:docs=“docs”) to bind server-preloaded data (in this case, docs) to the client-side rendering. This allows the initial data, such as the navigation structure (docs.navbar), to be fetched server-side and passed to the client before the page is rendered. &lt;div id=&quot;app&quot; s:docs=&quot;docs&quot; c-cloak&gt; The docs object is populated on the server, likely from a backend data source or file, and it is injected into the template. This enables the use of this data immediately upon loading without additional client-side API calls, improving the initial loading performance. Using the include Directive for Templates You are including reusable components, such as the navbar, breadcrumbs, and footer, with the include directive. These templates are preloaded on the server, enhancing modularity and maintainability: &lt;!-- include(&#x27;public/views/docs/navbar&#x27;) --&gt; &lt;!-- include(&#x27;public/views/docs/breadcrumb&#x27;); --&gt; &lt;!-- include(&#x27;public/views/docs/footer&#x27;); --&gt; By loading these components server-side, you avoid multiple HTTP requests to fetch the template separately and enable the server to handle the logic related to content inclusion. However, as you noted, this approach currently processes only the main setup logic, and any additional setup logic within included templates (like navbar.html) is not supported. Client-Side State Updates Once the data and templates are preloaded on the server, the client-side JavaScript is responsible for handling state updates. For example, in your main component, you load the saved state of the navbar from localStorage and provide methods to toggle the state: export default { data() { return { navbar: [] } }, async mounted() { this.loadState(); }, methods: { loadState() { this.navbar = JSON.parse( localStorage.getItem(&#x27;navbarState&#x27;) ) || {}; return this.navbar; }, saveState(state) { localStorage.setItem(&#x27;navbarState&#x27;, JSON.stringify(state)); }, toggle(isOpened, itemName) { isOpened = !isOpened; const currentState = this.loadState(); currentState[itemName] = isOpened; this.saveState(currentState); return isOpened; } } }; This ensures that interactions on the page, such as expanding or collapsing navbar sections, persist between sessions, as the state is stored in localStorage and reloaded when the page is mounted. The Limitation As noted in the provided comment, there is no current support for individual setup logic within included templates (like navbar.html). This differs from frameworks like Nuxt.js, where each component can have its own setup function. In your current implementation, adding a script setup block inside an included template would cause issues, as only the setup logic from the main template (index.html) is processed. For example, adding a setup block in the navbar.html would not work as expected: &lt;!-- navbar.html --&gt; &lt;script s-setup&gt; export default { data() { return { isOpened: false }; }, methods: { toggleNavbar() { this.isOpened = !this.isOpened; } } }; &lt;/script&gt; This would break the application because only the first setup is processed, and additional setups are ignored. Future Enhancements The idea of allowing component-specific setups, similar to Nuxt.js, is a potential enhancement that could improve the flexibility of the system. However, this needs to be handled carefully to avoid performance issues like infinite loading loops. When each component has its own setup logic, the application might end up in a continuous loop of re-rendering if not properly managed. To safely implement component-specific setup: Careful Dependency Management: Ensure that each component’s setup logic is independent and doesn’t trigger unnecessary re-renders of the parent component. Lazy Loading: Consider lazy loading for templates or components that don’t need to be preloaded on the server, reducing the initial load and avoiding potential issues with large applications. Optimized State Sharing: Provide mechanisms to share state across components without requiring full re-execution of setup logic when components are dynamically included. Here’s how individual setups could work in the future, following a model like Nuxt.js: &lt;!-- index.html --&gt; &lt;div id=&quot;app&quot; s:docs=&quot;docs&quot; c-cloak&gt; &lt;div&gt; &lt;!-- include(&#x27;public/views/docs/navbar&#x27;) --&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- navbar.html --&gt; &lt;script s-setup&gt; export default { data() { return { isOpened: false }; }, methods: { toggleNavbar() { this.isOpened = !this.isOpened; } } }; &lt;/script&gt; &lt;ul&gt; &lt;li @click=&quot;toggleNavbar&quot;&gt;Menu Item&lt;/li&gt; &lt;/ul&gt; In this future scenario, each component or template could handle its own state and methods without conflicting with the main template setup. Full implementation Below is an example of implementation of practically all the directives that were used to create the system in this documentation. /public/templates/default.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;headers/&gt; &lt;/head&gt; &lt;body scope&gt; &lt;slot/&gt; &lt;scripts/&gt; &lt;/body&gt; &lt;/html&gt; /public/views/docs/index.html &lt;div id=&quot;app&quot; s:docs=&quot;docs&quot; c-cloak&gt; &lt;nav class=&quot;navbar bg-neutral-800 h-16 top-0 w-full fixed flex z-50 shadow-lg&quot;&gt; &lt;div class=&quot;max-w-8xl mx-auto flex container&quot;&gt; &lt;div class=&quot;w-60&quot;&gt; &lt;a href=&quot;/&quot; title=&quot;UCS.js&quot;&gt; &lt;img src=&quot;/assets/logo-min-invert.png&quot; class=&quot;mt-6 ml-4&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;justify-between w-full text&quot;&gt; &lt;div class=&quot;relative text-right mt-3 hover:cursor-pointer group bg-neutral-800 float-right rounded-lg border border-black&quot;&gt; &lt;div class=&quot;absolute text-white z-40 top-2 left-18&quot; style=&quot;left: 12px; color: #ccd0d5;&quot;&gt; &lt;i class=&quot;fa-solid fa-search&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;text&quot; class=&quot;p-1.5 pl-10 text-white bg-transparent&quot; placeholder=&quot;Search&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;justify-between align-middle text-center mr-2 text-white flex&quot;&gt; &lt;a href=&quot;https://github.com/andrehrferreira/cmmv&quot; title=&quot;Github&quot; target=&quot;_blank&quot; class=&quot;text-2xl p-2 mt-2 hover:text-neutral-300&quot;&gt; &lt;i class=&quot;fa-brands fa-github&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;!--&lt;a href=&quot;https://discord.gg/XtUH9sJP&quot; title=&quot;Discord&quot; target=&quot;_blank&quot; class=&quot;text-2xl p-2 mt-2 hover:text-neutral-300&quot;&gt; &lt;i class=&quot;fa-brands fa-discord&quot;&gt;&lt;/i&gt; &lt;/a&gt;--&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class=&quot;max-w-8xl mx-auto flex container&quot;&gt; &lt;div class=&quot;w-60 fixed mt-20 z-40 overflow-auto&quot; style=&quot;height: calc(100% - 84px); background-color: #2e3035&quot; c-cloak &gt; &lt;!-- include(&#x27;public/views/docs/navbar&#x27;) --&gt; &lt;/div&gt; &lt;div class=&quot;mt-20 ml-64 text-justify relative&quot;&gt; &lt;div class=&quot;lg:pl-[19.5rem] m-4 p-4 px-20 max-w-3x1 mx-auto xl:max-w-none xl:ml-0 xl:mr-[15.5rem] xl:pr-16&quot; :class=&quot;{&#x27;w-full&#x27;: docs.anchors.length &lt; 4}&quot; &gt; &lt;!-- include(&#x27;public/views/docs/breadcrumb&#x27;); --&gt; &lt;!-- include(&#x27;public/views/docs/anchors&#x27;); --&gt; &lt;div class=&quot;max-w-screen-lg relative text-white mb-20 context-html&quot;&gt; &lt;div c-html=&quot;docs.index&quot;&gt;{ docs.index }&lt;/div&gt; &lt;div class=&quot;absolute top-0 right-0&quot;&gt; &lt;a :href=&quot;`https://github.com/andrehrferreira/docs.cmmv.io/tree/main${docs.link?.replace(&#x27;.html&#x27;, &#x27;.md&#x27;)}?plain=1`&quot; target=&quot;_blank&quot; title=&quot;Suggest change&quot; &gt; &lt;i class=&quot;fa-solid fa-pen-to-square fa-lg&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- include(&#x27;public/views/docs/footer&#x27;); --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script s-attr=&quot;nonce&quot;&gt; function updateCurrent(){ const scrollPosition = window.scrollY; document.querySelectorAll(&#x27;.current&#x27;).forEach(el =&gt; el.classList.remove(&#x27;current&#x27;)); let repoint = false; document.querySelectorAll(&#x27;#anchors li&#x27;).forEach((item, index) =&gt; { const target = document.querySelector(item.querySelector(&#x27;a&#x27;).getAttribute(&#x27;href&#x27;)); if (target?.offsetTop &gt;= scrollPosition &amp;&amp; !repoint) { repoint = true; item.classList.add(&#x27;current&#x27;); } else if(!target) { repoint = true; item.classList.add(&#x27;current&#x27;); } }); } window.addEventListener(&#x27;scroll&#x27;, updateCurrent); window.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; { document.querySelectorAll(&#x27;a[href^=&quot;#&quot;]&#x27;).forEach((link, index) =&gt; { link.addEventListener(&#x27;click&#x27;, function(event) { event.preventDefault(); const href = this.getAttribute(&#x27;href&#x27;); document.querySelectorAll(&#x27;.current&#x27;).forEach(el =&gt; el.classList.remove(&#x27;current&#x27;)); this.parentElement.classList.add(&#x27;current&#x27;); window.scrollTo({ top: document.querySelector(href).offsetTop, behavior: &#x27;smooth&#x27; }); window.location.hash = href; }); }); updateCurrent(); }); &lt;/script&gt; &lt;script s-setup&gt; export default { layout: &quot;default&quot;, data(){ return { navbar: [] } }, async mounted() { this.loadState(); }, methods: { loadState(){ this.navbar = JSON.parse(localStorage.getItem(&#x27;navbarState&#x27;)) || {}; return this.navbar; }, saveState(state) { localStorage.setItem(&#x27;navbarState&#x27;, JSON.stringify(state)); }, toggle(isOpened, itemName) { isOpened = !isOpened; const currentState = this.loadState(); currentState[itemName] = isOpened; this.saveState(currentState); return isOpened; } } } &lt;/script&gt; /public/views/docs/navbar.html &lt;ul class=&quot;p-4 select-none top-16&quot; c-cloak c-show=&quot;docs&quot;&gt; &lt;li c-for=&quot;(item, key) in docs.navbar&quot;&gt; &lt;div c-show=&quot;item&quot; class=&quot;flex hover:text-blue-700 itemRoot text-white&quot; :id=&quot;item?.name.replace(/\\s/,&#x27;_&#x27;)&quot; :data-opened=&quot;false&quot; @click.stop=&quot;navbar[item?.name.replace(/\\s/, `_`)] = toggle(navbar[item?.name.replace(/\\s/, `_`)], item.name?.replace(/\\s/, `_`))&quot; &gt; &lt;div class=&quot;flex flex-1 font-bold text-md cursor-pointer navbar-item&quot;&gt; &lt;h3 c-if=&quot;item &amp;&amp; item?.isDir&quot; class=&quot;text-white&quot;&gt;{{ item?.name }}&lt;/h3&gt; &lt;span c-else class=&quot;text-white&quot;&gt;{{ item?.name }}&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;justify-between cursor-pointer&quot; c-if=&quot;item?.isDir&quot;&gt; &lt;i class=&quot;fa-solid fa-angle-down&quot; c-show=&quot;!navbar[item?.name.replace(/\\s/, `_`)]&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa-solid fa-angle-up&quot; c-show=&quot;navbar[item?.name.replace(/\\s/, `_`)]&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;ul c-if=&quot;item &amp;&amp; item.children &amp;&amp; item.children.length &gt; 0&quot; :id=&quot;`${item?.name.replace(/\\s/, `_`)}_contents`&quot; class=&quot;p-4 py-1 text-md mb-4&quot; :style=&quot;(navbar[item?.name.replace(/\\s/, `_`)]) ? &#x27;&#x27; : &#x27;display: none;&#x27;&quot; &gt; &lt;li c-for=&quot;(child) in item.children&quot;&gt; &lt;div class=&quot;hover:text-gray-800 text-white text-base p-1&quot; style=&quot;font-size: 12px&quot;&gt; &lt;a :href=&quot;child.uri&quot; class=&quot;text-base&quot;&gt;{{ child.name }}&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; /src/docs.controller.ts import * as fs from &#x27;fs&#x27;; import * as path from &quot;path&quot;; import { Controller, Get, Param, Response, ServiceRegistry } from &#x27;@cmmv/http&#x27;; import { DocsService } from &#x27;./docs.service&#x27;; const index = require(&quot;../docs/index.json&quot;); @Controller(&quot;docs&quot;) export class DocsController { constructor(private docsService: DocsService){} @Get() async indexHandler(@Response() res) { return res.render(&quot;views/docs/index&quot;, { docs: await this.docsService.getDocsStrutucture(), services: ServiceRegistry.getServicesArr() }); } @Get(&quot;:item&quot;) async getDocHandler( @Param(&quot;item&quot;) item: string, @Response() res ) { if(index[item]) this.getDoc(index[item], res) else res.status(404).end(); } @Get(&quot;:dir/:item&quot;) async getDocSubdirHandler( @Param(&quot;dir&quot;) dir: string, @Param(&quot;item&quot;) item: string, @Response() res ) { const fullPath = `${dir}/${item}`; if(index[fullPath]) this.getDoc(index[fullPath], res) else res.status(404).end(); } async getDoc(docFilename: string, @Response() res) { const file = path.resolve(docFilename); const data = await this.docsService.getDocsStrutucture(file); return res.render(&quot;views/docs/index&quot;, { docs: data, services: ServiceRegistry.getServicesArr() }); } } To have full access to the code, access Github",
        "hierarchy": {
            "lvl0": "Directives",
            "lvl1": "s-data",
            "lvl2": "How It Works",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "view/reactivity",
        "url": "/view/reactivity.html",
        "content": "Reactivity The @cmmv/reactivity module was created based on the core ideas of Petite Vue, a simplified version of Vue.js. Petite Vue, developed by Evan You, the creator of Vue.js, offers a lightweight alternative to the full Vue framework, providing only the essential reactivity and templating features needed for smaller or simpler projects. Petite Vue is just 6KB in size and implements basic directives, making it an excellent foundation for building minimal reactive systems. Inspired by Petite Vue’s design philosophy, @cmmv/reactivity integrates this lightweight, reactive approach into the CMMV framework. By doing so, it offers developers the ability to use two-way data binding and efficient UI updates with minimal overhead. The core reactivity engine from Petite Vue has been adapted to fit seamlessly into the CMMV ecosystem, allowing for easy integration with server-side rendering, WebSockets, Protobuf, and other key modules of CMMV. With this combination, @cmmv/reactivity provides an optimal balance of simplicity and performance, making it ideal for building dynamic user interfaces while keeping the overall bundle size minimal. It is well-suited for developers who prefer a lightweight, Vue-inspired reactivity system without the complexity of a full-featured framework. For more information on Petite Vue, you can visit the official Petite Vue repository. Limitations The primary goal of the CMMV framework is to build high-performance applications with a strong focus on speed, efficiency, and SEO optimization. To achieve this, we highly recommend using @cmmv/reactivity as the frontend framework rather than incorporating heavier frameworks like Vue, React, or Angular. @cmmv/reactivity is designed to handle most of the common challenges faced in web applications, providing essential reactivity features in a lightweight package that minimizes the impact on your application’s load times and performance. By choosing @cmmv/reactivity, you can ensure that your application remains fast and optimized for both users and search engines. Adding larger frameworks such as Vue, React, or Angular introduces additional layers of JavaScript that can increase the page’s initial load time, potentially harming your PageSpeed score and overall performance. This goes against the core principles of CMMV, which aims to reduce unnecessary overhead. If you find that certain critical features are missing from @cmmv/reactivity, we encourage you to submit a pull request to the repository. We’re open to suggestions and contributions that improve the framework while keeping it aligned with CMMV’s performance goals. In extreme cases where heavier frameworks like Vue, React, or Angular are necessary, we will eventually provide native support for their integration. However, we strongly advise against this approach due to the performance trade-offs. Any implementation of these frameworks will be at your own risk, and we will not offer official support for such setups—our focus will remain exclusively on optimizing @cmmv/reactivity for the best possible user experience and SEO results. Installation To install the @cmmv/reactivity package, simply run the following command: $ npm install @cmmv/reactivity or $ yarn add @cmmv/reactivity Alternatively, you can visit the GitHub repository for more details. The @cmmv/view module already integrates reactivity natively, so it does not need to be installed separately. Usage Below is the documentation for all directives supported by @cmmv/reactivity based on the samples provided in the CMMV Reactivity GitHub repository. c-model Binds the value of an input element to the application’s data and enables two-way data binding. This is useful for dynamically updating the UI as users input data. &lt;input c-model=&quot;username&quot;&gt; &lt;p&gt;Username: {{ username }}&lt;/p&gt; Sample : &lt;script type=&quot;module&quot;&gt; import { createApp } from &#x27;../src&#x27; createApp().mount(&#x27;#app&#x27;) &lt;/script&gt; &lt;div id=&quot;app&quot; scope=&quot;{ text: &#x27;hello&#x27;, checked: true, checkToggle: { a: 1 }, trueValue: { a: 1 }, falseValue: { a: 2 }, arr: [&#x27;one&#x27;], radioSelected: &#x27;two&#x27;, selected: &#x27;two&#x27; }&quot; &gt; &lt;pre&gt;{{ $data }}&lt;/pre&gt; &lt;h2&gt;Text Input&lt;/h2&gt; {{ text }} &lt;input v-model.trim=&quot;text&quot; /&gt; &lt;h2&gt;TextArea&lt;/h2&gt; {{ text }} &lt;textarea v-model.trim=&quot;text&quot;&gt;&lt;/textarea&gt; &lt;h2&gt;Checkbox&lt;/h2&gt; &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot; /&gt; &lt;label for=&quot;checkbox&quot;&gt;{{ checked }}&lt;/label&gt; &lt;h2&gt;Checkbox w/ Array&lt;/h2&gt; &lt;label&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;arr&quot; value=&quot;one&quot; /&gt; one&lt;/label&gt; &lt;label&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;arr&quot; value=&quot;two&quot; /&gt; two&lt;/label&gt; &lt;label &gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;arr&quot; :value=&quot;123&quot; /&gt; actual number&lt;/label &gt; &lt;div&gt;{{ arr }}&lt;/div&gt; &lt;h2&gt;Checkbox w/ true-value / false-value&lt;/h2&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checkToggle&quot; :true-value=&quot;trueValue&quot; :false-value=&quot;falseValue&quot; /&gt; &lt;div&gt;{{ checkToggle }}&lt;/div&gt; &lt;h2&gt;Radio&lt;/h2&gt; &lt;label&gt;&lt;input type=&quot;radio&quot; v-model=&quot;radioSelected&quot; value=&quot;one&quot; /&gt; one&lt;/label&gt; &lt;label&gt;&lt;input type=&quot;radio&quot; v-model=&quot;radioSelected&quot; value=&quot;two&quot; /&gt; two&lt;/label&gt; &lt;label &gt;&lt;input type=&quot;radio&quot; v-model=&quot;radioSelected&quot; value=&quot;three&quot; /&gt; three&lt;/label &gt; &lt;div&gt;{{ radioSelected }}&lt;/div&gt; &lt;h2&gt;Select&lt;/h2&gt; &lt;select v-model=&quot;selected&quot; @change=&quot;console.log(selected, $event.target.value)&quot;&gt; &lt;option&gt;one&lt;/option&gt; &lt;option&gt;two&lt;/option&gt; &lt;option&gt;three&lt;/option&gt; &lt;/select&gt; &lt;div&gt;{{ selected }}&lt;/div&gt; &lt;/div&gt; In this example, the input’s value is bound to the username field in the data model. Changes in the input will be reflected in the username property. c-show Controls the visibility of elements based on a condition. If the condition evaluates to false, the element will be hidden. &lt;p c-show=&quot;isLoggedIn&quot;&gt;Welcome back, user!&lt;/p&gt; c-if Conditionally renders an element only if the specified expression is true. Unlike c-show, this directive removes the element from the DOM if the condition is false. &lt;p c-if=&quot;showMessage&quot;&gt;This message is shown only if showMessage is true.&lt;/p&gt; Sample: &lt;script type=&quot;module&quot;&gt; import { createApp } from &#x27;../src&#x27; createApp().mount(&#x27;#app&#x27;) &lt;/script&gt; &lt;div id=&quot;app&quot; scope=&quot;{ open: true, elseOpen: true }&quot;&gt; &lt;button @click=&quot;open = !open&quot;&gt;toggle&lt;/button&gt; &lt;button @click=&quot;elseOpen = !elseOpen&quot;&gt;toggle else&lt;/button&gt; &lt;div c-if=&quot;open&quot;&gt;ok&lt;/div&gt; &lt;div c-else-if=&quot;elseOpen&quot;&gt;else if&lt;/div&gt; &lt;template c-else&gt;else&lt;/template&gt; &lt;/div&gt; c-for Loops through an array or object and repeats the associated element for each item. &lt;ul&gt; &lt;li c-for=&quot;item in items&quot;&gt;{{ item }}&lt;/li&gt; &lt;/ul&gt; Sample: &lt;script type=&quot;module&quot;&gt; import { createApp } from &#x27;../src&#x27; let id = 4 createApp({ list: [ { id: 1, text: &#x27;bar&#x27; }, { id: 2, text: &#x27;boo&#x27; }, { id: 3, text: &#x27;baz&#x27; }, { id: 4, text: &#x27;bazz&#x27; } ], add() { this.list.push({ id: ++id, text: &#x27;new item&#x27; }); }, splice() { this.list.splice(1, 0, { id: ++id, text: &#x27;new item&#x27; }) } }).mount(&#x27;#app&#x27;) &lt;/script&gt; &lt;div id=&quot;app&quot; scope&gt; &lt;button @click=&quot;add&quot;&gt;add&lt;/button&gt; &lt;button @click=&quot;list.reverse()&quot;&gt;reverse&lt;/button&gt; &lt;button @click=&quot;list.pop()&quot;&gt;pop&lt;/button&gt; &lt;button @click=&quot;splice&quot;&gt;splice&lt;/button&gt; &lt;ul&gt; &lt;li c-for=&quot;({ id, text }, index) in list&quot; :key=&quot;id&quot;&gt; &lt;div&gt;{{ index }} {{ { id, text } }}&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li c-for=&quot;item of list&quot; :key=&quot;item.id&quot;&gt; &lt;input c-model=&quot;item.text&quot; /&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; c-on Attaches an event listener to an element. Commonly used for handling click events, form submissions, or other user interactions. &lt;button c-on:click=&quot;incrementCounter&quot;&gt;Click me!&lt;/button&gt; &lt;button @click=&quot;incrementCounter&quot;&gt;Click me!&lt;/button&gt; Sample: &lt;script type=&quot;module&quot;&gt; import { createApp } from &#x27;../src&#x27; createApp().mount(&#x27;#app&#x27;) &lt;/script&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; @keyup.x=&quot;alert(&#x27;yo&#x27;)&quot; placeholder=&quot;type x to test key modifier&quot; /&gt; &lt;form&gt; &lt;button type=&quot;submit&quot; @click.prevent.stop&gt;submit (prevented)&lt;/button&gt; &lt;/form&gt; &lt;button @click.right=&quot;alert(&#x27;clicked&#x27;)&quot;&gt;right click&lt;/button&gt; &lt;button @click.middle=&quot;alert(&#x27;clicked&#x27;)&quot;&gt;middle click&lt;/button&gt; &lt;button @click.once=&quot;alert(&#x27;clicked&#x27;)&quot;&gt;click once&lt;/button&gt; &lt;/div&gt; c-bind Dynamically binds an attribute to an expression. This is often used to modify attributes like src, href, or class. &lt;img :src=&quot;imageSource&quot;&gt; Sample: &lt;style&gt; #green { color: green; } .red { color: red; } .orange { color: orange; } .static { font-weight: bold; } &lt;/style&gt; &lt;script type=&quot;module&quot;&gt; import { createApp, reactive } from &#x27;../src&#x27; const data = (window.data = reactive({ id: &#x27;green&#x27;, classes: [&#x27;foo&#x27;, { red: true }], style: { color: &#x27;blue&#x27; }, obj: { class: &#x27;orange&#x27; } })) createApp(data).mount() &lt;/script&gt; &lt;div scope&gt; &lt;div :id=&quot;id&quot;&gt;simple binding - this should be green&lt;/div&gt; &lt;div class=&quot;static&quot; :class=&quot;classes&quot;&gt; class binding - this should be red and bold &lt;/div&gt; &lt;div style=&quot;font-weight: bold&quot; :style=&quot;style&quot;&gt; style binding - this should be blue and bold &lt;/div&gt; &lt;div c-bind=&quot;obj&quot;&gt;object binding - this should be orange&lt;/div&gt; &lt;/div&gt; c-text Dynamically sets the text content of an element. &lt;div scope=&quot;{ count: 1 }&quot;&gt; &lt;p c-text=&quot;count&quot;&gt;&lt;/p&gt; &lt;button @click=&quot;count++&quot;&gt;increase&lt;/button&gt; &lt;/div&gt; c-html Inserts raw HTML content into an element. &lt;div c-html=&quot;htmlContent&quot;&gt;&lt;/div&gt; c-class Dynamically binds one or more CSS classes to an element. &lt;div c-class=&quot;{ active: isActive, disabled: isDisabled }&quot;&gt;&lt;/div&gt; In this example, if isActive is true, the active class is added, and if isDisabled is true, the disabled class is added. c-once &lt;script type=&quot;module&quot;&gt; import { createApp } from &#x27;../src&#x27; createApp().mount() &lt;/script&gt; &lt;div scope=&quot;{ count: 5 }&quot;&gt; {{ count }} &lt;div c-once&gt; &lt;h2&gt;Once&lt;/h2&gt; {{ count }} &lt;span c-text=&quot;count&quot;&gt;&lt;/span&gt; &lt;span v-for=&quot;i in count&quot;&gt;{{ i }}&lt;/span&gt; &lt;/div&gt; &lt;span c-text=&quot;count&quot;&gt;&lt;/span&gt; &lt;button @click=&quot;count++&quot;&gt;++&lt;/button&gt; &lt;/div&gt; ref In the @cmmv/reactivity framework, the ref system allows you to easily reference DOM elements within the template and manipulate them in your JavaScript logic. This concept is crucial for managing DOM elements directly when reactive bindings alone are not enough. By associating a ref with an element, you can interact with the DOM directly from the reactive context of your application. Key Benefits of Using ref: Direct DOM Access: It allows you to interact directly with DOM elements, which is sometimes necessary for operations that cannot be purely reactive. Dynamic Ref Assignment: You can dynamically change the target element assigned to a ref at runtime. Scoped Refs: The system supports nested scopes, meaning you can define refs within a specific context without affecting the global references. &lt;script type=&quot;module&quot;&gt; import { createApp, reactive } from &#x27;../src&#x27; createApp().mount() &lt;/script&gt; &lt;div id=&quot;root&quot; ref=&quot;root&quot; scope=&quot;{ dynamicRef: &#x27;x&#x27;, show: true }&quot; c-effect=&quot;console.log({ x: $refs.x, y: $refs.y, input: $refs.input })&quot; &gt; &lt;p&gt;Accessing root el: id is {{ $refs.root.id }}&lt;/p&gt; &lt;input ref=&quot;input&quot; /&gt; &lt;span v-show=&quot;show&quot; :ref=&quot;dynamicRef&quot;&gt;Span with dynamic ref&lt;/span&gt; &lt;p&gt;dynamicRef is {{ dynamicRef }}&lt;/p&gt; &lt;button @click=&quot;dynamicRef = dynamicRef === &#x27;x&#x27; ? &#x27;y&#x27; : &#x27;x&#x27;&quot;&gt; change dynamicRef &lt;/button&gt; &lt;button @click=&quot;show = !show&quot;&gt;toggle&lt;/button&gt; &lt;div scope&gt; &lt;p ref=&quot;x&quot;&gt;nested scope ref&lt;/p&gt; &lt;button @click=&quot;console.log({ x: $refs.x, y: $refs.y, input: $refs.input })&quot; &gt; log nested scope refs &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; Static Ref Assignment: The ref attribute binds an element to a key in the $refs object. In the example above, the element input ref=&quot;input&quot; is now accessible via $refs.input in your JavaScript code. Accessing Ref Values: The c-effect directive is used to log the values of the refs whenever the component is re-rendered or when its state changes. For example, c-effect=“console.log({ x: $refs.x, y: $refs.y, input: $refs.input })” logs the current values of x, y, and input. Dynamic Ref Assignment: You can dynamically change which element is referenced by using a reactive variable. For example, the element uses :ref=“dynamicRef”, which means the ref value can change based on the value of dynamicRef. The button with the text “change dynamicRef” toggles the reference between x and y. Scoped Refs: The element defines a nested scope, which means the ref=“x” inside it refers to a local element. The $refs object will adjust to the scope context, providing an isolated reference within that scope. Toggling Visibility: The c-show=“show” directive toggles the visibility of the , but the ref still holds the reference to the element, even when it is hidden. Components The @cmmv/reactivity framework allows you to create lightweight and reactive components in your application without the overhead of traditional frameworks. The example provided demonstrates how you can define and use a simple component using createApp, reactive, and templates. &lt;script type=&quot;module&quot;&gt; import { createApp, reactive } from &#x27;../src&#x27; function MyComp() { return { $template: &#x27;#comp&#x27;, count: 0, get plusOne() { return this.count + 1 } } } createApp({ MyComp }).mount() &lt;/script&gt; &lt;template id=&quot;comp&quot;&gt; {{ count }} {{ plusOne }} &lt;button @click=&quot;count++&quot;&gt;++&lt;/button&gt; &lt;/template&gt; &lt;div scope=&quot;MyComp()&quot;&gt;&lt;/div&gt; Component Setup: The MyComp function returns the component’s data and computed properties. The $template points to the HTML template that will render this component. Reactive Data: count is a reactive property. Changing its value updates the UI automatically. plusOne is a computed property that reacts to count and displays count + 1. Template: The template uses {{ count }} and {{ plusOne }} to display the reactive data. Clicking the button increments count and updates the displayed value. Mounting: The createApp function registers the component and mounts it inside the div scope=&quot;MyComp()&quot; tag, which defines where the component will appear.",
        "hierarchy": {
            "lvl0": "Reactivity",
            "lvl1": "Limitations",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "view/overview",
        "url": "/view/overview.html",
        "content": "View The @cmmv/view module in CMMV is a custom view engine designed to optimize SEO and performance by incorporating server-side rendering (SSR) with seamless integration into modern frontend frameworks. Built on top of EJS (Embedded JavaScript), it serves as a middleware for Express and Fastify, processing views in real-time and injecting pre-loaded data into the HTML before it reaches the browser. This approach enables search engines to index content that has already been processed, while still offering flexibility to use popular frontend frameworks like Vue.js, React, or Angular for additional client-side interaction. Traditional client-side rendering (CSR) frameworks, such as Vue.js and React, generate content dynamically in the browser. While these frameworks provide rich interactivity, they can negatively impact SEO due to the delayed rendering of content—search engines may not fully index dynamic content that relies on JavaScript execution. By incorporating SSR through @cmmv/view, the critical content of your web application is rendered on the server, allowing it to be immediately visible to both users and search engines. This significantly enhances the SEO of your site because the content is presented in the initial HTML response, allowing for better crawlability and faster page loads. Key Features of @cmmv/view Server-Side Rendering (SSR) The @cmmv/view module processes views and injects dynamic data server-side before the HTML is sent to the browser. This means that any service calls, database queries, or API requests required to generate content are completed on the server, so the user and search engines receive fully rendered HTML. Optimized JavaScript Bundle In addition to rendering views, the @cmmv/view module creates an optimized JavaScript bundle that includes the core libraries required by the application, such as @cmmv/reactivity (a component that handles real-time updates via RPC). This bundle ensures that the frontend is prepared for fast and efficient interaction once it reaches the client. Seamless Integration with JavaScript Frameworks While @cmmv/view focuses on SSR, it doesn’t prevent the use of modern frontend frameworks like Vue.js, React, or Angular. It provides a way to hydrate the server-rendered HTML with these frameworks, so developers can benefit from both SSR and client-side interactivity. In future versions, there will be streamlined support for these frameworks, allowing them to work effortlessly with the existing CMMV infrastructure. Pre-Loaded Data for SEO One of the most significant SEO advantages of @cmmv/view is its ability to inject pre-loaded data directly into the HTML template. This data is often gathered from services such as APIs, databases, or repositories, making it available for search engine crawlers before any JavaScript needs to be executed. This feature ensures that essential content is available upfront, improving SEO rankings, as search engines can see the full context of the page without relying on client-side scripts. Dynamic JavaScript Inclusion In addition to handling SSR, @cmmv/view dynamically includes any additional JavaScript files necessary for the page. Whether it’s a custom script or a framework like React, these files are bundled and served in a single request, reducing network overhead and speeding up initial load times. Custom Directives for SSR The @cmmv/view module also supports custom directives that process HTML and data on the server-side. These directives handle pre-loading data, managing conditional content, looping over datasets, and handling i18n translations—all of which are rendered as static HTML, further improving SEO. SEO Improved Crawlability When search engines crawl your site, they rely on HTML to extract key information for indexing. In a typical CSR application, much of the content is loaded asynchronously via JavaScript, which search engines may not execute fully, or at all. This results in poor visibility for crawlers, reducing the discoverability of critical content. With @cmmv/view, the content is already pre-rendered by the time it reaches the browser. The server completes the processing of all service requests, API calls, and dynamic data queries, delivering fully rendered HTML. As a result, search engines can immediately identify the core content of your pages, leading to higher rankings in search results. Faster Page Load Times Since @cmmv/view processes data on the server and sends it along with the initial HTML, users experience faster page loads. The time spent rendering content in the browser is minimized, which not only improves the user experience but also enhances the page’s SEO performance. JavaScript Overhead Reduction Client-side rendering frameworks often involve large JavaScript bundles and significant runtime execution. With @cmmv/view, much of the work is offloaded to the server, reducing the amount of JavaScript required to process the page on the client-side. This results in reduced network load, quicker time-to-interactive (TTI), and a smoother overall experience for the user. Pre-Loaded Data for SEO and UX By pre-fetching data and injecting it into the HTML, @cmmv/view ensures that users and search engines see the most relevant content immediately. Whether it’s product information, blog content, or news articles, everything is available as soon as the page loads, improving both SEO and user engagement. Exemple &lt;div class=&quot;product-page&quot; s:product=&quot;services.product.getProductById(productId)&quot; scope &gt; &lt;h1&gt;{{ product.name }}&lt;/h1&gt; &lt;p&gt;{{ product.description }}&lt;/p&gt; &lt;div class=&quot;price&quot;&gt;{{ product.price | currency }}&lt;/div&gt; &lt;div class=&quot;availability&quot;&gt; {{ product.inStock ? &#x27;In Stock&#x27; : &#x27;Out of Stock&#x27; }} &lt;/div&gt; &lt;button s-i18n=&quot;addToCart&quot; class=&quot;add-to-cart&quot; @click=&quot;addToCart(product.id)&quot; &gt;&lt;/button&gt; &lt;/div&gt; &lt;script s-setup&gt; export default { layout: &quot;default&quot;, data() { return { product: null } }, methods: { addToCart(productId) { ... } } } &lt;/script&gt; By using @cmmv/view, developers can leverage the advantages of SSR to significantly boost their SEO performance and reduce load times. By pre-loading content, optimizing JavaScript bundles, and offering seamless integration with modern frontend frameworks, @cmmv/view provides a comprehensive solution for building scalable, SEO-friendly web applications. The ability to serve pre-rendered content, while maintaining the flexibility of client-side interactivity, ensures that CMMV applications can deliver the best of both worlds: high SEO performance and rich, responsive user experiences. Settings The @cmmv/view module in CMMV allows for flexible customization through the .cmmv.config.js file. Below are the available configurations that you can use to fine-tune the behavior of the view engine, internationalization (i18n), meta tags for SEO, security headers, and JavaScript resources. module.exports = { ... i18n: { localeFiles: &quot;./src/locale&quot;, default: &quot;en&quot; }, view: { extractInlineScript: true, minifyHTML: true }, head: { title: &quot;CMMV&quot;, htmlAttrs: { lang: &quot;pt-br&quot; }, meta: [ { charset: &#x27;utf-8&#x27; }, { name: &#x27;viewport&#x27;, content: &#x27;width=device-width&#x27; }, ... ], link: [ { rel: &#x27;icon&#x27;, href: &#x27;assets/favicon/favicon.ico&#x27; }, ... ] }, headers: { &quot;Content-Security-Policy&quot;: [ &quot;default-src &#x27;self&#x27;&quot;, &quot;script-src &#x27;self&#x27; &#x27;unsafe-eval&#x27;&quot;, &quot;style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;&quot;, &quot;font-src &#x27;self&#x27;&quot; ], ... }, scripts: [ { type: &quot;text/javascript&quot;, src: &#x27;/assets/bundle.min.js&#x27; } ] } I18n Configuration The i18n configuration allows you to manage internationalization (i18n) in your CMMV application by defining the directory for locale files and setting a default language. i18n: { localeFiles: &quot;./src/locale&quot;, default: &quot;en&quot; } localeFiles: Directory where the translation files for different languages are stored. default: The default language to be used when no specific locale is selected. View Configuration The view configuration lets you control how the HTML output is processed. It includes options for extracting inline scripts and minifying HTML for optimized performance. view: { extractInlineScript: true, minifyHTML: true } Head Configuration The head configuration controls the &lt;head&gt; section of your HTML document, allowing you to define meta tags, attributes for the &lt;html&gt; tag, and links such as favicons. head: { title: &quot;CMMV&quot;, htmlAttrs: { lang: &quot;pt-br&quot; }, meta: [ { charset: &#x27;utf-8&#x27; }, { name: &#x27;viewport&#x27;, content: &#x27;width=device-width&#x27; } ... ], link: [ { rel: &#x27;icon&#x27;, href: &#x27;assets/favicon/favicon.ico&#x27; } ... ] } Headers Configuration The headers configuration allows you to define HTTP headers such as Content-Security-Policy (CSP), which help secure your application. headers: { &quot;Content-Security-Policy&quot;: [ &quot;default-src &#x27;self&#x27;&quot;, &quot;script-src &#x27;self&#x27; &#x27;unsafe-eval&#x27;&quot;, &quot;style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;&quot;, &quot;font-src &#x27;self&#x27;&quot; ] } Scripts Configuration The scripts configuration specifies external or internal JavaScript files that should be included in the HTML output. scripts: [ { type: &quot;text/javascript&quot;, src: &#x27;/assets/bundle.min.js&#x27;, defer: &quot;defer&quot; } ]",
        "hierarchy": {
            "lvl0": "View",
            "lvl1": "Key Features of @cmmv/view",
            "lvl2": "Scripts Configuration",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "rpc/benchmarks",
        "url": "/rpc/benchmarks.html",
        "content": "RPC Benchmarks This report demonstrates a simple benchmark test for making 1000 HTTP requests to a server, including the size of the request and response headers, and estimates for the average time it takes to process each request. The data payload being tested is a simple JSON object { “Hello”: “World” }, and the following headers are used for the request and response. Request and Response Headers: Response Headers: HTTP/1.1 200 OK Access-Control-Allow-Origin: * Cross-Origin-Opener-Policy: same-origin Cross-Origin-Resource-Policy: same-origin Origin-Agent-Cluster: ?1 Referrer-Policy: no-referrer Strict-Transport-Security: max-age=15552000; includeSubDomains X-Content-Type-Options: nosniff X-DNS-Prefetch-Control: off X-Download-Options: noopen X-Frame-Options: SAMEORIGIN X-Permitted-Cross-Domain-Policies: none X-XSS-Protection: 0 Content-Security-Policy: default-src &#x27;self&#x27; &#x27;nonce-f0954b9e&#x27;; script-src &#x27;self&#x27; &#x27;unsafe-eval&#x27; &#x27;unsafe-inline&#x27; &#x27;nonce-f0954b9e&#x27;; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; https://cdnjs.cloudflare.com &#x27;nonce-f0954b9e&#x27;; font-src &#x27;self&#x27; https://cdnjs.cloudflare.com &#x27;nonce-f0954b9e&#x27; Content-Type: text/html; charset=utf-8 ETag: W/&quot;5d67-lioHfOkcIYpcQS7nNQKGH5y6XRk&quot; Vary: Accept-Encoding Content-Encoding: gzip Date: Wed, 04 Sep 2024 12:41:13 GMT Connection: keep-alive Keep-Alive: timeout=5 Transfer-Encoding: chunked Request Headers: GET /docs/3-RPC%2F0-Overview HTTP/1.1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate, br, zstd Accept-Language: pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7,es;q=0.6 Cache-Control: max-age=0 Connection: keep-alive Host: localhost:3000 If-None-Match: W/&quot;5cee-HeytSiLTPcs5WSj3kRViDNpXpt0&quot; Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari For the benchmark test, we analyzed the total size and time for processing 1000 HTTP requests. Here is the detailed breakdown: Header Sizes: Response Headers Size: 925 bytes Request Headers Size: 783 bytes Data Size: 20 bytes (JSON payload { “Hello”: “World” }) Total Size per Request: Total Size per Request: 1,728 bytes Total Size for 1000 Requests: Total Size for 1000 Requests: 1,728,000 bytes (1.73 MB) Timing Analysis: Assuming an average internet connection with: DNS Lookup: 50ms Time to First Byte (TTFB): 100ms Ping Time: 100ms Content Download Time: 50ms Total Time per Request: 300ms Total Time for 1000 Requests: 300 seconds (5 minutes) Protobuf + Websocket For this benchmark, we analyzed the total size and time for 1000 WebSocket requests using Protobuf for binary communication. In this scenario, the Protobuf schema is loaded only once (26 KB), and the data sent over WebSocket is minimal due to the efficient binary format. We assume the same payload, but in a compact, serialized format using Protobuf. Assumptions: Initial Protobuf Load: 26 KB (loaded once, cached) Data Size (Binary Format): Approximately 12 bytes (based on the compact binary representation of { “Hello”: “World” }) WebSocket Headers: WebSocket doesn’t require large headers like HTTP, leading to much smaller overhead. Persistent Connection: The WebSocket connection stays open, eliminating the need for repeated DNS lookups, TTFB, etc., which are required for each HTTP request. Total Size per Request: Binary Data Size per Request: 12 bytes WebSocket Header Overhead: 2-6 bytes per frame (depending on the frame structure and opcode) Total Size per Request: ~18 bytes Total Size for 1000 Requests: Protobuf Schema Size (only loaded once): 26 KB (26,000 bytes) Total Data Transferred: 18 bytes * 1000 requests = 18,000 bytes Total Size for 1000 Requests: 26,000 bytes (schema) + 18,000 bytes (data) = 44,000 bytes (44 KB) Timing Analysis: In a WebSocket connection: No DNS Lookup: DNS lookup occurs only once during the initial connection. No TTFB: The connection is persistent, so there’s no time-to-first-byte for each request. Ping Time: 100ms (assumed for network latency) Content Download Time (Binary Data): Much smaller than HTTP/JSON. Total Time per Request: ~100ms (ping + minimal processing) Total Time for 1000 Requests: 100 seconds (1 minute 40 seconds) Conclusion: Total Data Transferred: Only 44 KB for 1000 requests compared to 1.73 MB in HTTP/JSON. Total Time: 100 seconds (1 minute 40 seconds) for 1000 WebSocket requests, compared to 5 minutes for HTTP requests. The binary communication over WebSocket using Protobuf is significantly more efficient in terms of both data size and processing time. The persistent connection eliminates the overhead associated with repeated DNS lookups and TTFB, while the compact binary format reduces the payload size considerably.",
        "hierarchy": {
            "lvl0": "RPC Benchmarks",
            "lvl1": "",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "rpc/gateways",
        "url": "/rpc/gateways.html",
        "content": "Gateway When the @cmmv/ws module is present in the project, it automatically creates WebSocket (WS) gateways based on the defined contracts. These gateways handle Remote Procedure Call (RPC) interactions in a binary format, optimizing both the size of the transmitted data and the process of identifying the correct handlers for the messages. RPC Gateways: Each contract generates a WebSocket gateway that allows interaction between clients and the server using efficient binary communication. Automatic Request Packaging: The @cmmv/ws module automatically packages responses and parses incoming requests using the contract definitions, ensuring that all messages conform to the expected structure. WsCall Contract: The WsCall contract is a crucial component that serves as an index for system packets and defines the available messages in each contract. It helps minimize the number of bytes sent during interactions and allows easy identification of which handler should process each message. Here is an example of the WsCall contract that serves as the foundation for these interactions: import { AbstractContract, Contract, ContractField } from &quot;@cmmv/core&quot;; @Contract({ controllerName: &quot;WsCall&quot;, protoPath: &quot;src/protos/ws.proto&quot;, protoPackage: &quot;ws&quot;, directMessage: true, generateController: false }) export class WSContract extends AbstractContract { @ContractField({ protoType: &#x27;int32&#x27; }) contract: number; @ContractField({ protoType: &#x27;int32&#x27; }) message: number; @ContractField({ protoType: &#x27;bytes&#x27; }) data: Uint8Array; } Client Sends a Request: When the client sends a request, it is formatted according to the WsCall contract, containing: contract: A number identifying which contract the message belongs to. message: A number identifying the specific message or action. data: A binary payload (usually a serialized object) containing the actual data of the request. Parsing the Request: Upon receiving the request, the system parses the contract and message fields to determine: Which contract the request corresponds to. Which handler in the gateway should process the message. Calling the Correct Handler: Once the system identifies the contract and message, it routes the request to the appropriate handler in the WebSocket gateway. The handler then processes the request and sends back a response in the same efficient binary format. Example Gateway When a contract is created, the WebSocket gateway might look like this: import { Rpc, Message, Data, Socket, RpcUtils } from &quot;@cmmv/ws&quot;; import { TaskService } from &#x27;../services/task.service&#x27;; @Rpc(&quot;task&quot;) export class TaskGateway { constructor(private readonly taskService: TaskService) {} @Message(&quot;GetAllTaskRequest&quot;) async getAll(@Socket() socket) { const items = await this.taskService.getAll(); const response = await RpcUtils.pack( &quot;task&quot;, &quot;GetAllTaskResponse&quot;, items ); socket.send(response); } @Message(&quot;AddTaskRequest&quot;) async add(@Data() data, @Socket() socket) { const result = await this.taskService.add(data.item); const response = await RpcUtils.pack( &quot;task&quot;, &quot;AddTaskResponse&quot;, { item: result } ); socket.send(response); } } Binary Communication: Uses binary data (via Uint8Array) for fast and compact message exchanges. Efficient Message Handling: The contract and message fields allow quick identification of the correct handler, minimizing overhead. Custom Gateways: Developers can extend or customize gateways by creating specific handlers for different contract messages. This approach ensures that communication between clients and the server is not only efficient but also structured and easy to manage. WebSocket Interceptor The interceptor is a key component in the @cmmv/ws system that handles the parsing and routing of incoming WebSocket messages. When a WebSocket packet is received from the client, the interceptor processes the data, decodes it according to the defined protocol, and dispatches it to the appropriate handler. Below is an explanation of how the WebSocket interceptor works step-by-step: The interceptor receives a socket and the binary data. The first step is to decode the binary data into a structured message using the WSCall contract: const message = plainToClass(WSCall, ProtoRegistry. retrieve(&quot;ws&quot;)?. lookupType(&quot;WsCall&quot;). decode(data) ); Next, the system retrieves the contract and message type from the ProtoRegistry: const contract = ProtoRegistry.retrieveByIndex(message.contract); const typeName = ProtoRegistry.retrieveTypes( message.contract, message.message ); retrieveByIndex(message.contract): Retrieves the contract by its index in the registry. retrieveTypes(message.contract, message.message): Determines the specific type of message based on the contract and message identifiers. This will be used to find the correct handler. Once the contract and message type are identified, the interceptor checks if the message type has a registered handler: if (contract &amp;&amp; this.registeredMessages.has(typeName)) { const { instance, handlerName, params } = this.registeredMessages.get(typeName); const realMessage = contract .lookupType(typeName) .decode(message.data); } Finally, the handler is executed with the mapped arguments: const args = params .sort((a, b) =&gt; a.index - b.index) .map(param =&gt; { switch (param.paramType) { case &#x27;data&#x27;: return realMessage; case &#x27;socket&#x27;: return socket; default: return undefined; } }); try { instance[handlerName](...args); } catch (e) { this.logger.error(e.message); } This process ensures that all WebSocket messages are efficiently routed to the appropriate handler based on the contract and message type. Utils The RpcUtils class provides utility methods to work with Protobuf serialization and message packaging for RPC communication. It is primarily used to convert JavaScript objects into Protobuf-encoded binary buffers, as well as to pack RPC messages for transmission over WebSocket or other binary protocols. Method Description generateBuffer(protoFile, namespace, data) Converts a JavaScript object into a Protobuf-encoded buffer using the specified proto file and message type. pack(contractName, messageName, data) Packs a message into a Protobuf-encoded buffer for RPC communication, including contract and message metadata. generateBuffer(protoFile: string, namespace: string, data: any): Promise&lt;Uint8Array&gt; This method generates a Protobuf-encoded buffer from a JavaScript object using a specific proto file and message type. Parameters: protoFile (string): The name of the proto file that defines the message structure. namespace (string): The name of the message type (namespace) within the proto file. data (any): The JavaScript object containing the data to be encoded into Protobuf format. Returns: Promise&lt;Uint8Array | null&gt;: A promise that resolves to a Uint8Array representing the encoded Protobuf message, or null if an error occurs. const buffer = await RpcUtils.generateBuffer( &#x27;myProtoFile&#x27;, &#x27;MyMessage&#x27;, { id: 1, name: &#x27;example&#x27; } ); if (buffer) { // buffer is ready to be sent via WebSocket or saved } else { // handle error } Pack pack(contractName: string, messageName: string, data?: any): Promise&lt;Uint8Array | null&gt; The pack method prepares a Protobuf-encoded message for RPC communication. It includes metadata such as the contract and message indices, along with the actual message data. Parameters: contractName (string): The name of the contract associated with the message. messageName (string): The name of the message within the contract. data (any, optional): The data to be included in the message, which will be encoded as Protobuf. Returns: Promise&lt;Uint8Array | null&gt;: A promise that resolves to a Uint8Array representing the packed message, or null if an error occurs. const packedMessage = await RpcUtils.pack( &#x27;TaskContract&#x27;, &#x27;AddTaskRequest&#x27;, { taskId: 1, taskLabel: &#x27;New Task&#x27; } ); if (packedMessage) { // ready to send packed message via WebSocket or other binary protocol } else { // handle error }",
        "hierarchy": {
            "lvl0": "Gateway",
            "lvl1": "Example Gateway",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "rpc/websocket",
        "url": "/rpc/websocket.html",
        "content": "Websocket The @cmmv/ws module is a key component responsible for handling WebSocket communication in the CMMV framework. It is crucial for the functioning of Remote Procedure Calls (RPC) in the system, allowing for seamless client-server interactions. This module automatically generates WebSocket gateways based on the contracts defined in your project, enabling binary RPC request and response handling. Automatic Gateway Generation: When the @cmmv/ws module is added, it automatically generates WebSocket gateways from the contracts defined in your project. These gateways serve as the communication endpoints for RPC requests and responses. Binary Protocol: The module communicates using a binary format for all RPC requests and responses. This ensures efficient data transfer and supports complex data structures. It is important to note that simple text-based communication is not supported by this module. Contract-based Communication: The communication follows the structure defined in your contracts, ensuring type-safe, well-structured data handling. The contracts are written using the @Contract decorator from the @cmmv/core module. Below is an example of a contract that defines the structure for task-related RPC operations. The contract is annotated with the @Contract and @ContractField decorators to specify the fields and types. import { AbstractContract, Contract, ContractField } from &#x27;@cmmv/core&#x27;; @Contract({ controllerName: &#x27;Task&#x27;, protoPath: &#x27;src/protos/task.proto&#x27;, protoPackage: &#x27;task&#x27;, }) export class TasksContract extends AbstractContract { @ContractField({ protoType: &#x27;string&#x27;, unique: true, }) label: string; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false, }) checked: boolean; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false, }) removed: boolean; } The contract above will generate a WebSocket gateway, responsible for handling RPC operations like adding, updating, deleting, and retrieving tasks. Below is an example of a generated gateway: // Generated automatically by CMMV import { Rpc, Message, Data, Socket, RpcUtils } from &quot;@cmmv/ws&quot;; import { plainToClass } from &#x27;class-transformer&#x27;; import { TaskEntity } from &#x27;../entities/task.entity&#x27;; import { AddTaskRequest, UpdateTaskRequest, DeleteTaskRequest } from &quot;../protos/task&quot;; import { TaskService } from &#x27;../services/task.service&#x27;; @Rpc(&quot;task&quot;) export class TaskGateway { constructor(private readonly taskservice: TaskService) {} @Message(&quot;GetAllTaskRequest&quot;) async getAll(@Socket() socket) { try { const items = await this.taskservice.getAll(); const response = await RpcUtils.pack( &quot;task&quot;, &quot;GetAllTaskResponse&quot;, items ); if (response) socket.send(response); } catch (e) { // Handle error } } @Message(&quot;AddTaskRequest&quot;) async add(@Data() data: AddTaskRequest, @Socket() socket) { try { const entity = plainToClass(TaskEntity, data.item); const result = await this.taskservice.add(entity); const response = await RpcUtils.pack( &quot;task&quot;, &quot;AddTaskResponse&quot;, { item: result, id: result.id } ); if (response) socket.send(response); } catch (e) { // Handle error } } @Message(&quot;UpdateTaskRequest&quot;) async update(@Data() data: UpdateTaskRequest, @Socket() socket) { try { const entity = plainToClass(TaskEntity, data.item); const result = await this.taskservice.update(data.id, entity); const response = await RpcUtils.pack( &quot;task&quot;, &quot;UpdateTaskResponse&quot;, { item: result, id: result.id } ); if (response) socket.send(response); } catch (e) { // Handle error } } @Message(&quot;DeleteTaskRequest&quot;) async delete(@Data() data: DeleteTaskRequest, @Socket() socket) { try { const result = (await this.taskservice.delete(data.id)).success; const response = await RpcUtils.pack( &quot;task&quot;, &quot;DeleteTaskResponse&quot;, { success: result, id: data.id } ); if (response) socket.send(response); } catch (e) { // Handle error } } } The gateway interacts with services (e.g., TaskService) to process the data. These services perform business logic and interact with the database or other back-end components. The @cmmv/ws module is a powerful tool for handling binary WebSocket communication in the CMMV framework. It automatically generates WebSocket gateways based on contracts, handling RPC requests and responses efficiently using binary data. This ensures secure, performant communication and seamless integration with the rest of the CMMV system. By utilizing this module, developers can easily implement real-time functionality in their applications, leveraging the built-in RPC system for tasks such as data synchronization, real-time updates, and more.",
        "hierarchy": {
            "lvl0": "Websocket",
            "lvl1": "",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "rpc/proto",
        "url": "/rpc/proto.html",
        "content": "Proto The CMMV framework provides seamless integration between server-side contracts and frontend applications using Protobuf as the communication protocol. By defining contracts in a structured way, CMMV automatically generates Protobuf files and TypeScript types, allowing for a smooth and efficient integration of RPC-based communication. In this section, we’ll walk through how the contract definition in the backend is transformed into Protobuf schema, TypeScript types, and integrated into the frontend for real-time binary communication. In CMMV, contracts are defined using the @Contract and @ContractField decorators. Below is an example contract for managing tasks: import { AbstractContract, Contract, ContractField } from &quot;@cmmv/core&quot;; @Contract({ controllerName: &quot;Task&quot;, protoPath: &quot;src/protos/task.proto&quot;, protoPackage: &quot;task&quot; }) export class TasksContract extends AbstractContract { @ContractField({ protoType: &#x27;string&#x27;, unique: true }) label: string; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false }) checked: boolean; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false }) removed: boolean; } @Contract: Defines the metadata for the contract, including the name of the controller, the database type (mongodb), the path to the Protobuf file, and the Protobuf package name. @ContractField: Defines individual fields of the contract, specifying their Protobuf type and any additional constraints (e.g., unique values, default values). .proto Based on the contract above, CMMV will automatically generate the corresponding .proto file and associated TypeScript types. This generated Protobuf file allows for binary communication between the server and client. // Proto generated automatically by CMMV syntax = &quot;proto3&quot;; package task; message Task { string label = 1; bool checked = 2; bool removed = 3; } message AddTaskRequest { Task item = 1; } message AddTaskResponse { Task item = 1; } message UpdateTaskRequest { string id = 1; Task item = 2; } message UpdateTaskResponse { Task item = 1; } message DeleteTaskRequest { string id = 1; } message DeleteTaskResponse { bool success = 1; } message GetAllTaskRequest {} message GetAllTaskResponse { repeated Task items = 1; } Types CMMV also generates TypeScript types for the Protobuf messages, ensuring strong typing across the entire application. These types are generated alongside the Protobuf files, and look like the following: // Types generated automatically by CMMV export namespace Task { export type label = string; export type checked = boolean; export type removed = boolean; } export interface AddTaskRequest { item: Task; } export interface AddTaskResponse { item: Task; } export interface UpdateTaskRequest { id: string; item: Task; } export interface UpdateTaskResponse { item: Task; } export interface DeleteTaskRequest { id: string; } export interface DeleteTaskResponse { success: boolean; } export interface GetAllTaskRequest {} export interface GetAllTaskResponse { items: Task[]; } On the frontend, CMMV automatically integrates the Protobuf schema for seamless communication. With WebSocket support and binary communication through Protobuf, the frontend can make RPC (Remote Procedure Call) requests to the server using the defined contract methods. By using CMMV’s auto-generated functions, such as AddTaskRequest, UpdateTaskRequest, etc., developers can interact with the backend contract without writing additional code for parsing and validation. The functions are available directly in the context of the view, enabling effortless interaction from the UI. Frontend On the frontend, CMMV automatically integrates the Protobuf schema for seamless communication. With WebSocket support and binary communication through Protobuf, the frontend can make RPC (Remote Procedure Call) requests to the server using the defined contract methods. By using CMMV’s auto-generated functions, such as AddTaskRequest, UpdateTaskRequest, etc., developers can interact with the backend contract without writing additional code for parsing and validation. The functions are available directly in the context of the view, enabling effortless interaction from the UI. &lt;div class=&quot;todo-box&quot; scope&gt; &lt;h1 s-i18n=&quot;todo&quot;&gt;&lt;/h1&gt; &lt;div c-show=&quot;todolist?.length &gt; 0&quot; s:todolist=&quot;services.task.getAll()&quot; &gt; &lt;div c-show=&quot;todolist&quot; c-for=&quot;(item, key) in todolist&quot; class=&quot;todo-item&quot; &gt; &lt;div class=&quot;todo-item-content&quot;&gt; &lt;input type=&quot;checkbox&quot; c-model=&quot;item.checked&quot; @change=&quot;UpdateTaskRequest(item)&quot; &gt;&lt;/input&gt; &lt;label :class=&quot;{&#x27;todo-item-checked&#x27;: item.checked }&quot; &gt;{{ item.label }}&lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;todo-btn-remove&quot; s-i18n=&quot;remove&quot; @click=&quot;DeleteTaskRequest(item.id)&quot; &gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;todo-input-box&quot;&gt; &lt;input c-model=&quot;label&quot; class=&quot;todo-input&quot;&gt; &lt;button class=&quot;todo-btn-add&quot; s-i18n=&quot;add&quot; @click=&quot;addTask&quot; &gt;&lt;/button&gt; &lt;/div&gt; &lt;pre&gt;{{ todolist }}&lt;/pre&gt; &lt;/div&gt; &lt;script s-setup&gt; export default { layout: &quot;default&quot;, data(){ return { todolist: [], label: &quot;&quot; } }, methods: { addTask(){ this.AddTaskRequest({ label: this.label }); this.label = &#x27;&#x27;; }, DeleteTaskResponse(data){ if (data.success) { const index = this.todolist.findIndex( item =&gt; item.id === data.id ); if (index !== -1) this.todolist.splice(index, 1); } }, AddTaskResponse(data) { this.UpdateTaskResponse(data); }, UpdateTaskResponse(data) { const index = this.todolist.findIndex( item =&gt; item.id === data.id ); if (index !== -1) this.todolist[index] = { ...data.item, id: data.id }; else this.todolist.push({ ...data.item, id: data.id }); } } } &lt;/script&gt; CMMV provides flexibility in loading the Protobuf contracts: PreLoad Contracts: By default, all contracts are pre-processed, converted into JSON, and included in the main JavaScript bundle. This allows for faster execution at runtime since the contracts are already available, and the frontend can immediately start making RPC calls. On-Demand Loading: In cases where there are many contracts, or if you want to optimize the initial page load, you can set preLoadContracts = false. This way, contracts are fetched on-demand when they are needed, caching them locally to avoid multiple network requests. By automatically generating Protobuf contracts, TypeScript types, and integrating them into the frontend, CMMV simplifies communication between the server and client. The use of WebSocket and Protobuf ensures fast, efficient, and type-safe communication, reducing the overhead associated with traditional HTTP/JSON-based systems.",
        "hierarchy": {
            "lvl0": "Proto",
            "lvl1": ".proto",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "rpc/overview",
        "url": "/rpc/overview.html",
        "content": "RPC In modern web applications, reducing overhead and increasing efficiency in communication is essential. A common approach in traditional systems is the use of HTTP/JSON, but this method introduces significant inefficiencies: HTTP Overhead: HTTP headers in both requests and responses are often larger than the payload itself, especially for small data exchanges. This leads to unnecessary bandwidth consumption, particularly in real-time applications where the overhead is repeatedly incurred. JSON’s Inefficiencies: Although JSON is human-readable and widely used, it is verbose and lacks the performance needed for high-throughput systems. Parsing and serializing JSON adds extra computational overhead compared to binary formats, making it suboptimal for systems requiring quick response times and high concurrency. Why CMMV Uses RPC and WebSocket/Protobuf WebSocket provides persistent, full-duplex communication between the server and the client, reducing the need to repeatedly establish and tear down connections as seen in HTTP. This alone cuts down significant overhead by eliminating connection re-establishment, headers, and other metadata required by HTTP. However, CMMV doesn’t stop at WebSockets. It also leverages Protocol Buffers (Protobuf) for encoding data. Protobuf is a binary serialization format that significantly reduces the size of the messages exchanged, as it uses a compact binary representation, unlike the verbose text format of JSON. This leads to: Reduced Payload Sizes: Protobuf is much more efficient at encoding data, reducing both the size of requests and responses, resulting in faster data transfer. Improved Speed: Binary formats like Protobuf are faster to serialize and deserialize compared to JSON. This improves both performance on the server side (processing multiple requests) and the client side (faster rendering or interaction). Schema Enforcement: Unlike JSON, which is flexible but prone to errors, Protobuf enforces a structured schema. This ensures that the data being sent and received is well-defined and consistent, preventing mismatches and making it easier to maintain and extend over time. HTTP/JSON vs. WebSocket/Protobuf Latency: WebSocket/Protobuf reduces latency in client-server interactions, enabling near real-time responses. It avoids the overhead of stateless HTTP and the verbosity of JSON. Efficiency: WebSocket connections remain open, allowing for continuous data exchange without re-establishing connections for each transaction. Protobuf further enhances this by ensuring the data exchanged is minimal, leading to better bandwidth utilization. Scalability: Systems using WebSocket/Protobuf scale more effectively because they reduce both network and computational overhead. This becomes critical in applications that need to handle many clients simultaneously, such as multiplayer games or real-time analytics platforms. In scenarios where real-time communication, such as gaming, financial trading platforms, or IoT systems, is required, WebSocket/Protobuf excels over traditional HTTP/JSON due to its ability to handle many concurrent connections with lower latency and better data throughput. By choosing RPC via WebSocket/Protobuf as the default communication protocol, CMMV ensures that developers can build efficient, scalable applications without the burden of HTTP’s overhead or JSON’s inefficiency, leading to faster, more reliable systems. Protobuf Protocol Buffers (Protobuf) is a language-neutral, platform-neutral binary serialization format developed by Google. In CMMV, Protobuf was selected as the communication layer due to its efficiency, structure, and performance benefits over alternatives like JSON or XML. Compact and Efficient: Protobuf encodes data in a binary format, significantly reducing the size of transmitted data compared to text formats like JSON. This leads to faster transmission, crucial for real-time applications like gaming or financial systems. Speed: Binary serialization in Protobuf is far quicker than JSON serialization/deserialization, providing faster data processing and reducing computational load. Schema Enforcement: Protobuf requires a predefined schema for data, ensuring that data structures are strictly typed and versioned. This avoids inconsistencies during client-server communication, improving reliability in distributed systems. Language and Platform Agnostic: Protobuf supports multiple programming languages and platforms, allowing CMMV applications to remain flexible across different environments. Efficient Overhead Management: Protobuf allows for more efficient use of bandwidth and lower CPU usage, making it ideal for systems requiring high throughput and low latency, like RPC-based communication in CMMV. By using Protobuf, CMMV ensures optimal performance in data serialization, making communication efficient, scalable, and reliable across a range of applications. Instalation To implement WebSocket communication using Protobuf in CMMV, follow these steps: $ npm install @cmmv/protobuf @cmmv/ws protobufjs or $ yarn add @cmmv/protobuf @cmmv/ws protobufjs Application setup: import { Application } from &quot;@cmmv/core&quot;; import { ExpressAdapter, ExpressModule } from &quot;@cmmv/http&quot;; import { ProtobufModule } from &quot;@cmmv/protobuf&quot;; import { WSModule, WSAdapter } from &quot;@cmmv/ws&quot;; import { ViewModule } from &quot;@cmmv/view&quot;; Application.create({ httpAdapter: ExpressAdapter, wsAdapter: WSAdapter, modules: [ ExpressModule, ProtobufModule, WSModule, ViewModule ], contracts: [...], }); WSAdapter: Handles WebSocket connections. ProtobufModule: Defines message structures with Protocol Buffers for communication. WSModule: Manages WebSocket connections, utilizing Protobuf messages for efficient data transmission. Settings .cmmv.config.js module.exports = { server: { host: process.env.HOST || &quot;0.0.0.0&quot;, port: process.env.PORT || 3000, ... }, rpc: { enabled: true, preLoadContracts: true }, ... }; In CMMV, contracts are processed in .proto format and stored in the /src/proto directory along with TypeScript types. These contracts are loaded into the frontend using protobufjs in two ways: Preloading Contracts: Setting preLoadContracts = true converts all contracts to JSON, which are then bundled with the application. This allows for efficient caching, especially through CDNs. On-Demand Loading: Setting preLoadContracts = false loads .proto files as needed upon receiving the first message that requires the contract, caching them locally for future use. This approach is useful for applications with numerous contracts. Integration The CMMV framework simplifies communication in the frontend by binding Protobuf methods directly to the view context. This allows developers to invoke RPC methods like AddTaskRequest and DeleteTaskRequest within their views seamlessly, as demonstrated in the example to-do list. &lt;div class=&quot;todo-box&quot; scope&gt; &lt;h1 s-i18n=&quot;todo&quot;&gt;&lt;/h1&gt; &lt;div c-show=&quot;todolist?.length &gt; 0&quot; s:todolist=&quot;services.task.getAll()&quot; &gt; &lt;div c-show=&quot;todolist&quot; c-for=&quot;(item, key) in todolist&quot; class=&quot;todo-item&quot; &gt; &lt;div class=&quot;todo-item-content&quot;&gt; &lt;input type=&quot;checkbox&quot; c-model=&quot;item.checked&quot; @change=&quot;UpdateTaskRequest(item)&quot; &gt;&lt;/input&gt; &lt;label :class=&quot;{&#x27;todo-item-checked&#x27;: item.checked}&quot; &gt;{{ item.label }}&lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;todo-btn-remove&quot; s-i18n=&quot;remove&quot; @click=&quot;DeleteTaskRequest(item.id)&quot; &gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;todo-input-box&quot;&gt; &lt;input c-model=&quot;label&quot; class=&quot;todo-input&quot;&gt; &lt;button class=&quot;todo-btn-add&quot; s-i18n=&quot;add&quot; @click=&quot;addTask&quot; &gt;&lt;/button&gt; &lt;/div&gt; &lt;pre&gt;{{ todolist }}&lt;/pre&gt; &lt;/div&gt; &lt;script s-setup&gt; export default { layout: &quot;default&quot;, head: { meta: [ { name: &quot;description&quot;, content: &quot;CMMV Todolist sample&quot; }, { name: &quot;keywords&quot;, content: &quot;cmmv, contract model, websocket&quot; } ], link: [ { rel: &quot;stylesheet&quot;, href: &quot;/assets/styles/todo.css&quot; }, { rel: &quot;canonical&quot;, href: &quot;https://cmmv.io&quot; }, ] }, data(){ return { todolist: [], label: &quot;&quot; } }, methods: { addTask(){ this.AddTaskRequest({ label: this.label }); this.label = &#x27;&#x27;; }, DeleteTaskResponse(data){ if (data.success) { const index = this.todolist.findIndex( item =&gt; item.id === data.id ); if (index !== -1) this.todolist.splice(index, 1); } }, AddTaskResponse(data) { this.UpdateTaskResponse(data); }, UpdateTaskResponse(data) { const index = this.todolist.findIndex( item =&gt; item.id === data.id ); if (index !== -1) this.todolist[index] = { ...data.item, id: data.id }; else this.todolist.push({ ...data.item, id: data.id }); } } } &lt;/script&gt; The integration of Protobuf with CMMV’s transpiler offers significant advantages over traditional methods like protoc. While protoc generates a large volume of boilerplate code, much of it may be unnecessary depending on the project’s scope. CMMV automatically integrates contracts with services like repositories, caches, and other modules, simplifying the development process. Instead of manually invoking generated code, CMMV injects Protobuf functions directly into the view layer, reducing overhead and avoiding redundant code generation, making it more efficient for modern web applications. This streamlined approach not only reduces complexity but also enhances performance by avoiding unnecessary intermediate files and services, focusing solely on the functional requirements.",
        "hierarchy": {
            "lvl0": "RPC",
            "lvl1": "Instalation",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "contracts/serialization",
        "url": "/contracts/serialization.html",
        "content": "Serialization Serialization and deserialization in a project using class-transformer are crucial for converting JavaScript objects into specific class instances and vice versa. In the example above, the Task class, automatically generated by @cmmv/core, can be serialized and validated, ensuring the application processes data safely and with correct typing. The goal of serialization is to transform data into appropriate class instances, ensuring the objects being manipulated have the correct properties and types. We use the class-transformer package for serializing and deserializing objects and class-validator to validate the data. Here’s an implementation of a Task model that represents a task and uses class-validator and class-transformer to ensure proper serialization and validation of fields: // Generated automatically by CMMV import { IsString, IsNotEmpty, IsBoolean } from &#x27;class-validator&#x27;; import { plainToClass, classToPlain } from &#x27;class-transformer&#x27;; export interface ITask { id?: any; label: string; checked: boolean; removed: boolean; } export class Task implements ITask { id?: any; @IsString({ message: &#x27;Invalid label&#x27; }) @IsNotEmpty({ message: &#x27;Invalid label&#x27; }) label: string; @IsBoolean({ message: &#x27;Invalid checked type&#x27; }) checked: boolean = false; @IsBoolean({ message: &#x27;Invalid removed type&#x27; }) removed: boolean = false; constructor(partial: Partial&lt;Task&gt;) { Object.assign(this, partial); } } plainToInstance: Converts plain objects (like JSON) into class instances, transforming a received JSON object into an instance of the Task class. instanceToPlain: Converts a class instance back into a plain object for serialization or sending in an HTTP response. Here’s how we convert a plain object representing a task into an instance of the Task class using plainToInstance: Deserializing import { plainToInstance } from &#x27;class-transformer&#x27;; // Plain object const plainTask = { label: &#x27;Complete report&#x27;, checked: true, removed: false, }; // Convert to a Task class instance const taskInstance = plainToInstance(Task, plainTask); console.log(taskInstance); // Instance of Task Serializing When the application needs to send data to a database or an API, it can serialize the class instance back into a plain object using instanceToPlain. import { instanceToPlain } from &#x27;class-transformer&#x27;; const taskInstance = new Task({ label: &#x27;Complete report&#x27;, checked: true }); // Convert to a plain object const plainTask = instanceToPlain(taskInstance); console.log(plainTask); // Plain object Data Validation Use validate from class-validator to check if the data is valid: import { validate } from &#x27;class-validator&#x27;; const taskInstance = new Task({ label: &#x27;&#x27;, checked: &#x27;true&#x27; }); validate(taskInstance).then(errors =&gt; { if (errors.length &gt; 0) { console.log(&#x27;Validation failed. Errors: &#x27;, errors); } else { console.log(&#x27;Validation succeeded&#x27;); } }); By using class-transformer and class-validator, you ensure that class instances are properly validated and easily converted between plain objects and class instances. This provides a strong validation layer and simplifies data handling, especially for APIs and databases.",
        "hierarchy": {
            "lvl0": "Serialization",
            "lvl1": "Deserializing",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "contracts/transform",
        "url": "/contracts/transform.html",
        "content": "Transform In CMMV, you can transform data within contracts using the transform parameter in the field decorator. The system utilizes the class-transformer (NPM) library to handle these transformations. This is particularly useful for converting input data into the appropriate format for entity and model classes, which are necessary for interactions with repositories, among other functionalities. exclude: Removes the field during serialization or deserialization. toClassOnly: Ensures that the transformation is only applied when converting to a class instance (useful for data integrity). transform: Allows for custom transformation logic such as encrypting, hashing, adding metadata, or converting dates. These transforms enable seamless handling of complex data formats like hashing passwords, generating timestamps, and converting or formatting incoming/outgoing data. Below are a few examples: import * as crypto from &#x27;crypto&#x27;; import { AbstractContract, Contract, ContractField } from &#x27;@cmmv/core&#x27;; @Contract({ controllerName: &#x27;User&#x27;, protoPath: &#x27;src/protos/user.proto&#x27;, protoPackage: &#x27;user&#x27;, }) export class UsersContract extends AbstractContract { @ContractField({ protoType: &#x27;string&#x27;, validations: [&quot;IsString&quot;], // Example of simple transformation transform: ({ value }) =&gt; value.toUpperCase(), }) name: string; @ContractField({ protoType: &#x27;string&#x27;, // This field will be excluded in output exclude: false, // Will be processed only when converting to class toClassOnly: true, transform: ({ value }) =&gt; crypto.createHash(&#x27;sha256&#x27;) .update(value).digest(&#x27;hex&#x27;), // Hash the value }) password: string; } Data Security: You can easily encrypt or hash sensitive fields, such as passwords. Data Formatting: Automatically format dates, strings, or numbers before they are stored in a repository. Flexibility: You have full control over how input data is transformed, ensuring compatibility with backend services and databases. These transforms ensure that your contract and data structure remain flexible while allowing control over how data is processed during the request-response lifecycle. Input Data Assume you have the following plain JavaScript object as input data: { &quot;name&quot;: &quot;john doe&quot;, &quot;password&quot;: &quot;mypassword&quot; } Here’s what happens when plainToClass(UsersContract, input) is applied: { // Transformed to uppercase as specified name: &quot;JOHN DOE&quot;, // Not included in output due to `exclude` and `toClassOnly` options password: undefined } Name Transformation: The name field was converted to uppercase due to the transform function applied: value.toUpperCase(). Password Transformation: The password field was hashed using SHA-256, but it was excluded from the resulting class because of the exclude: true and toClassOnly: true options. This means the password is hashed when converting to the class instance, but it’s not included in the serialized output. Example Without Exclude If we remove the exclude: true option for password, it will still be hashed but included in the output: { // Transformed to uppercase name: &quot;JOHN DOE&quot;, // Hashed password password: &quot;5e884898da28047151d0e56f...&quot; } In this case, the transform function is applied, and the password is hashed, but it is not excluded from the output anymore. The toClassOnly: true ensures the transformation is only applied when converting to a class.",
        "hierarchy": {
            "lvl0": "Transform",
            "lvl1": "Input Data",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "contracts/validation",
        "url": "/contracts/validation.html",
        "content": "Validation CMMV supports automatic contract validation using the class-validator (NPM) module. During data insertion and update operations, CMMV can apply validation rules to contract fields, ensuring that data meets the defined criteria before being processed. You can specify validation rules for each field by adding the validations parameter. These validations are executed automatically during insert and update operations, and the system will return errors if any validation fails. Below is an example of a TasksContract, where each field is validated using different rules: import { AbstractContract, Contract, ContractField } from &#x27;@cmmv/core&#x27;; @Contract({ controllerName: &#x27;Task&#x27;, protoPath: &#x27;src/protos/task.proto&#x27;, protoPackage: &#x27;task&#x27;, }) export class TasksContract extends AbstractContract { @ContractField({ protoType: &#x27;string&#x27;, unique: true, validations: [{ type: &quot;IsString&quot;, message: &quot;Invalid label&quot; }, { type: &quot;IsNotEmpty&quot;, message: &quot;Label cannot be empty&quot; }] }) label: string; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false, validations: [{ type: &quot;IsBoolean&quot;, message: &quot;Invalid checked type&quot; }] }) checked: boolean; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false, validations: [{ type: &quot;IsBoolean&quot;, message: &quot;Invalid removed type&quot; }] }) removed: boolean; } Structure Each validation rule is configured using the validations parameter, which contains an array of validation objects. Each object can include the following properties: type: The type of validation to apply, such as IsString, IsNotEmpty, IsBoolean, etc. message (optional): A custom error message that will be shown when the validation fails. context (optional): Additional context information that can be included with the validation. Validation Types class-validator provides a wide range of validation types that can be applied to contract fields. Some common types are: Decorator Description IsDefined Checks if value is defined (!== undefined, !== null). This is the only decorator that ignores skipMissingProperties option. IsOptional Checks if given value is empty (=== null, === undefined) and if so, ignores all the validators on the property. Equals Checks if value equals (“===”) comparison. NotEquals Checks if value not equal (“!==”) comparison. IsEmpty Checks if given value is empty (=== ‘’, === null, === undefined). IsNotEmpty Checks if given value is not empty (!== ‘’, !== null, !== undefined). IsIn Checks if value is in an array of allowed values. IsNotIn Checks if value is not in an array of disallowed values. IsBoolean Checks if a value is a boolean. IsDate Checks if the value is a date. IsString Checks if the value is a string. IsNumber Checks if the value is a number. IsInt Checks if the value is an integer number. IsArray Checks if the value is an array. IsEnum Checks if the value is a valid enum. IsDivisibleBy Checks if the value is a number that’s divisible by another. IsPositive Checks if the value is a positive number greater than zero. IsNegative Checks if the value is a negative number smaller than zero. Min Checks if the given number is greater than or equal to given number. Max Checks if the given number is less than or equal to given number. MinDate Checks if the value is a date that’s after the specified date. MaxDate Checks if the value is a date that’s before the specified date. IsBooleanString Checks if a string is a boolean (e.g. is “true” or “false” or “1”, “0”). IsDateString Alias for @IsISO8601(). IsNumberString Checks if a string is a number. Contains Checks if the string contains the seed. NotContains Checks if the string not contains the seed. IsAlpha Checks if the string contains only letters (a-zA-Z). IsAlphanumeric Checks if the string contains only letters and numbers. IsDecimal Checks if the string is a valid decimal value. IsAscii Checks if the string contains ASCII chars only. IsBase32 Checks if a string is base32 encoded. IsBase58 Checks if a string is base58 encoded. IsBase64 Checks if a string is base64 encoded. IsIBAN Checks if a string is an IBAN (International Bank Account Number). IsBIC Checks if a string is a BIC (Bank Identification Code) or SWIFT code. IsByteLength Checks if the string’s length (in bytes) falls in a range. IsCreditCard Checks if the string is a credit card. IsCurrency Checks if the string is a valid currency amount. IsEthereumAddress Checks if the string is an Ethereum address using basic regex. Does not validate address checksums. IsDataURI Checks if the string is a data uri format. IsEmail Checks if the string is an email. IsFQDN Checks if the string is a fully qualified domain name (e.g. domain.com). IsHexColor Checks if the string is a hexadecimal color. IsISBN Checks if the string is an ISBN (version 10 or 13). IsUUID Checks if the string is a UUID (version 3, 4, 5 or all). ArrayContains Checks if array contains all values from the given array of values. ArrayNotEmpty Checks if given array is not empty. ArrayMinSize Checks if the array’s length is greater than or equal to the specified number. @Allow() Prevents stripping off the property when no other constraint is specified for it. When a contract is used in insert or update operations, CMMV automatically converts the incoming data to class instances, applies any transformations, and performs the validation according to the rules defined in the contract. If any field does not meet the validation criteria, the process is halted, and a list of validation errors is returned. This process ensures that data is always compliant with the rules defined in the contract, protecting the integrity of the system. Validation in Models When validations are defined in the contract fields, the CMMV framework automatically adds the corresponding class-validator decorators to the generated model. These decorators perform runtime validation to ensure the data adheres to the defined rules. The model generation process inserts the correct validation decorators above each field, along with any specified validation options, such as custom error messages. Here’s an example of how to define a contract with validations: import { AbstractContract, Contract, ContractField } from &#x27;@cmmv/core&#x27;; @Contract({ controllerName: &#x27;Task&#x27;, protoPath: &#x27;src/protos/task.proto&#x27;, protoPackage: &#x27;task&#x27;, }) export class TasksContract extends AbstractContract { @ContractField({ protoType: &#x27;string&#x27;, unique: true, validations: [{ type: &quot;IsString&quot;, message: &quot;Invalid label&quot; }, { type: &quot;IsNotEmpty&quot;, message: &quot;Invalid label&quot; }] }) label: string; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false, validations: [{ type: &quot;IsBoolean&quot;, message: &quot;Invalid checked type&quot; }] }) checked: boolean; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false, validations: [{ type: &quot;IsBoolean&quot;, message: &quot;Invalid removed type&quot; }] }) removed: boolean; } When the contract is processed by the framework, the following model is automatically generated. The decorators from class-validator are added to each field to perform validation according to the specified rules: // Generated automatically by CMMV import { IsString, IsNotEmpty, IsBoolean } from &#x27;class-validator&#x27;; export interface ITask { id?: any; label: string; checked: boolean; removed: boolean; } export class Task implements ITask { id?: any; @IsString({ message: &quot;Invalid label&quot; }) @IsNotEmpty({ message: &quot;Invalid label&quot; }) label: string @IsBoolean({ message: &quot;Invalid checked type&quot; }) checked: boolean = false; @IsBoolean({ message: &quot;Invalid removed type&quot; }) removed: boolean = false; } This approach ensures that data is validated correctly and that the model is generated dynamically based on the contract definitions, making the framework highly adaptable and efficient for managing validations across various models. Validation in Services In addition to the generated model, services also undergo changes to ensure that the data being input is properly validated before it’s processed or stored. Both the service generated by @cmmv/http and the repository implementation from @cmmv/repository include built-in validation mechanisms using the class-validator module. This validation ensures that all incoming data adheres to the rules specified in the contract fields before any database operations or further business logic are executed. Here’s an example of the add function in the service that is generated by the repository: async add(item: ITask, req?: any): Promise&lt;TaskEntity&gt; { return new Promise(async (resolve, reject) =&gt; { try{ Telemetry.start(&#x27;TaskService::Add&#x27;, req?.requestId); // Convert plain object to class and validate the data const newItem = plainToClass(Task, item, { exposeUnsetFields: true, enableImplicitConversion: true }); // Validate the newItem with class-validator const errors = await validate(newItem, { skipMissingProperties: true }); if (errors.length &gt; 0) { // If validation fails, return the errors Telemetry.end(&#x27;TaskService::Add&#x27;, req?.requestId); reject(errors); } else { // If validation passes, proceed with the repository const result = await Repository.insert&lt;TaskEntity&gt;( TaskEntity, newItem ); Telemetry.end(&#x27;TaskService::Add&#x27;, req?.requestId); resolve(result); } } catch(e){ Telemetry.end(&#x27;TaskService::Add&#x27;, req?.requestId); console.log(e); reject(e); } }); } Validation Step: Before performing any database operations, the input data is converted into a class instance using plainToClass and then validated using validate from class-validator. Error Handling: If validation fails, the process halts, and the errors are returned to the caller without proceeding to the database operation. Telemetry Tracking: Telemetry functions track the beginning and end of the add operation, ensuring that all actions are monitored for performance and logging. Repository Insert: Once the validation passes, the Repository.insert method inserts the validated data into the database. This mechanism ensures that all input data is validated in a consistent manner across the system, making it easy to manage and enforce validation rules at the service level, guaranteeing data integrity and reducing the risk of invalid data being stored or processed.",
        "hierarchy": {
            "lvl0": "Validation",
            "lvl1": "Structure",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "contracts/overview",
        "url": "/contracts/overview.html",
        "content": "Contracts CMMV’s contract system allows defining structured models that are used to auto-generate APIs, RPCs, and WebSocket routes. Contracts are defined using decorators applied to classes and their fields. Contracts are defined using the @Contract and @ContractField decorators. These decorators specify the contract name, file path for protocol buffers, and the type of the contract fields. import { AbstractContract, Contract, ContractField } from &quot;@cmmv/core&quot;; @Contract({ controllerName: &quot;Task&quot;, protoPath: &quot;src/protos/task.proto&quot;, protoPackage: &quot;task&quot; }) export class TasksContract extends AbstractContract { @ContractField({ protoType: &#x27;string&#x27;, unique: true }) label: string; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false }) checked: boolean; @ContractField({ protoType: &#x27;bool&#x27;, defaultValue: false }) removed: boolean; } @Contract Defines a contract class with the following options: controllerName: Specifies the contract name. controllerCustomPath: defines a custom path for the Rest controller. protoPath: Specifies the path to the protocol buffer file. protoPackage: defines the namespace of the contract generated in the protocol buffer. directMessage: defines whether RPC calls are direct or whether a crud structure should be created. generateController: defines whether or not transpilers should automatically generate drivers for this contract. generateController: defines access to data that requires authentication. @ContractField Defines a contract field with options such as: protoType: Field type (string, number, etc.). protoRepeated: defines whether the field is a list. defaultValue: sets a default value when creating the record. unique: Ensures uniqueness. index: defines that the field in question is an index. Supported Field Types CMMV supports a variety of field types: Basic Types: string, boolean, int, float, double, bytes, uuid Numeric Types: int32, int64, uint32, uint64, sint32, sint64, fixed32, fixed64, sfixed32, sfixed64 Advanced Types: json, jsonb, simpleArray, simpleJson, any Date and Time Types: date, time, timestamp When the application starts, the system automatically generates controllers, services, and generic entities based on the contract definitions. This process simplifies development by ensuring that common components like CRUD operations are pre-built and ready to use. Each entity and service is created dynamically to match the contract specifications, allowing the developer to focus on custom logic without having to manually define the basic structures. This auto-generation enhances efficiency and consistency throughout the application. HTTP Module To start a basic REST application using the @cmmv/http and @cmmv/view modules, follow these steps: npm install @cmmv/http @cmmv/view Set up the application: import { Application } from &quot;@cmmv/core&quot;; import { ExpressAdapter, ExpressModule } from &quot;@cmmv/http&quot;; import { ViewModule } from &quot;@cmmv/view&quot;; Application.create({ httpAdapter: ExpressAdapter, modules: [ ExpressModule, ViewModule ] }); To correctly implement a basic CMMV application using either the Express or Fastify adapters, you can use the following structure in your src/index.ts file. The system supports both Express and Fastify for handling HTTP requests, and the correct adapter is selected in the configuration. By default, when you start the application, it will be hosted at http://localhost:3000. This can be easily modified by configuring the port and bind address in the application’s configuration file. The configuration settings allow you to change the host, port, and other related properties for the HTTP server. These options will be covered in more detail later when we show the configuration file setup, providing flexibility to adjust your server’s runtime environment. Model The system will automatically generate the model for your entity in the following format: // Generated automatically by CMMV export interface Task { id?: any; label: string; checked: boolean; removed: boolean; } This Task interface defines the structure of the model, including optional and required fields. The id is optional, and fields such as label, checked, and removed are mandatory with defined types. You can further customize or extend this model based on your application’s needs. This base interface, such as the Task interface, will be utilized by other modules, including the repository module, to define entities in the database. By sharing the same interface structure across modules, it ensures consistency and type safety throughout the application. For example, the repository module will use this Task interface to map and handle database operations, making it easier to maintain and scale your application while ensuring that the data model aligns across different layers of the system. Controller The example contract provided above will automatically generate a controller at the path /src/controllers/task.controller.ts. This controller will be structured as follows: // Generated automatically by CMMV import { Telemetry } from &quot;@cmmv/core&quot;; import { Controller, Get, Post, Put, Delete, Queries, Param, Body, Request } from &#x27;@cmmv/http&#x27;; import { TaskService } from &#x27;../services/task.service&#x27;; import { Task } from &#x27;../models/task.model&#x27;; @Controller(&#x27;task&#x27;) export class TaskController { constructor(private readonly taskservice: TaskService) {} @Get() async getAll(@Queries() queries: any, @Request() req): Promise&lt;Task[]&gt; { Telemetry.start(&#x27;TaskController::GetAll&#x27;, req.requestId); let result = await this.taskservice.getAll(queries, req); Telemetry.end(&#x27;TaskController::GetAll&#x27;, req.requestId); return result; } @Get(&#x27;:id&#x27;) async getById(@Param(&#x27;id&#x27;) id: string, @Request() req): Promise&lt;Task&gt; { Telemetry.start(&#x27;TaskController::GetById&#x27;, req.requestId); let result = await this.taskservice.getById(id, req); Telemetry.end(&#x27;TaskController::GetById&#x27;, req.requestId); return result; } @Post() async add(@Body() item: Task, @Request() req): Promise&lt;Task&gt; { Telemetry.start(&#x27;TaskController::Add&#x27;, req.requestId); let result = await this.taskservice.add(item, req); Telemetry.end(&#x27;TaskController::Add&#x27;, req.requestId); return result; } @Put(&#x27;:id&#x27;) async update( @Param(&#x27;id&#x27;) id: string, @Body() item: Task, @Request() req ): Promise&lt;Task&gt; { Telemetry.start(&#x27;TaskController::Update&#x27;, req.requestId); let result = await this.taskservice.update(id, item, req); Telemetry.end(&#x27;TaskController::Update&#x27;, req.requestId); return result; } @Delete(&#x27;:id&#x27;) async delete( @Param(&#x27;id&#x27;) id: string, @Request() req ): Promise&lt;{ success: boolean, affected: number }&gt; { Telemetry.start(&#x27;TaskController::Delete&#x27;, req.requestId); let result = await this.taskservice.delete(id, req); Telemetry.end(&#x27;TaskController::Delete&#x27;, req.requestId); return result; } } You can create your own custom controllers by simply informing the application of their existence during the creation process or by including them via modules. This allows for greater flexibility and customization in your application’s architecture. When you define custom controllers, you can register them within the application module during the application setup phase, ensuring that they integrate smoothly with the core framework, such as HTTP routing or WebSocket handling, while adhering to your project’s specific requirements. Services Just like the controller, the service layer is also automatically generated by the system. In the absence of persistence modules such as the repository, a placeholder service is created, which temporarily stores records in memory while the application is online. This allows basic operations like adding, updating, and deleting data without a persistent store. Once a repository module is introduced, it overrides the default service, enabling direct interaction with a database, allowing data to be saved, queried, and managed efficiently from persistent storage. Here is an example of a service created using the repository module. This service interacts directly with the database using the repository pattern: // Generated automatically by CMMV import { Telemetry } from &quot;@cmmv/core&quot;; import { AbstractService, Service } from &#x27;@cmmv/http&#x27;; import { Repository } from &#x27;@cmmv/repository&#x27;; import { TaskEntity } from &#x27;../entities/task.entity&#x27;; @Service(&quot;task&quot;) export class TaskService extends AbstractService { public override name = &quot;task&quot;; async getAll(queries?: any, req?: any): Promise&lt;TaskEntity[]&gt; { const instance = Repository.getInstance(); const repository = instance.dataSource.getRepository(TaskEntity); Telemetry.start(&#x27;TaskService::GetAll&#x27;, req?.requestId); let result = await repository.find(); Telemetry.end(&#x27;TaskService::GetAll&#x27;, req?.requestId); return result; } async getById(id: string, req?: any): Promise&lt;TaskEntity&gt; { const instance = Repository.getInstance(); const repository = instance.dataSource.getRepository(TaskEntity); Telemetry.start(&#x27;TaskService::GetById&#x27;, req?.requestId); const item = await repository.findOneBy({ id }); Telemetry.end(&#x27;TaskService::GetById&#x27;, req?.requestId); if (!item) throw new Error(&#x27;Item not found&#x27;); return item; } async add(item: Partial&lt;TaskEntity&gt;, req?: any): Promise&lt;TaskEntity&gt; { const instance = Repository.getInstance(); const repository = instance.dataSource.getRepository(TaskEntity); Telemetry.start(&#x27;TaskService::Add&#x27;, req?.requestId); const result = await repository.save(item); Telemetry.end(&#x27;TaskService::Add&#x27;, req?.requestId); return result; } async update( id: string, item: Partial&lt;TaskEntity&gt;, req?: any ): Promise&lt;TaskEntity&gt; { const instance = Repository.getInstance(); const repository = instance.dataSource.getRepository(TaskEntity); Telemetry.start(&#x27;TaskService::Update&#x27;, req?.requestId); await repository.update(id, item); let result = await repository.findOneBy({ id }); Telemetry.end(&#x27;TaskService::Update&#x27;, req?.requestId); return result; } async delete( id: string, req?: any ): Promise&lt;{ success: boolean, affected: number }&gt; { const instance = Repository.getInstance(); const repository = instance.dataSource.getRepository(TaskEntity); Telemetry.start(&#x27;TaskService::Delete&#x27;, req?.requestId); const result = await repository.delete(id); Telemetry.end(&#x27;TaskService::Delete&#x27;, req?.requestId); return { success: result.affected &gt; 0, affected: result.affected }; } } More The installation of additional modules, such as RPC, caching, and authentication, will extend the functionality of your application. Each module introduces new capabilities, like enabling remote procedure calls, enhancing security through authentication, or improving performance with caching. For more details, specific documentation for each module is available in the sidebar, where you’ll find comprehensive guides on how to integrate and implement these modules effectively within your application.",
        "hierarchy": {
            "lvl0": "Contracts",
            "lvl1": "@Contract",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "overview/ecosystem",
        "url": "/overview/ecosystem.html",
        "content": "Ecosystem CMMV offers a range of plugins to complement applications, providing additional and optimized features for various needs. These plugins extend the framework’s capabilities by integrating communication, storage, caching, and more in a native and well-integrated manner. Below is a list of available plugins at the moment: Plugin Description @cmmv/core Core module providing the foundation for building applications, managing modules, services, and contracts. @cmmv/http HTTP server management module with support for multiple HTTP adapters, including default, Express, and Fastify. @cmmv/protobuf Provides Protobuf support for serialization and deserialization, optimizing binary communication. @cmmv/ws Native WebSocket support for real-time communication between the client and server. @cmmv/auth Handles user authentication and authorization, managing security and access control. @cmmv/cache Caching module to optimize performance by storing temporary data for quick access. @cmmv/queue Manages job queues and background processing tasks to help improve application performance. @cmmv/repository Database management with repositories for handling entities and persistent data access. @cmmv/scheduling Module for scheduling tasks and automating routines with task management support. @cmmv/view Server-Side Rendering (SSR) engine for rendering views, including its own template engine. @cmmv/reactivity Enables reactive data binding and management to create more dynamic applications. @cmmv/server Default HTTP server for high-performance applications, providing more control over server features. @cmmv/server-static Serves static files from the file system, enabling faster delivery of assets like HTML, CSS, and JS. @cmmv/body-parser Middleware for parsing incoming request bodies, including support for JSON and URL-encoded payloads. @cmmv/compression Compression middleware to reduce the size of the response body and improve application performance. @cmmv/cookie-parser Parses cookies in requests, making it easier to manage session and user data via cookies. @cmmv/cors Middleware for enabling Cross-Origin Resource Sharing (CORS), allowing secure cross-origin requests. @cmmv/etag ETag generation for response caching, improving efficiency by validating cached responses. @cmmv/helmet Security middleware to help protect applications by setting various HTTP headers. @cmmv/swagger Provides API documentation with Swagger integration, automatically generating OpenAPI specifications.",
        "hierarchy": {
            "lvl0": "Ecosystem",
            "lvl1": "",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "overview/decorators",
        "url": "/overview/decorators.html",
        "content": "Decorators Custom decorators in @cmmv allow you to extend and modify class behavior dynamically by using Reflect metadata. Here’s how you can create your own decorators: Use TypeScript’s ClassDecorator, MethodDecorator, or PropertyDecorator interfaces to define your custom decorators. function CustomClassDecorator(options?: any): ClassDecorator { return (target: object) =&gt; { Reflect.defineMetadata(&#x27;custom_metadata&#x27;, options, target); }; } This stores metadata (options) associated with the class. To access this metadata later, use Reflect.getMetadata(): const metadata = Reflect.getMetadata(&#x27;custom_metadata&#x27;, MyClass); Custom Method You can define decorators for methods similarly: function LogExecutionTime(): MethodDecorator { return (target, propertyKey, descriptor: PropertyDescriptor) =&gt; { const originalMethod = descriptor.value; descriptor.value = function (...args: any[]) { const start = Date.now(); const result = originalMethod.apply(this, args); const end = Date.now(); console.log(`Execution time: ${end - start}ms`); return result; }; }; } This method decorator logs the execution time of the method. Property Decorator For property decorators, you can use the following pattern: function DefaultValue(value: any): PropertyDecorator { return (target, propertyKey: string | symbol) =&gt; { Reflect.defineMetadata( &#x27;default_value&#x27;, value, target, propertyKey ); }; } Later, retrieve the default value: const defaultValue = Reflect.getMetadata( &#x27;default_value&#x27;, target, propertyKey ); Create the Decorator: Use Reflect.defineMetadata() to attach metadata to the class, method, or property. Use the Decorator: Apply the decorator to classes, methods, or properties. Retrieve Metadata: Use Reflect.getMetadata() to retrieve the attached metadata at runtime. Contract Decorator The @Contract decorator is used to define a contract controller with various options, such as authentication, caching, and proto file paths. @Contract({ controllerName: &#x27;UserContract&#x27;, protoPath: &#x27;user.proto&#x27;, generateEntities: true, auth: true, cache: { key: &#x27;userCache&#x27;, ttl: 300 } }) class UserContract {} ``controllerName (string): Defines the name of the controller to be generated. controllerCustomPath (string, optional): Custom path for the controller. protoPath (string): Path to the .proto file for the contract. protoPackage (string, optional): Package name for the protocol buffer. directMessage (boolean, optional): If true, enables direct messaging via WebSocket. generateController (boolean, optional): Automatically generates the controller if set to true. generateEntities (boolean, optional): Controls whether entities are generated. auth (boolean, optional): Enables authentication for the controller. imports (Array&lt;string&gt;, optional): Specifies additional imports required by the controller. cache (CacheOptions, optional): Defines caching behavior for the contract. ContractField Decorator The @ContractField decorator is used to declare fields within a contract and define validation rules, transformations, and database configurations. @ContractField({ protoType: &#x27;string&#x27;, unique: true, validations: [{ type: &#x27;isEmail&#x27;, message: &#x27;Invalid email format&#x27; }] }) email: string; protoType (string): Defines the data type in the protocol buffer (e.g., string, int32). protoRepeated (boolean, optional): Indicates if the field is a repeated (array) type. defaultValue (any, optional): Specifies the default value for the field. index (boolean, optional): Enables database indexing for the field. unique (boolean, optional): Ensures the field has unique values. exclude (boolean, optional): Excludes the field from the generated contract. nullable (boolean, optional): Allows null values. toClassOnly (boolean, optional): Restricts field mapping to the class, excluding database/entity. transform (Function, optional): A custom transformation function for field values. validations (ValidationOption[], optional): Defines validation rules, such as type checks or custom validation logic.",
        "hierarchy": {
            "lvl0": "Decorators",
            "lvl1": "Custom Method",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "overview/request",
        "url": "/overview/request.html",
        "content": "Request The HttpService class in the @cmmv/http package provides a convenient way to make HTTP requests to external APIs using the Axios NPM library. It extends the AbstractService and is registered as a service with the name 'http'. The service wraps common HTTP request methods such as GET, POST, DELETE, PUT, PATCH, and HEAD while using Axios for handling requests and responses. To use the HttpService in your project, make sure to import it from the @cmmv/http package: import { HttpService } from &#x27;@cmmv/http&#x27;; The HttpService provides several HTTP methods for interacting with external APIs. These methods support custom configurations through AxiosRequestConfig and return a Promise that resolves with an AxiosResponse. Methods request&lt;T&gt;(config: AxiosRequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; Description: Performs a generic HTTP request based on the given Axios configuration. Parameters: config: An AxiosRequestConfig object that defines the HTTP method, headers, and other request configurations. Returns: A Promise that resolves with an AxiosResponse. const response = await this.httpService.request({ method: &#x27;GET&#x27;, url: &#x27;https://api.example.com/data&#x27;, }); Get get&lt;T&gt;(url: string, config?: AxiosRequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; Description: Sends an HTTP GET request to the specified URL. Parameters: url: The URL to send the GET request to. config: An AxiosRequestConfig object that defines the HTTP method, headers, and other request configurations. Returns: A Promise that resolves with an AxiosResponse. const response = await this.httpService.get(&#x27;https://api.example.com/data&#x27;); Delete delete&lt;T&gt;(url: string, config?: AxiosRequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; Description: Sends an HTTP DELETE request to the specified URL. Parameters: url: The URL to send the DELETE request to. config: Optional Axios configuration options. Returns: A Promise that resolves with an AxiosResponse. const response = await httpService.delete(&#x27;https://api.example.com/data/1&#x27;); Delete delete&lt;T&gt;(url: string, config?: AxiosRequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; Description: Sends an HTTP DELETE request to the specified URL. Parameters: url: The URL to send the DELETE request to. config: Optional Axios configuration options. Returns: A Promise that resolves with an AxiosResponse. const response = await httpService.delete(&#x27;https://api.example.com/data/1&#x27;); Head head&lt;T&gt;(url: string, config?: AxiosRequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; Description: Sends an HTTP HEAD request to the specified URL to fetch only headers without the response body. Parameters: url: The URL to send the HEAD request to. config: Optional Axios configuration options. Returns: A Promise that resolves with an AxiosResponse. const response = await this.httpService.head(&#x27;https://api.example.com/data&#x27;); Post post&lt;T&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; Description: Sends an HTTP POST request to the specified URL with the given data. Parameters: url: The URL to send the POST request to. data: The data to be sent in the request body. config: Optional Axios configuration options. Returns: A Promise that resolves with an AxiosResponse. const response = await httpService.post(&#x27;https://api.example.com/data&#x27;, { key: &#x27;value&#x27; }); Put put&lt;T&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; Description: Sends an HTTP PUT request to the specified URL with the given data. Parameters: url: The URL to send the PUT request to. data: The data to be sent in the request body. config: Optional Axios configuration options. Returns: A Promise that resolves with an AxiosResponse. const response = await httpService.put(&#x27;https://api.example.com/data/1&#x27;, { key: &#x27;newValue&#x27; }); Patch patch&lt;T&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;AxiosResponse&lt;T&gt;&gt; Description: Sends an HTTP PATCH request to the specified URL with the given data. Parameters: url: The URL to send the PATCH request to. data: The data to be sent in the request body. config: Optional Axios configuration options. Returns: A Promise that resolves with an AxiosResponse. const response = await httpService.patch(&#x27;https://api.example.com/data/1&#x27;, { key: &#x27;patchedValue&#x27; }); Usage import { Service } from &quot;@cmmv/core&quot;; import { HttpService } from &quot;@cmmv/http&quot;; import { Cron } from &quot;@cmmv/scheduling&quot;; @Service() export class CryptoPriceService { private readonly apiUrl = &quot;https://api.coingecko.com/api/v3/coins/markets&quot;; constructor( private readonly httpService: HttpService ){} @Cron(&quot;*/1 * * * *&quot;) async fetchTopCryptos(){ try { const response = await this.httpService.get(this.apiUrl, { params: { vs_currency: &#x27;usd&#x27;, order: &#x27;market_cap_desc&#x27;, page: 1 } }); if (response.status === 200) { const cryptos = response.data; cryptos.forEach((crypto: any) =&gt; { console.log(` Criptomoeda: ${crypto.name}, Preço: $${crypto.current_price} `); }); } else { console.error(`Erro ao obter dados: ${response.statusText}`); } } catch (error) { console.error(&#x27;Erro ao realizar a requisição:&#x27;, error.message); } } } The HttpService is a powerful and flexible tool for making HTTP requests within the @cmmv/http framework. It leverages the popular Axios library to handle HTTP operations, providing an easy way to interact with external APIs from your CMMV-based application. Each method corresponds to a standard HTTP request type, and additional configurations can be applied using AxiosRequestConfig to customize behavior like headers, timeouts, and more.",
        "hierarchy": {
            "lvl0": "Request",
            "lvl1": "Methods",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "overview/telemetry",
        "url": "/overview/telemetry.html",
        "content": "Telemetry The telemetry system within the CMMV framework provides a powerful mechanism for tracking and monitoring internal processes both in the backend and frontend. It is designed to measure the performance of various components such as database queries, service calls, API responses, and rendering times. By utilizing this telemetry system, developers can identify potential bottlenecks or performance issues in the system. The Telemetry class, a singleton, manages telemetry records for processes in both server and client environments. It tracks the start and end times of labeled processes, allowing the calculation of the time spent on each task. These records can be accessed, monitored, and displayed in real-time, particularly in development mode, to help developers analyze where slowdowns or inefficiencies are occurring. Method Description start(label: string, requestId?: string) Starts a telemetry record for a process with a given label and request ID. end(label: string, requestId?: string) Ends the telemetry record by marking the end time for the process with the given label. getTelemetry(requestId: string) Returns all telemetry records for a given request ID. clearTelemetry(requestId: string) Clears telemetry records for a specific request ID. registerPlugin(plugin: any) Allows external plugins to register and extend the telemetry system with additional capabilities. getRecords() Retrieves all telemetry records currently stored. Workflow Start a Telemetry Record: When a request or action starts, the telemetry system logs the start time with the process label. Telemetry.start(&#x27;TaskService::GetAll&#x27;, requestId); End the Telemetry Record: When the process completes, the telemetry system logs the end time. Telemetry.end(&#x27;TaskService::GetAll&#x27;, requestId); Retrieve the Telemetry Data: After the request completes, you can retrieve all telemetry data associated with the request ID. const records = Telemetry.getTelemetry(requestId); Clear the Telemetry Data: Once telemetry data is no longer needed, you can clear it. Telemetry.clearTelemetry(requestId); In services that communicate with external components (e.g., databases, queues), it is recommended to implement telemetry points to track the execution time of these operations. This is particularly helpful when NODE_ENV is set to dev, as it will log the telemetry data and display it in the console. async getAll(req?: any): Promise&lt;TaskEntity[]&gt; { try { Telemetry.start(&#x27;TaskService::GetAll&#x27;, req?.requestId); const result = await Repository.findAll(TaskEntity); Telemetry.end(&#x27;TaskService::GetAll&#x27;, req?.requestId); return result; } catch (e) { Telemetry.end(&#x27;TaskService::GetAll&#x27;, req?.requestId); throw e; } } The telemetry system supports both backend and frontend processes. By implementing telemetry in both environments, you can get a complete view of the system’s performance from request initiation to response and rendering. Example console output of telemetry: Index Process Duration 0 ‘Server: Request Process’ ‘35.00 ms’ 1 ‘Server: Compile Template’ ‘30.00 ms’ 2 ‘Server: Load Includes’ ‘0.00 ms’ 3 ‘Server: TaskService::GetAll’ ‘10.00 ms’ 4 ‘Server: Process Setup’ ‘17.00 ms’ 5 ‘Client: Initialize Frontend’ ‘0.30 ms’ 6 ‘Client: WebSocket Initialization’ ‘0.30 ms’ 7 ‘Client: Load Contracts’ ‘1.30 ms’ 8 ‘Client: Process Expressions’ ‘5.30 ms’ 9 ‘Client: CreateApp’ ‘1.00 ms’ 10 ‘Client: Mount App’ ‘4.20 ms’ This output provides a detailed timeline of both server-side and client-side processes, allowing you to pinpoint slow areas in the system. Best Practices Telemetry in Services: Always implement telemetry for operations that involve external services or long-running tasks such as database queries or message queue operations. Use in Development: When NODE_ENV is set to dev, telemetry data is automatically sent to @cmmv/view and displayed in the console, allowing for immediate performance analysis. Clear Telemetry: Clear telemetry records when they are no longer needed to avoid memory leaks or excessive storage. By using the telemetry system, you can gain full visibility into how long processes take and where slowdowns occur, whether in the backend or frontend of your application. This can help you optimize your system’s performance and ensure smooth communication between components.",
        "hierarchy": {
            "lvl0": "Telemetry",
            "lvl1": "Workflow",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "overview/logging",
        "url": "/overview/logging.html",
        "content": "Logger The Logger class in the @cmmv/core module is designed to provide standardized logging for applications. It allows you to log messages at different severity levels (log, error, warning, debug, verbose) and format the output with timestamps, colored contexts, and message levels to improve readability. Method Description log Logs a general message with LOG level and the optional context. error Logs an error message with ERROR level and the optional context. warning Logs a warning message with WARNING level and the optional context. debug Logs a debugging message with DEBUG level and the optional context. verbose Logs detailed verbose information with VERBOSE level and the optional context. Each of these methods formats the message, adds a timestamp, and colors the output based on the severity level to ensure clarity during logging. Context: A default context (Server) is used unless a specific context is provided during instantiation. The context is shown in yellow brackets to differentiate between different parts of the application if necessary. Timestamps: Each log message is timestamped in the format MM/DD/YYYY, HH:MM:SS AM/PM to track when events occur. Color-Coded Severity Levels: The message severity is highlighted using different colors: ERROR: Red WARNING: Orange DEBUG: Blue VERBOSE: Cyan LOG: Green Context is always highlighted in yellow, and the message body is colored based on the severity level. Message Formatting: Messages are constructed using a method called formatMessage that combines the timestamp, severity level, context, and message body into a cohesive, readable log entry. Customization: The logger can be initialized with a custom context name for more specific categorization of logs. Example const logger = new Logger(&#x27;MyApp&#x27;); logger.log(&#x27;Application has started&#x27;); logger.error(&#x27;Failed to connect to the database&#x27;, &#x27;DatabaseService&#x27;); logger.warning(&#x27;Memory usage is high&#x27;); logger.debug(&#x27;User object: &#x27;, &#x27;UserService&#x27;); logger.verbose(&#x27;Detailed information about request processing&#x27;); Output [Server] - 12/04/2024, 10:14:32 AM LOG [MyApp] Application has started [Server] - 12/04/2024, 10:15:01 AM ERROR [DatabaseService] Failed to connect to the database [Server] - 12/04/2024, 10:15:45 AM WARNING [Server] Memory usage is high [Server] - 12/04/2024, 10:16:12 AM DEBUG [UserService] User object: [Server] - 12/04/2024, 10:16:58 AM VERBOSE [Server] Detailed information about request processing Logger in Classes The Logger class in the @cmmv/core module provides a simple logging utility that can be used in various classes, such as transpilers and services, to log messages, errors, warnings, and debugging information. Below is an example of how to use the Logger class in your code and what each logging method does. In the example of the RepositoryTranspile class, the Logger is used to log important information during the transpile process. Here is how you can integrate the Logger into your class: import { ITranspile, Logger, Scope } from &#x27;@cmmv/core&#x27;; export class RepositoryTranspile implements ITranspile { // Initialize the Logger instance with a custom context private logger: Logger = new Logger(&#x27;RepositoryTranspile&#x27;); // Main run method that uses the logger to log the start of the transpile process run(): void { this.logger.log(&#x27;Starting transpile process for contracts&#x27;); const contracts = Scope.getArray&lt;any&gt;(&#x27;__contracts&#x27;); // Log when no contracts are found if (!contracts || contracts.length === 0) { this.logger.warning(&#x27;No contracts found for transpiling.&#x27;); return; } contracts.forEach((contract: any) =&gt; { if (contract.generateController) { this.logger.log(`Generating entity and service for contract: ${contract.controllerName}`); this.generateEntity(contract); this.generateService(contract); } }); this.logger.log(&#x27;Transpile process completed successfully.&#x27;); } private generateEntity(contract: any): void { try { // Code for generating the entity this.logger.debug(`Generating entity for ${contract.controllerName}`); } catch (error) { this.logger.error(`Failed to generate entity for ${contract.controllerName}`, error); } } private generateService(contract: any): void { try { // Code for generating the service this.logger.debug(`Generating service for ${contract.controllerName}`); } catch (error) { this.logger.error(`Failed to generate service for ${contract.controllerName}`, error); } } } By using these logging methods, you can ensure that your application provides informative, structured, and context-specific logs, which are essential for debugging and monitoring production environments.",
        "hierarchy": {
            "lvl0": "Logger",
            "lvl1": "Example",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "overview/transpiles",
        "url": "/overview/transpiles.html",
        "content": "Transpiles In the CMMV framework, transpilers are essential tools used to generate necessary files based on contracts and module requirements. These classes automatically create code or configuration files that are vital for the proper functioning of modules such as HTTP, Protobuf, and Repository. Whenever a module requires specific artifacts, like controllers, entities, or Protobuf definitions, a transpiler processes the contracts and generates the required files. This approach ensures modularity and adaptability, as each module can define its own set of transpilers to handle file generation as needed. Key Features of Transpilers Automatic Code Generation: Transpilers generate files automatically based on contracts, reducing manual work and ensuring consistency between your application and the database, API interfaces, or other modules. Modular: Each module (e.g., HTTP, Protobuf, Repository) has its own transpiler, ensuring a clean separation of concerns. Customizable: New transpilers can be added for other custom modules, making the system extensible. Contract-Based: Transpilers rely on contracts to define what code needs to be generated. Contracts are the central mechanism for defining the structure, behavior, and data types for entities and services. Native Transpilers Protobuf Transpiler: Generates .proto files based on contracts to enable RPC communication. Repository Transpiler: Creates database entities based on TypeORM, implementing CRUD functionality based on contracts. HTTP Transpiler: Generates controllers and routes for RESTful APIs based on the contract definitions. Websocket Transpiler: Generates Websocket communication gateways for RPC based on contract definitions. Example Below is an implementation of the ProtobufTranspile class, which generates .proto files from contracts to facilitate communication using Protobuf. import * as fs from &#x27;fs&#x27;; import * as path from &#x27;path&#x27;; import * as protobufjs from &#x27;protobufjs&#x27;; import * as UglifyJS from &#x27;uglify-js&#x27;; import { ProtoRegistry } from &#x27;./protobuf-registry.utils&#x27;; import { ITranspile, Logger, Scope } from &quot;@cmmv/core&quot;; export class ProtobufTranspile implements ITranspile { private logger: Logger = new Logger(&#x27;ProtobufTranspile&#x27;); run(): void { const contracts = Scope.getArray&lt;any&gt;(&quot;__contracts&quot;); const contractsJson: { [key: string]: any } = {}; contracts?.forEach((contract: any) =&gt; { const outputPath = path.resolve(contract.protoPath); const outputPathJson = outputPath.replace(&#x27;.proto&#x27;, &#x27;.json&#x27;); const outputPathTs = outputPath.replace(&#x27;.proto&#x27;, &#x27;.d.ts&#x27;); const outputDir = path.dirname(outputPath); if (!fs.existsSync(outputDir)) { fs.mkdirSync(outputDir, { recursive: true }); this.logger.log(`Created directory ${outputDir}`); } const root = new protobufjs.Root(); const protoNamespace = root.define(contract.controllerName); const itemMessage = new protobufjs.Type(contract.controllerName) .add(new protobufjs.Field(&quot;id&quot;, 1, &quot;int32&quot;)); contract.fields.forEach((field: any, index: number) =&gt; { const protoType = this.mapToProtoType(field.protoType); itemMessage.add(new protobufjs.Field(field.propertyKey, index + 2, protoType)); }); protoNamespace.add(itemMessage); if (!contract.directMessage) { const listMessage = new protobufjs.Type(`${contract.controllerName}List`) .add(new protobufjs.Field(&quot;items&quot;, 1, `${contract.controllerName}`, &quot;repeated&quot;)); protoNamespace.add(listMessage); } const protoContent = this.generateProtoContent(contract); fs.writeFileSync(outputPath, protoContent, &#x27;utf8&#x27;); const tsContent = this.generateTypes(contract); fs.writeFileSync(outputPathTs, tsContent, &#x27;utf8&#x27;); const contractJSON = root.toJSON(); contractsJson[contract.controllerName] = contractJSON; fs.writeFileSync(outputPathJson, JSON.stringify(contractJSON), &#x27;utf8&#x27;); }); this.generateContractsJs(contractsJson); } private generateProtoContent(contract: any): string { const packageName = contract.protoPackage || null; const lines: string[] = []; let includesGoogleAny = false; contract.fields.forEach((field: any) =&gt; { if (field.protoType === &#x27;any&#x27;) includesGoogleAny = true; }); lines.push(&#x27;// Generated automatically by CMMV&#x27;); lines.push(`syntax = &quot;proto3&quot;;`); if (packageName) lines.push(`package ${packageName};`); if (includesGoogleAny) lines.push(&#x27;import &quot;google/protobuf/any.proto&quot;;&#x27;); lines.push(&#x27;&#x27;); lines.push(`message ${contract.controllerName} {`); contract.fields.forEach((field: any, index: number) =&gt; { const protoType = this.mapToProtoType(field.protoType); const repeatedPrefix = field.protoRepeated ? &#x27;repeated &#x27; : &#x27;&#x27;; lines.push(` ${repeatedPrefix}${protoType} ${field.propertyKey} = ${index + 1};`); }); lines.push(`}`); if (!contract.directMessage) { lines.push(&#x27;&#x27;); lines.push(`message ${contract.controllerName}List {`); lines.push(` repeated ${contract.controllerName} items = 1;`); lines.push(`}`); } lines.push(&#x27;&#x27;); lines.push(`message Add${contract.controllerName}Request {`); lines.push(` ${contract.controllerName} item = 1;`); lines.push(`}`); lines.push(`message Add${contract.controllerName}Response {`); lines.push(` string id = 1;`); lines.push(` ${contract.controllerName} item = 2;`); lines.push(`}`); lines.push(&#x27;&#x27;); lines.push(`message Update${contract.controllerName}Request {`); lines.push(` string id = 1;`); lines.push(` ${contract.controllerName} item = 2;`); lines.push(`}`); lines.push(`message Update${contract.controllerName}Response {`); lines.push(` string id = 1;`); lines.push(` ${contract.controllerName} item = 2;`); lines.push(`}`); lines.push(&#x27;&#x27;); lines.push(`message Delete${contract.controllerName}Request {`); lines.push(` string id = 1;`); lines.push(`}`); lines.push(`message Delete${contract.controllerName}Response {`); lines.push(` bool success = 1;`); lines.push(` string id = 2;`); lines.push(`}`); lines.push(&#x27;&#x27;); lines.push(`message GetAll${contract.controllerName}Request {}`); lines.push(`message GetAll${contract.controllerName}Response {`); lines.push(` ${contract.controllerName}List items = 1;`); lines.push(`}`); lines.push(&#x27;&#x27;); lines.push(`service ${contract.controllerName}Service {`); lines.push(` rpc Add${contract.controllerName} (Add${contract.controllerName}Request) returns (Add${contract.controllerName}Response);`); lines.push(` rpc Update${contract.controllerName} (Update${contract.controllerName}Request) returns (Update${contract.controllerName}Response);`); lines.push(` rpc Delete${contract.controllerName} (Delete${contract.controllerName}Request) returns (Delete${contract.controllerName}Response);`); lines.push(` rpc GetAll${contract.controllerName} (GetAll${contract.controllerName}Request) returns (GetAll${contract.controllerName}Response);`); lines.push(`}`); return lines.join(&#x27;\\n&#x27;); } private generateTypes(contract: any): string { const lines: string[] = []; lines.push(`// Types generated automatically by CMMV`); lines.push(`export namespace ${contract.controllerName} {`); contract.fields.forEach((field: any) =&gt; { const tsType = this.mapToTsType(field.protoType); lines.push(` export type ${field.propertyKey} = ${tsType};`); }); lines.push(`}`); lines.push(`export interface Add${contract.controllerName}Request {`); lines.push(` item: ${contract.controllerName};`); lines.push(`}`); lines.push(`export interface Add${contract.controllerName}Response {`); lines.push(` item: ${contract.controllerName};`); lines.push(`}`); lines.push(`export interface Update${contract.controllerName}Request {`); lines.push(` id: string;`); lines.push(` item: ${contract.controllerName};`); lines.push(`}`); lines.push(`export interface Update${contract.controllerName}Response {`); lines.push(` item: ${contract.controllerName};`); lines.push(`}`); lines.push(`export interface Delete${contract.controllerName}Request {`); lines.push(` id: string;`); lines.push(`}`); lines.push(`export interface Delete${contract.controllerName}Response {`); lines.push(` success: boolean;`); lines.push(`}`); lines.push(`export interface GetAll${contract.controllerName}Request {}`); lines.push(`export interface GetAll${contract.controllerName}Response {`); lines.push(` items: ${contract.controllerName}[];`); lines.push(`}`); return lines.join(&#x27;\\n&#x27;); } private async generateContractsJs(contractsJson: { [key: string]: any }): Promise&lt;void&gt; { const outputFile = path.resolve(&#x27;public/core/contracts.min.js&#x27;); await ProtoRegistry.load(); const contracts = ProtoRegistry.retrieveAll(); let contractsJSON = {}; let index = {}; let pointer = 0; for(let key in contracts){ const contract = ProtoRegistry.retrieve(key); contractsJSON[key] = contract.toJSON(); let types = {}; let pointerTypes = 0; for(let namespace of contract.nestedArray){ for(let type in namespace.toJSON().nested){ types[type] = pointerTypes; pointerTypes++; } } index[key] = { index: pointer, types }; pointer++; } const data = { index, contracts: contractsJSON }; let jsContent = &#x27;// Generated automatically by CMMV\\n&#x27;; jsContent += &#x27;(function(global) {\\n&#x27;; jsContent += &#x27; try {\\n&#x27;; jsContent += &#x27; global.cmmv.addContracts(&#x27; + JSON.stringify(data) + &#x27;);\\n&#x27;; jsContent += &#x27; } catch (e) {\\n&#x27;; jsContent += &#x27; console.error(&quot;Error loading contracts:&quot;, e);\\n&#x27;; jsContent += &#x27; }\\n&#x27;; jsContent += &#x27;})(typeof window !== &quot;undefined&quot; ? window : global);\\n&#x27;; const minifiedJsContent = UglifyJS.minify(jsContent).code; fs.writeFileSync(outputFile, minifiedJsContent, &#x27;utf8&#x27;); } private mapToProtoType(type: string): string { const typeMapping: { [key: string]: string } = { string: &#x27;string&#x27;, boolean: &#x27;bool&#x27;, bool: &#x27;bool&#x27;, int: &#x27;int32&#x27;, int32: &#x27;int32&#x27;, int64: &#x27;int64&#x27;, float: &#x27;float&#x27;, double: &#x27;double&#x27;, bytes: &#x27;bytes&#x27;, date: &#x27;string&#x27;, timestamp: &#x27;string&#x27;, text: &#x27;string&#x27;, json: &#x27;string&#x27;, jsonb: &#x27;string&#x27;, uuid: &#x27;string&#x27;, time: &#x27;string&#x27;, simpleArray: &#x27;string&#x27;, simpleJson: &#x27;string&#x27;, bigint: &#x27;int64&#x27;, uint32: &#x27;uint32&#x27;, uint64: &#x27;uint64&#x27;, sint32: &#x27;sint32&#x27;, sint64: &#x27;sint64&#x27;, fixed32: &#x27;fixed32&#x27;, fixed64: &#x27;fixed64&#x27;, sfixed32: &#x27;sfixed32&#x27;, sfixed64: &#x27;sfixed64&#x27;, any: &#x27;google.protobuf.Any&#x27; }; return typeMapping[type] || &#x27;string&#x27;; } private mapToTsType(protoType: string): string { const typeMapping: { [key: string]: string } = { string: &#x27;string&#x27;, boolean: &#x27;boolean&#x27;, bool: &#x27;boolean&#x27;, int: &#x27;number&#x27;, int32: &#x27;number&#x27;, int64: &#x27;number&#x27;, float: &#x27;number&#x27;, double: &#x27;number&#x27;, bytes: &#x27;Uint8Array&#x27;, date: &#x27;string&#x27;, timestamp: &#x27;string&#x27;, text: &#x27;string&#x27;, json: &#x27;any&#x27;, jsonb: &#x27;any&#x27;, uuid: &#x27;string&#x27;, time: &#x27;string&#x27;, simpleArray: &#x27;string[]&#x27;, simpleJson: &#x27;any&#x27;, bigint: &#x27;bigint&#x27;, uint32: &#x27;number&#x27;, uint64: &#x27;number&#x27;, sint32: &#x27;number&#x27;, sint64: &#x27;number&#x27;, fixed32: &#x27;number&#x27;, fixed64: &#x27;number&#x27;, sfixed32: &#x27;number&#x27;, sfixed64: &#x27;number&#x27;, any: &#x27;any&#x27; }; return typeMapping[protoType] || &#x27;any&#x27;; } } In the example above, the Protobuf transpiler takes contract definitions and generates .proto files to be used for RPC communication with the protobufjs library. These .proto files define message structures for binary data exchanges. Additionally, TypeScript types are generated based on these contracts to ensure type safety. Finally, the contracts are converted into JSON format and attached to the frontend framework, which will handle the sending and receiving of binary data in the Protobuf format, enabling efficient data communication between frontend and backend. Call a Transpiler In CMMV, transpilers are modular, which allows them to be dynamically added to modules and invoked during the application processing. A transpiler’s role is to automatically generate necessary files (such as entities, services, and Protobuf definitions) based on the contracts defined in your application. /packages/protobuf/src/protobuf.module.ts import { Module } from &quot;@cmmv/core&quot;; import { ProtobufTranspile } from &quot;./protobuf.transpiler&quot;; export let ProtobufModule = new Module({ transpilers: [ProtobufTranspile] // Register the transpiler here }); In this case, ProtobufModule registers the ProtobufTranspile transpiler. The transpilers property in the Module configuration allows you to list all the transpilers that should be executed when the module is processed. When the application is started, the transpiler will be invoked automatically as part of the module processing. Each module’s transpilers will run based on the contracts defined in the system, and they will generate the required files accordingly. import { Application } from &quot;@cmmv/core&quot;; import { ProtobufModule } from &quot;@cmmv/protobuf&quot;; new Application({ ... modules: [ProtobufModule], }); When the application starts, it will look for all modules, identify the transpilers within those modules, and run them in sequence. In this case, the ProtobufTranspile will process any contracts registered in the system and generate the corresponding Protobuf files. This modular design makes it easy to extend the system by adding new transpilers for various tasks, such as generating database entities, Protobuf definitions, or other required files based on the contracts defined in your application.",
        "hierarchy": {
            "lvl0": "Transpiles",
            "lvl1": "Key Features of Transpilers",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "overview/singleton",
        "url": "/overview/singleton.html",
        "content": "Singleton In CMMV, the traditional dependency injection pattern is replaced by singleton registries, which streamline the management of global services. In many applications, modules often share services such as cache, queues, or database connections. Instead of declaring and injecting these services across multiple modules, a singleton ensures that only one instance of a service is created and shared across the entire application. This approach offers several advantages: Simplifies service management by eliminating the need for explicit injection across modules. Reduces complexity by avoiding circular dependencies. Optimizes performance by ensuring only one instance of each service exists, minimizing overhead. Example import { Singleton } from &quot;@cmmv/core&quot;; export class Scope extends Singleton { private data: Map&lt;string, any&gt; = new Map(); public static set(name: string, data: any): boolean { const scope = Scope.getInstance(); if (!scope.data.has(name)) { scope.data.set(name, data); return true; } return false; } public static has(name: string): boolean { const scope = Scope.getInstance(); return scope.data.has(name); } public static get&lt;T = any&gt;(name: string): T | null { const scope = Scope.getInstance(); return scope.data.has(name) ? (scope.data.get(name) as T) : null; } public static clear(name: string): void { const scope = Scope.getInstance(); scope.data.delete(name); } public static addToArray&lt;T = any&gt;(name: string, value: T): boolean { const scope = Scope.getInstance(); const array = scope.data.get(name) || []; if (Array.isArray(array)) { array.push(value); scope.data.set(name, array); return true; } return false; } public static removeFromArray&lt;T = any&gt;(name: string, value: T): boolean { const scope = Scope.getInstance(); const array = scope.data.get(name); if (Array.isArray(array)) { const index = array.indexOf(value); if (index &gt; -1) { array.splice(index, 1); scope.data.set(name, array); return true; } } return false; } public static getArray&lt;T = any&gt;(name: string): T[] | null { const scope = Scope.getInstance(); const array = scope.data.get(name); if (Array.isArray(array)) return array as T[]; return null; } public static getArrayFromIndex&lt;T = any&gt;(name: string, index: number): T | null { const scope = Scope.getInstance(); const array = scope.data.get(name); if (Array.isArray(array) &amp;&amp; array.length &gt;= index) return array[index] as T; return null; } } Advantages Using singletons provides several advantages over traditional dependency injection systems, especially for larger applications with complex services and multiple modules: Performance Optimization: Since singletons are instantiated only once, they reduce the overhead associated with creating multiple instances of services. This is particularly beneficial when dealing with high-frequency services like database connections or cache managers. Simplified Architecture: Instead of managing complex dependency trees and imports in each module, singleton registries allow direct access to services, simplifying module design and reducing the need for boilerplate code. Avoid Circular Dependencies: Circular dependencies occur when two services depend on each other, causing dependency injection systems to fail or become overly complex. Singletons avoid this issue by being self-contained and globally accessible. Ease of Access: Services like configuration, caching, and logging can be made globally accessible without requiring them to be explicitly injected into every module or service that needs them. Scalability: As the application grows, using singletons simplifies service management. Unlike traditional dependency injection systems that require the careful management of imports and global providers, singletons offer a straightforward solution to sharing services across different modules. Best Practices Use Singletons for Global Services: Use singleton registries for services that need to be shared across multiple modules, such as configuration, logging, caching, and database connections. Minimize Overuse: While singletons simplify service management, overusing them can make testing and debugging more difficult. Use them judiciously for truly global services. Avoid State Mutability: If possible, keep singleton services stateless or ensure their state is managed carefully to avoid unintended side effects. Testing: When testing singleton services, remember that they maintain their state throughout the application lifecycle. Reset or mock singleton instances as needed during tests.",
        "hierarchy": {
            "lvl0": "Singleton",
            "lvl1": "Example",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "overview/modules",
        "url": "/overview/modules.html",
        "content": "Modules The CMMV module system shares similarities with NestJS, providing a modular approach to application development. However, it differs in one key aspect: no dependency context control. This means that services are not injected or managed by a centralized dependency injection container. Instead, any provider (service, utility, etc.) can be created independently and added to modules where needed. For shared services across the system, such as the Repository or Config classes, it’s recommended to use singleton registries, making these services globally accessible without the need for repeated instantiation. Key Features No Dependency Context Control: Services are not automatically injected. Instead, they can be created and indexed within the module system. Singleton Registries: Shared services can be registered as singletons to avoid duplication and make them accessible across the entire system. Module Composition: Modules in CMMV are flexible, allowing you to define controllers, services (providers), transpilers, contracts, and submodules within a single module. Automatic Module Generation: The system generates the main module (e.g., app.module.ts) based on contracts, controllers, and gateways defined within the application. Example Here’s an example of a full-featured module with all possible properties in CMMV: import { Module } from &#x27;@cmmv/core&#x27;; import { DocsController } from &#x27;./docs.controller&#x27;; import { DocsService } from &#x27;./docs.service&#x27;; import { DocsTranspile } from &#x27;./docs.transpile&#x27;; import { DocsContract } from &#x27;./docs.contract&#x27;; import { SubModule } from &#x27;./submodule&#x27;; export let DocsModule = new Module({ controllers: [DocsController], providers: [DocsService], transpilers: [DocsTranspile], submodules: [SubModule], contracts: [DocsContract] }); controllers: An array of controllers that handle HTTP requests and return responses. They manage the application’s routes and are responsible for interacting with services. providers: A list of services or classes that contain the business logic for your module. These providers are manually instantiated and indexed when needed. transpilers: These are responsible for generating necessary files, such as database entities, Protobuf definitions, or other code artifacts based on contracts. submodules: Allows you to break your application into smaller, self-contained modules that can be nested within other modules. contracts: Defines the contracts associated with this module. Contracts define the data structure and behavior of entities, and transpilers generate the appropriate files (e.g., database models, API endpoints). Singleton Registries Instead of injecting shared services across multiple modules, singleton registries can be used for services like Repository or Config, which are intended to be accessible globally. This reduces the need for dependency injection and ensures that these services are instantiated only once and shared throughout the system. Application Whenever contracts are defined, the system will automatically create a module at /src/app.module.ts. This module will include all contracts, controllers, and gateways automatically generated by the application. Here is an example of how the file might be generated: // Generated automatically by CMMV import { Module } from &#x27;@cmmv/core&#x27;; import { TaskController } from &#x27;./controllers/task.controller&#x27;; import { TaskService } from &#x27;./services/task.service&#x27;; import { TaskGateway } from &#x27;./gateways/task.gateway&#x27;; export let ApplicationModule = new Module({ controllers: [TaskController], providers: [TaskService, TaskGateway] }); It is important to note that the file /src/app.module.ts is automatically generated by the system and should not be manually modified, as it will be recreated every time the application is started. Any changes made directly to this file will be overwritten. If you need to add or modify modules, services, or controllers, it is recommended to do so in separate files and register them properly within the application to ensure your modifications are preserved. Modular Design CMMV follows a modular design, allowing you to break down your application into reusable and maintainable parts. Each module can focus on a specific domain or feature, which improves separation of concerns, maintainability, and scalability. Feature-Oriented Structure: Group controllers, services, and other components related to the same feature together in a module. Reusability: Modules can be reused across different parts of the application, and submodules can help break down complex functionality into simpler units. Transpilers for Automation: Transpilers automate repetitive tasks, like generating files based on contracts, minimizing manual coding and ensuring consistency. Best Practices Use Singleton Registries: For shared services (e.g., configuration, repository), use singleton registries to avoid repeated instantiation and simplify access. Define Modules for Each Feature: Organize your application by defining a separate module for each feature or domain, making it easier to manage and scale. Automatic Contracts and Services: Let the CMMV framework handle the generation of services, controllers, and gateways based on contracts to reduce manual boilerplate code. Avoid Modifying Auto-Generated Files: Files like app.module.ts are auto-generated and should not be manually edited. Always make your modifications in separate modules or services. The CMMV module system provides a flexible and powerful way to structure your application, allowing for efficient handling of controllers, services, and transpilers. By leveraging features like singleton registries and automatic file generation through contracts, CMMV helps streamline the development process, reduce manual configuration, and ensure that the application remains scalable and maintainable.",
        "hierarchy": {
            "lvl0": "Modules",
            "lvl1": "Key Features",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "overview/settings",
        "url": "/overview/settings.html",
        "content": "Settings The system configuration for a CMMV project is managed through a .cmmv.config.js file in the root directory. This file defines various settings, such as: Server Settings: Configures the host and port for the application. I18n: Manages internationalization with locale files and default languages. Repository: Defines the database type (e.g., SQLite) and connection details. Head Configuration: Sets HTML attributes, meta tags, and links for the application’s frontend. Headers: Security policies like Content-Security-Policy. Scripts: Specifies JavaScript files to load. Modules can extend this configuration based on the application’s requirements. module.exports = { server: { host: &quot;0.0.0.0&quot;, port: process.env.PORT || 3000 }, i18n: { localeFiles: &quot;./src/locale&quot;, default: &quot;en&quot; }, head: { title: &quot;Documentation | CMMV - A minimalistic Node.js framework&quot;, htmlAttrs: { lang: &quot;pt-br&quot; }, meta: [ { charset: &#x27;utf-8&#x27; }, { &quot;http-equiv&quot;: &quot;content-type&quot;, content: &quot;text/html; charset=UTF-8&quot; }, { name: &#x27;viewport&#x27;, content: &#x27;width=device-width, initial-scale=1&#x27; }, { name: &quot;robots&quot;, content: &quot;noodp&quot; } ], link: [ { rel: &#x27;icon&#x27;, href: &#x27;/assets/favicon/favicon.ico&#x27; }, { rel: &quot;dns-prefetch&quot;, href: &quot;https://docs.cmmv.io&quot; }, { rel: &quot;preconnect&quot;, href: &quot;https://docs.cmmv.io&quot; }, { rel: &quot;stylesheet&quot;, href: &quot;/assets/docs.css&quot; } ] }, headers: { &quot;Content-Security-Policy&quot;: [ &quot;default-src &#x27;self&#x27;&quot;, &quot;script-src &#x27;self&#x27; &#x27;unsafe-eval&#x27; &#x27;unsafe-inline&#x27;&quot;, &quot;style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;&quot;, &quot;font-src &#x27;self&#x27;&quot; ] }, scripts: [ { type: &quot;text/javascript&quot;, src: &#x27;/assets/bundle.min.js&#x27;}, ] }; The default HTTP renderer in CMMV natively supports internationalization, SEO configuration, and security-focused custom headers. These features allow developers to manage localized content, improve search engine optimization, and apply security policies like Content-Security-Policy directly in the configuration. Additional settings for templates and views can also be added later, providing flexibility for customizing pages. More detailed instructions can be found in the “View” documentation, which explains how to implement these configurations within the template system. Assign The Config.assign() method allows you to dynamically modify or override the system configuration at runtime. This method takes an object that merges or updates the existing configuration. Below is an example of how the configuration can be applied using Config.assign(): import { Config } from &#x27;@cmmv/core&#x27;; Config.assign({ server: { host: process.env.HOST || &#x27;127.0.0.1&#x27;, port: process.env.PORT || 4000, }, i18n: { localeFiles: &#x27;./locales&#x27;, default: &#x27;en&#x27;, }, // Additional settings... }); With Config.assign(), you can flexibly modify settings such as server configuration, internationalization, and more, without hardcoding them directly in .cmmv.config.js. API The system configurations in a CMMV-based application can be accessed programmatically through the Config class from the @cmmv/core module. This allows developers to dynamically retrieve, modify, or delete configuration values throughout the application. For example, the server’s host and port settings, database configurations, or internationalization options can be accessed and altered by calling methods like Config.get(), Config.set(), and Config.has(). These features enable a flexible and centralized approach to managing system settings. import { Config } from &quot;@cmmv/core&quot;; //Get const serverPort = Config.get&lt;number&gt;(&#x27;server.port&#x27;); console.log(`Server running on port: ${serverPort}`); //Set Config.set(&#x27;server.host&#x27;, &#x27;127.0.0.1&#x27;); //Delete Config.delete(&#x27;repository.logging&#x27;); //Get All const allConfig = Config.getAll(); console.log(allConfig); //Assign Config.assign({ server: { port: 4000 }, repository: { type: &#x27;sqlite&#x27; } }); Each module in the CMMV system has its own set of configurations that can be added to the central configuration file (.cmmv.config.js). This allows developers to customize the behavior and features of the modules they are using. Because different modules may require specific settings, it’s essential to review each module’s documentation carefully to understand the available configuration options and how they integrate with the core system. This ensures optimal setup and use of advanced functionalities such as RPC, authentication, caching, and more. Environment The env setting allows you to control the environment of the application (e.g., development, production). This setting typically comes from environment variables using dotenv NPM to manage sensitive values securely. env: process.env.NODE_ENV, // Example: &#x27;development&#x27; or &#x27;production&#x27; Server Configuration The server settings control various aspects of how the application is hosted and its behavior in terms of security, performance, and session management. The configuration supports environment variables for flexibility in different deployment environments. server: { host: process.env.HOST || &#x27;0.0.0.0&#x27;, // Default host port: process.env.PORT || 3000, // Default port poweredBy: false, // Remove &#x27;X-Powered-By&#x27; header removePolicyHeaders: false, // Option to remove headers added by Helmet cors: true, // Enable Cross-Origin Resource Sharing (CORS) // Compression settings compress: { enabled: true, options: { level: 6, // Compression level (0-9) }, }, // Security headers with Helmet.js helmet: { enabled: true, options: { contentSecurityPolicy: false, // CSP can be customized }, }, // Session management session: { enabled: true, // Enable sessions options: { sessionCookieName: process.env.SESSION_COOKIENAME || &#x27;cmmv-session&#x27;, secret: process.env.SESSION_SECRET || &#x27;secret&#x27;, // Session secret resave: false, // Prevent resaving session data saveUninitialized: false, // Do not save uninitialized sessions cookie: { secure: true, // Ensure secure cookie (only over HTTPS) maxAge: 60000, // Cookie expiration time in ms }, }, }, }, This section includes detailed control over CORS, session management, compression, and security features such as Helmet. You can also set up different environments using dotenv. Internationalization The i18n (Internationalization) system provides a way to manage locale files and define the default language for the application. This helps with the translation and localization of content. i18n: { localeFiles: &#x27;./src/locale&#x27;, // Path to locale files default: &#x27;en&#x27;, // Default language (English) }, RPC The rpc configuration allows Remote Procedure Calls (RPC) to be used in the application. RPC improves the performance and modularity of the system by enabling communication via predefined contracts. rpc: { enabled: true, // Enable RPC system preLoadContracts: true, // Pre-load RPC contracts for efficiency }, View View settings control how HTML is rendered, including options for minifying HTML and handling inline scripts. These settings can be adjusted to optimize the delivery of frontend content. view: { extractInlineScript: false, // Disable extraction of inline scripts for better control minifyHTML: true, // Enable HTML minification for performance }, Repository The repository settings define the database type, path, and options for synchronization and logging. By default, SQLite is used, but other databases can be configured as needed. repository: { type: &#x27;sqlite&#x27;, // Default database type database: &#x27;./database.sqlite&#x27;, // Path to the SQLite database file synchronize: true, // Synchronize database schema logging: false, // Disable logging for performance }, Cache The cache configuration uses Redis by default for caching data, improving the speed and performance of the application. cache: { store: &#x27;@tirke/node-cache-manager-ioredis&#x27;, // Redis cache store getter: &#x27;ioRedisStore&#x27;, // Cache store getter host: &#x27;localhost&#x27;, // Redis host port: 6379, // Redis port ttl: 600, // Time to live for cache (in seconds) }, Authentication This section handles user authentication, including local login/registration and third-party OAuth integration (e.g., Google). The configuration allows for flexible setup of authentication mechanisms. auth: { localRegister: true, // Enable local user registration localLogin: true, // Enable local user login jwtSecret: process.env.JWT_SECRET || &#x27;secret&#x27;, // JWT secret for token signing expiresIn: 60 * 60, // JWT token expiration time (in seconds) // Google OAuth configuration google: { clientID: process.env.GOOGLE_CLIENT_ID, // Google client ID clientSecret: process.env.GOOGLE_CLIENT_SECRET, // Google client secret callbackURL: &#x27;http://localhost:3000/auth/google/callback&#x27;, // OAuth callback URL }, }, Head The head configuration manages HTML attributes, meta tags, and link elements, which are essential for SEO and proper rendering of the application. head: { title: &#x27;CMMV&#x27;, // Default title htmlAttrs: { lang: &#x27;pt-br&#x27;, // Default language }, meta: [ { charset: &#x27;utf-8&#x27; }, { &#x27;http-equiv&#x27;: &#x27;content-type&#x27;, content: &#x27;text/html; charset=UTF-8&#x27;, }, { name: &#x27;viewport&#x27;, content: &#x27;width=device-width, initial-scale=1&#x27;, }, ], link: [{ rel: &#x27;icon&#x27;, href: &#x27;assets/favicon/favicon.ico&#x27; }], }, Headers headers: { &#x27;Content-Security-Policy&#x27;: [ &quot;default-src &#x27;self&#x27;&quot;, &quot;script-src &#x27;self&#x27; &#x27;unsafe-eval&#x27; &#x27;unsafe-hashes&#x27;&quot;, &quot;style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;&quot;, &quot;font-src &#x27;self&#x27;&quot;, &quot;connect-src &#x27;self&#x27;&quot;, ], }, Scripts The scripts configuration defines JavaScript files to load in the application, which can be customized based on the project’s needs. scripts: [ { type: &#x27;text/javascript&#x27;, src: &#x27;/assets/bundle.min.js&#x27;, // Main JavaScript bundle defer: &#x27;defer&#x27;, // Load script after HTML is parsed }, ], This completes the detailed documentation of the settings. The assign method in Config allows you to dynamically update or override these settings, providing flexibility across different environments and modules.",
        "hierarchy": {
            "lvl0": "Settings",
            "lvl1": "Assign",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "overview/first-steps",
        "url": "/overview/first-steps.html",
        "content": "First steps CMMV (Contract Model Model View) is a revolution in web application development, breaking paradigms and redefining how we create, maintain and scale digital projects. Inspired by best practices and innovative concepts, CMMV integrates the power of contracts to automatically generate robust and secure structures, eliminating the complexity of manual code and providing an unprecedented development experience. Imagine a platform where the definition of contracts in TypeScript becomes the heart of your application, automatically generating APIs, controllers, ORM entities and even communication via binary RPC, all with optimized performance and seamless integration with the most modern technologies. With CMMV, you not only accelerate development, but also ensure the quality and consistency of your code, drastically reducing errors and rework. In addition, CMMV offers a reactive and lightweight interface, based on Vue 3, but with the ability to support other frameworks such as React and Angular, always focusing on performance and SEO. With CMMV, the frontend is not just a presentation layer, but an integral and dynamic part of your application, synchronized in real time with the backend. Whether you are an experienced developer or a programming newbie, CMMV empowers everyone to build powerful, scalable, modern systems by eliminating technical barriers and allowing creativity and innovation to be at the center of your development journey. It is more than a framework; it is a new way of thinking and building the future of web applications. Prerequisites To run CMMV it will be necessary to have Node.js (version &gt;= 18.0) installed in your operating system. Setup Currently CMMV does not have any CI system, so to install it in your project you just need to install the modules. $ npm install @cmmv/core @cmmv/http @cmmv/view rxjs reflect-metadata or $ yarn add @cmmv/core @cmmv/http @cmmv/view rxjs reflect-metadata Structure CMMV is a project that draws inspiration from some of the best practices and technologies in modern development, bringing solid references to create a powerful and flexible framework. At the heart of CMMV are contracts, which follow a model similar to TypeORM and Protobuf, but go further, offering a full range of configurations that allow the automatic generation of the entire base structure of the application. These contracts are the fundamental piece of the project, as from them it is possible to create everything from database entities to APIs and controllers. Written in TypeScript, CMMV adopts a backend structure that resembles NestJS, but with adjustments that make dependency injection and module control more intuitive and adapted to modern development needs. The idea is to offer a modular system, where developers have full control over the application layers, allowing the architecture to adapt to the specific demands of each project. On the frontend, CMMV incorporates a basic data binding controller inspired by Vue 3, but simplified and extremely lightweight. This reactive layer can be easily replaced by any other framework, such as React, Angular or even Vue itself, ensuring that the application maintains flexibility and performance, without sacrificing simplicity. The project is strongly influenced by SOLID principles, applying well-defined concepts of responsibility, but without rigidly following all the rules. The goal is to keep the architecture clean and organized, but with the flexibility necessary to meet the practical realities of development. In addition, TDD (Test-Driven Development) concepts are applied to facilitate maintenance and ensure code quality, but the system is completely modular and optional, allowing each developer to choose what best suits their workflow. In short, CMMV is more than a collection of tools and frameworks; it is an integrated approach to development, where contracts are at the core of everything. With a solid foundation, CMMV gives developers the freedom to build modern and scalable applications, without compromising the simplicity and flexibility that are essential for continuous innovation. Every application flow starts in the src/index.ts file which is responsible for starting the HTTP server and its adapters. import { Application } from &quot;@cmmv/core&quot;; import { DefaultAdapter, DefaultHTTPModule } from &quot;@cmmv/http&quot;; import { ProtobufModule } from &quot;@cmmv/protobuf&quot;; import { WSModule, WSAdapter } from &quot;@cmmv/ws&quot;; import { ViewModule } from &quot;@cmmv/view&quot;; import { RepositoryModule, Repository } from &quot;@cmmv/repository&quot;; import { ApplicationModule } from &quot;./app.module&quot;; Application.create({ httpAdapter: DefaultAdapter, wsAdapter: WSAdapter, modules: [ DefaultHTTPModule, ProtobufModule, WSModule, ViewModule, RepositoryModule ], services: [Repository], contracts: [...] }); It is possible to perform configurations through the .cmmv.config.js file without having to change the application source code, even in the future we will provide other HTTP server modules. The default directories that come with the project are the following: . └── public/ ├── assets/ ├── templates/ └── views/ └── src/ ├── contracts/ ├── controllers/ ├── entities/ ├── models/ ├── services/ ├── app.module.ts └── index.ts Structure Explanation public/: This directory contains all the static resources of the application, such as CSS, JavaScript and images. Within public, we have: assets/: Stores static files such as styles, scripts, images and other resources needed for the user interface. templates/: Contains HTML template files that can be used as base layouts for views. views/: Contains the pages or UI components that will be rendered on the frontend. src/: The src directory is the core of the application, where the source code is organized in a modular way to facilitate development and maintenance. In it, we find: contracts/: This is the most important directory, as it is where the application contracts are defined. When starting the application, the system checks the contracts present in this directory and, from them, automatically generates the controllers, entities, models and services. These contracts serve as the basis of the entire application structure. controllers/: After verifying the contracts, controllers are automatically generated in this directory. They are responsible for handling HTTP requests, processing data, and returning appropriate responses. entities/: If the repository module is present, this directory will house the entities generated in TypeORM format, which represent the database tables and serve as object-relational mapping (ORM). models/: Also generated from contracts, models are used to define the structure of the data that will be manipulated by the application, including data validation and transformation. services/: Services encapsulate the business logic and are responsible for manipulating entities and interacting with other application modules. They are automatically generated based on the contracts and installed modules. app.module.ts: This file is the root module of the application, configuring the main services and modules necessary for the application to function. index.ts: The application entry point, where the server is initialized and configured to start receiving requests. Automatic Generate CMMV’s greatest strength lies in its ability to automatically generate code based on contracts. When starting the application, the system checks the contracts directory and, depending on the installed modules, automatically generates the following parts: Controllers, Entities, Models and Services: Based on the defined contracts, the controllers, entities, models and services required for the application are created. If the repository module is present, the entities and models will be generated in TypeORM format and the connection to the database will be configured according to the information in the .cmmv.config.js file. RPC support with Protobuf: If the protobuf module is present, .proto contracts will be automatically generated for RPC (Remote Procedure Call) communication. This communication is done through a WebSocket adapter, integrating the HTTP and WebSocket server on the same port, facilitating real-time communication. HTTP Server Modularity: Currently, the HTTP module supports Express and Fastify, allowing developers to choose the framework that best suits their needs. In the future, new modules may be added to provide additional support for other frameworks. This modular approach ensures that CMMV easily adapts to the needs of the project, maintaining flexibility and scalability without compromising simplicity. The core of the application resides in the contracts, allowing the entire system to be configured and expanded in an efficient and automated way. Static files The recommendation regarding static files is to always use the CDN integration features available in the editor, as whenever the application is built all static files will be automatically uploaded and updated on the CDN, however if you want to maintain the availability of the files being served by the application, the system is configured to map a directory /public, if this directory exists in the export and deployment of the application, its files will be copied automatically, becoming available for public access without access control. Dev mode To start the application in development mode you can use the following command. $ yarn dev || npm run dev In this way, the initial application watches in parallel with the nodemon that checks for changes in the files and automatically reloads in case of changes, the server that provides the API will be loaded following the pure Typescript settings, the editor will be compiled for Javascript. Linting and formatting Like most public web applications that use Typescript, I use eslint and prettier to format and organize the code, making it possible to perform checks and corrections using the commands below # Lint with eslint $ yarn lint || npm run lint # Format with prettier $ yarn format || npm run format",
        "hierarchy": {
            "lvl0": "First steps",
            "lvl1": "Prerequisites",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "overview/introduction",
        "url": "/overview/introduction.html",
        "content": "Introduction CMMV (Contract-Model-Model-View) is a minimalistic framework designed to streamline the development of scalable and modular applications using TypeScript. By combining the power of contracts with a modular architecture, CMMV allows developers to define their entire application structure, from ORM entities to REST controllers and WebSocket endpoints, in a clear and maintainable way. The project is divided into three main components: Core System: The heart of CMMV, written in TypeScript and running on Node.js, is responsible for managing contracts, generating code, integrating with databases, and handling server-side operations. This component handles everything from parsing and code generation to integration with external services like cloud servers and databases. Backend: The CMMV backend is inspired by NestJS in terms of structure and organization, using a similar format of decorators, services, controllers, and other architectural patterns. This allows for a familiar development experience for those who already use NestJS, making it easier to create scalable and organized applications with a modular and object-oriented approach. Some implementations are quite different, especially when it comes to context and the need for dependency injection. Frontend: CMMV utilizes its own reactivity system, inspired by Vue 3 as the base framework. However, in the future, support for other frameworks such as React, Angular, and Vue will be available, even though their use is not recommended due to potential performance reduction and SEO issues. This approach simplifies the process of creating, managing, and deploying applications while offering optimal performance. CMMV draws inspiration from a wide range of technologies and concepts, blending ideas from game development (e.g., Unreal Engine’s Blueprints), component-based architectures (e.g., Delphi), and modern web development practices. It challenges traditional paradigms of web and application development, aiming to make the creation of complex systems as intuitive as possible. This project reflects over 20 years of experience in different languages and frameworks, with influences from Delphi, Unity, Unreal, C#, C++, JavaScript, Node.js, TypeScript, VSCode. We hope you find CMMV as exciting and powerful as we do. It’s the culmination of nearly a decade of work and passion for simplifying and improving the development process. Why CMMV? With over 20 years of experience in the tech industry as a programmer, I’ve developed various systems and projects used by millions of users. In 2020, I was working on my largest project to date, which was built on the following stack: backend using Node.js, TypeScript, NestJS, Nuxt.js, Redis, MongoDB, Elasticsearch, and RabbitMQ; frontend with Vue.js and Tailwind CSS; testing with Mocha, ESLint, and GitLab CI; infrastructure managed with Kubernetes and Nginx, and business intelligence powered by Grafana, Kafka, and IndexDB; along with a Flutter-based mobile app. Let’s dive into the problems we faced in this setup. First, the NestJS API, as more controllers and gateways were added, became increasingly difficult to manage and slowed down significantly, primarily due to dependency injection. Module management turned into a bureaucratic nightmare. Although the final application performed well, development became cumbersome. Furthermore, Nuxt’s SSR (server-side rendering) required integration, which often led to issues due to CORS policies. Communication between applications occurred via HTTP, and although NestJS supported RPC, Nuxt.js required custom proxies to implement WebSockets. Using Protobuf in the frontend presented additional challenges, and generating RPC controllers with Protoc resulted in a bloated codebase, making the application even heavier. Second, Nuxt.js, while capable of SSR, still relied on proxies with APIs to load data since it ran on a Vite-based implementation. Static page generation at scale, with thousands of pages, became an unattainable task. We tried, but the time required for page generation was prohibitive. Using standard SSR, with the proxy API and HTTP+JSON communication, significantly increased the TTFB (Time to First Byte), making optimization challenging. Only by delivering content directly through a CDN could we mitigate these delays, but even then, the page load was too slow for ideal SEO. Additionally, Nuxt.js generated numerous JavaScript bundles and data files to supplement frontend data binding, increasing page load and making SEO optimization a constant battle. It may seem counterintuitive to combine API and SSR into the same application due to competing processes, but consider that it’s much simpler to create a single load balancer that serves both frontend and backend. With direct integration, SSR eliminates latency when fetching data—excellent for reducing page load times and generating static pages. When well-integrated with Redis cache and efficient database queries, SSR can be nearly as fast as pre-rendered static pages. Moreover, this architecture simplifies integrations like internationalization, structured data, and sitemaps, making them much easier to manage and serve. Finally, the reduction in page onload time, which is also considered by search engines, is crucial. While Vue is an excellent tool, componentization in the frontend poses performance challenges due to potential deep coupling between components. Even with state management, critical issues related to element reactivity can lead to cascading update flows, which may either freeze the app or cause infinite loops. Avoiding such pitfalls requires a solid understanding of the underlying framework. Considering all these factors, I created CMMV (Contract-Model-Model-View). Initially, the goal was to develop a complete solution that would meet my development needs while maintaining the familiar syntax of NestJS, Vue, etc., but resolving the problems that have plagued me over the years and hampered development. After considering these factors, I created CMMV (Contract-Model-Model-View). My goal was not to compete with or replace any of the mentioned tools. All the technologies I’ve mentioned are of excellent quality and come highly recommended. They have large communities and are suitable for most projects. However, I had unique challenges in my projects, particularly around handling high volumes of traffic and the need for the best possible SEO performance. Despite my best efforts with my previous stack, the results were still not satisfactory for my specific needs. CMMV was born out of this necessity to address these exceptional requirements. André Ferreira (CEO) Read before use The CMMV framework is released under the MIT license, allowing anyone to use and modify it freely. However, it’s important to note that the primary purpose of this project is to meet my personal needs for a specific project I am working on. It was not designed to be a general-purpose framework for the broader developer community or to cater to the needs of the majority of developers. As a result, some modules or features that you might require may not have native implementations or official support in CMMV. If you find the need to use services such as Memcache, Kafka, or any other service that isn’t natively supported by CMMV, you will need to create a communication interface for these services. The project is flexible enough to allow such integrations, but keep in mind that the design is tailored to my specific requirements. If you like the project and develop solutions for other services, I encourage you to release your solution on NPM, update the documentation, and submit a pull request. However, any addition of new modules to the core of the project must be discussed with the moderators to ensure that the implementation aligns with the overall goals of the project. If not, your pull request will be denied. I’m not here to engage in debates over architectural choices or personal preferences. For example, if you prefer React syntax over Vue, you are free to fork the project and modify it to fit your preferred stack or technology. However, do not expect CMMV to be changed to suit your individual needs. The project is focused on solving my specific workflow and use cases. While CMMV provides flexibility for customization, any changes that affect the core of the project will be carefully reviewed. The main guiding principle is that this project is built to meet my own needs, not yours.",
        "hierarchy": {
            "lvl0": "Introduction",
            "lvl1": "Why CMMV?",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "http/services",
        "url": "/http/services.html",
        "content": "Services In @cmmv/core, services play a crucial role in managing business logic, serving as a bridge between the data repositories, cache, and external communication layers like HTTP or RPC. Services are responsible for handling data transformations and ensuring that external communication is model-agnostic, meaning the service works with models and automatically converts them as necessary. To create a service, use the @Service decorator. This decorator allows the service to be recognized by the framework and utilized throughout the application. @Service(&#x27;task&#x27;) export class TaskService extends AbstractService { public override name = &#x27;task&#x27;; // Service methods and logic } How Services Work Input and Output Models: Services use models (e.g., Task, ITask) to define their input and output. These models are automatically transformed when interacting with repositories or external communication layers. Data Handling: Services interface with the Repository to handle data persistence and retrieval. They are also responsible for validation, caching, and error handling. Telemetry: The service includes telemetry for performance tracking and logging, helping monitor execution times and request identifiers. Using Services In @cmmv, since the system doesn’t implement traditional dependency injection, you can easily register services as providers in any module and access them via the constructor of a class. This simplifies the service usage across controllers, gateways, or other components. import { TaskService } from &#x27;../services/task.service&#x27;; import { Task } from &#x27;../models/task.model&#x27;; import { Cache, CacheService } from &quot;@cmmv/cache&quot;; @Controller(&#x27;task&#x27;) export class TaskController { constructor(private readonly taskservice: TaskService) {} @Get() @Cache(&quot;task:getAll&quot;, { ttl: 300, compress: true }) async getAll(@Queries() queries: any, @Request() req): Promise&lt;Task[]&gt; { let result = await this.taskservice.getAll(queries, req); return result; } } Agnostic In the @cmmv framework, services are agnostic to the type of controller that invokes them, ensuring they can be used across HTTP controllers, RPC gateways, or other components. Services are automatically generated based on contract configurations and can be extended with the @cmmv/repository module to support database entities or @cmmv/cache for managing and retrieving cached data. While services handle business logic, authentication directives (@cmmv/auth) are applied at the controller or gateway level to ensure secure access. This modular approach allows for flexible and scalable service management. Singleton Global access services in @cmmv should be implemented as singletons to ensure consistent behavior and efficient resource usage across the application. Singletons prevent the creation of multiple instances of a service, centralizing operations such as caching and database management. To learn more about the implementation and benefits of singletons in @cmmv, please refer to the documentation available at CMMV Singleton Documentation. This documentation provides detailed guidance on how to implement and manage singleton services effectively.",
        "hierarchy": {
            "lvl0": "Services",
            "lvl1": "How Services Work",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "http/controllers",
        "url": "/http/controllers.html",
        "content": "Controllers The @cmmv/http module automatically generates REST controllers with standard CRUD operations based on defined contracts. However, you can create custom controllers using a syntax similar to NestJS, with decorators for defining routes and methods. Unlike NestJS, CMMV does not use complex dependency injection. Instead, services like databases, queues, and cache must be implemented as singletons. Here’s an example of a custom controller: import * as fs from &#x27;fs&#x27;; import * as path from &quot;path&quot;; import { Controller, Get, Param, Response, ServiceRegistry } from &#x27;@cmmv/http&#x27;; import { DocsService } from &#x27;./docs.service&#x27;; @Controller(&quot;docs&quot;) export class DocsController { constructor(private docsService: DocsService){} @Get() async index(@Response() res) { res.render(&quot;views/docs/index&quot;, { docs: await this.docsService.getDocsStrutucture(), services: ServiceRegistry.getServicesArr() }); } @Get(&quot;:item&quot;) async getDoc(@Param(&quot;item&quot;) item: string, @Response() res) { const file = path.resolve(&quot;./docs/&quot; + item + &quot;.html&quot;); const data = await this.docsService.getDocsStrutucture(file); res.render(&quot;views/docs/index&quot;, { docs: data, services: ServiceRegistry.getServicesArr() }); } } @Controller(prefix: string) Defines the controller and the route prefix for all its methods. The prefix parameter is optional, but it defines a base URL for the controller’s routes. @Controller(&#x27;tasks&#x27;) export class TaskController { ... } @Request() / @Req() Binds the entire request object to the method parameter. @Get() async getRequestData(@Request() req: any): Promise&lt;any&gt; { return req; } @Response() / @Res() Binds the entire response object to the method parameter, useful for handling custom responses. @Get() async customResponse(@Response() res: any): Promise&lt;void&gt; { res.send(&#x27;Custom Response&#x27;); } @Next() Binds the next function in middleware to the method parameter, useful for middleware chaining. @Get() async handleRequest(@Next() next: Function): Promise&lt;void&gt; { next(); } @Get(path?: string) Maps an HTTP GET request to a specific method. The optional path argument can define the route, or it will default to the controller’s base route. @Get(&#x27;:id&#x27;) getTaskById(@Param(&#x27;id&#x27;) id: string) { return this.taskService.getById(id); } @Post(path?: string) Handles HTTP POST requests. The @Body decorator can be used to access the request body and pass it to the method. @Post() addTask(@Body() task: any) { return this.taskService.add(task); } @Put(path?: string) Maps an HTTP PUT request to update existing resources. Like @Post, it can accept data through the request body. @Put(&#x27;:id&#x27;) updateTask(@Param(&#x27;id&#x27;) id: string, @Body() task: any) { return this.taskService.update(id, task); } @Delete(path?: string) Handles DELETE requests for removing resources by ID. @Delete(&#x27;:id&#x27;) deleteTask(@Param(&#x27;id&#x27;) id: string) { return this.taskService.delete(id); } @Param(param: string) Used to extract parameters from the route. In the example, @Param(‘id’) extracts the id from the request’s route. @Get(&#x27;:id&#x27;) getTaskById(@Param(&#x27;id&#x27;) id: string) { return this.taskService.getById(id); } @Body() This decorator extracts the request body and makes it available in the method. It’s commonly used with @Post and @Put for creating and updating data. @Query() Extracts query parameters from the request. @Get() getTasks(@Query(&#x27;status&#x27;) status: string) { return this.taskService.getByStatus(status); } @Queries() Binds all query parameters to the method parameter. @Get() async getAll(@Queries() queries: any): Promise&lt;Task[]&gt; { return this.taskService.getAll(queries); } @Header(headerName: string) Binds a specific header value to the method parameter. @Get() async checkHeader(@Header(&#x27;Authorization&#x27;) auth: string): Promise&lt;boolean&gt; { return this.authService.verifyToken(auth); } @Headers() Binds all headers to the method parameter. @Get() async getHeaders(@Headers() headers: any): Promise&lt;any&gt; { return headers; } @Session() Extracts session data and binds it to the method parameter. @Get() async getSessionData(@Session() session: any): Promise&lt;any&gt; { return session; } @Ip() Binds the client’s IP address to the method parameter. @Get() async getClientIp(@Ip() ip: string): Promise&lt;string&gt; { return ip; } @HostParam() Extracts the host information from the request. @Get() async getHost(@HostParam() host: string): Promise&lt;string&gt; { return host; } Getting up and running To make the controller functional, it needs to be added to a module and called in the application. The process involves creating a module, registering the controller, and ensuring the module is used during application initialization. Here is an example of registering a controller inside a module: import { Module } from &#x27;@cmmv/core&#x27;; import { TaskController } from &#x27;./controllers/task.controller&#x27;; export let TaskModule = new Module({ controllers: [TaskController], ... }); Once the module is created, you can import and load it into the main application configuration, ensuring the controller is properly initialized and accessible for handling requests. The module will automatically handle routing and the controller logic when linked to the application setup. This modular design enables the clean separation of concerns and simplifies adding and managing controllers in the CMMV framework.",
        "hierarchy": {
            "lvl0": "Controllers",
            "lvl1": "@Controller(prefix: string)",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "http/overview",
        "url": "/http/overview.html",
        "content": "Overview The CMMV framework introduces its own default server implementation, @cmmv/server, which offers superior performance and seamless integration with the overall CMMV ecosystem. This server is highly optimized and designed to provide built-in support for critical features such as compression, routing, request handling, static file serving, security, and middleware management. Because @cmmv/server is developed as a core part of CMMV, it allows for better control over feature enhancements, bug fixes, and performance improvements, making it the recommended option for most applications. The server is flexible and shares many of the same APIs and capabilities as Express and Fastify, which ensures an easy transition if you’re familiar with those frameworks. However, @cmmv/server also includes enhanced integration with CMMV’s contracts, modules, and services, providing a more consistent developer experience across different layers of the application. Key Features: HTTP and HTTPS Support: The adapter can initialize servers using both HTTP and HTTPS based on configuration. Middleware Management: Preconfigured middlewares such as compression, CORS, Helmet (security), and session handling are included. Static File Serving: Automatically serves static files from the /public directory. View Engine: Supports rendering HTML views using CMMVRenderer, a custom template engine with security options like CSP. Controller Registration: Automatically registers controllers by scanning the ControllerRegistry and mapping HTTP methods (GET, POST, PUT, DELETE) to paths. Session and Security Headers: Adds session management using express-session and security headers like Content Security Policy, XSS Protection, and HSTS. Request Tracking: Each request is assigned a unique requestId for telemetry and monitoring. Open Connection Tracking: Tracks and closes open connections when the server shuts down. Error Handling: Captures and logs errors during request processing, providing detailed error messages. Default Server import { Application } from &#x27;@cmmv/core&#x27;; import { DefaultAdapter, DefaultHTTPModule } from &#x27;@cmmv/http&#x27;; Application.create({ httpAdapter: DefaultAdapter, modules: [DefaultHTTPModule, ...], services: [...], contracts: [...], }); Express In addition to the default server, CMMV also supports Express and Fastify as alternative HTTP adapters, providing flexibility for developers who prefer or need to use these popular frameworks. Both Express and Fastify adapters are fully integrated into the CMMV ecosystem and can be used by simply switching the adapter in the application configuration. import { Application } from &#x27;@cmmv/core&#x27;; import { ExpressAdapter, ExpressModule } from &#x27;@cmmv/http&#x27;; Application.create({ httpAdapter: ExpressAdapter, modules: [ExpressModule, ...], services: [...], contracts: [...], }); The adapter registers all controllers automatically from the ControllerRegistry. It matches the controller’s routes to the corresponding HTTP methods (GET, POST, etc.), and processes middleware defined at the controller level. Fastify The Fastify Adapter in CMMV provides an alternative to the Express Adapter, allowing for lightweight, high-performance HTTP handling using Fastify’s framework. This adapter integrates key middleware like compression, CORS, helmet for security, and static file serving. It automatically registers controllers and manages the lifecycle of incoming requests. The Fastify Adapter follows the same structure as the Express Adapter, supporting session management and content rendering, while offering a faster, more optimized environment. Both Express and Fastify adapters are natively supported, and custom HTTP adapters can be created by extending the AbstractHttpAdapter. import { Application } from &#x27;@cmmv/core&#x27;; import { FastifyAdapter, FastifyModule } from &#x27;@cmmv/http&#x27;; Application.create({ httpAdapter: FastifyAdapter, modules: [FastifyModule, ...], services: [...], contracts: [...], }); Middlewares The httpMiddlewares configuration allows you to inject custom middleware into the HTTP adapter (such as Express or Fastify) during the application’s initialization. This provides additional flexibility by letting you apply any middleware functions to handle tasks like logging, request validation, or security checks. To use this feature, define an array of middleware functions in the httpMiddlewares property when creating the application. Here’s an example where we add the morgan logging middleware to an Express-based CMMV application: import { Application } from &quot;@cmmv/core&quot;; import { ExpressAdapter, ExpressModule } from &quot;@cmmv/http&quot;; import { ViewModule } from &quot;@cmmv/view&quot;; import morgan from &quot;morgan&quot;; Application.create({ httpAdapter: ExpressAdapter, httpMiddlewares: [ morgan(&#x27;dev&#x27;), ], modules: [ ExpressModule, ViewModule ] }); In this example, the morgan middleware is used to log incoming HTTP requests in the ‘dev’ format. This middleware is passed into the httpMiddlewares configuration, which applies it automatically during the application’s initialization. The httpMiddlewares array can include any number of middlewares, and each will be applied in the order they are provided. Make sure to import any custom middleware before passing it into the configuration. This configuration helps expand the capabilities of your application by allowing you to use any custom or third-party middleware that your chosen HTTP adapter (like Express or Fastify) supports.",
        "hierarchy": {
            "lvl0": "Overview",
            "lvl1": "Default Server",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "server/view-engine",
        "url": "/server/view-engine.html",
        "content": "View Engine In web applications, the view engine is responsible for rendering templates and generating HTML pages. In a typical setup, the view engine takes dynamic data and renders it into a static HTML page that is sent to the client. The res.render method in the server allows you to render a template using the view engine you configure. In this documentation, we’ll demonstrate how to set up and use a view engine, specifically with the popular Pug template engine. However, it’s possible to configure different view engines depending on your needs. In the following example, we configure the Pug template engine to render .pug files from the /views directory. Here’s how you can set it up: // Import the necessary modules import cmmv from &#x27;@cmmv/server&#x27;; import { json, urlencoded } from &#x27;@cmmv/server&#x27;; import { readFileSync } from &#x27;fs&#x27;; import path from &#x27;path&#x27;; // Initialize the app const app = cmmv(); // Set the view engine to Pug app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;); // Specify the directory where views are located app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;)); // Middleware to parse JSON and URL-encoded data app.use(json({ limit: &#x27;50mb&#x27; })); app.use(urlencoded({ extended: true })); // Example route to render a Pug template app.get(&#x27;/view&#x27;, function (req, res) { res.render(&#x27;index&#x27;, { title: &#x27;Hello&#x27;, message: &#x27;Welcome to the app!&#x27; }); }); // Start the server const host = &#x27;0.0.0.0&#x27;; const port = 3000; app.listen({ host, port }).then((server) =&gt; { console.log(`Server running at http://${host}:${port}`); }).catch((err) =&gt; { console.error(err); }); The default views directory is /views, but this can be customized as shown in the example. The Pug template engine expects files with the .pug extension inside this directory. For example, the index.pug file in the /views directory could look like this: doctype html html head title= title body h1= message By setting up a view engine, you can dynamically generate HTML pages based on templates and data. The example provided shows how to configure the Pug template engine and use it to render HTML from Pug templates stored in a specific directory. This allows you to easily manage dynamic content and display it to the client in your web application. In CMMV, you can configure various view engines supported by Express, such as EJS, Mustache, and others. Furthermore, you can also create custom implementations to suit your needs. For instance, in CMMV, there is native support for SSR (Server-Side Rendering) using the custom view engine @cmmv/view. Below is an example implementation that demonstrates how to configure and use the CMMV custom view engine. Custom View Engine This implementation configures a custom view engine that processes .html files for SSR (Server-Side Rendering). It uses CMMV’s own view engine, which provides flexibility in handling dynamic content with custom headers and nonce generation for security policies. import cmmv from &#x27;@cmmv/server&#x27;; import { v4 as uuidv4 } from &#x27;uuid&#x27;; import path from &#x27;path&#x27;; import fs from &#x27;fs&#x27;; import Config from &#x27;./config&#x27;; // Assume you have a Config service for app configuration const publicDir = path.join(process.cwd(), &#x27;public&#x27;); const app = cmmv(); // Setting up the view engine to process .html files using the custom engine app.set(&#x27;views&#x27;, publicDir); app.set(&#x27;view engine&#x27;, &#x27;html&#x27;); app.engine(&#x27;html&#x27;, (filePath, options, callback) =&gt; { app.render.renderFile( filePath, options, { nonce: options.nonce || &#x27;&#x27; }, callback, ); }); // Adding a hook to manage requests and handle headers with security policies app.addHook(&#x27;onRequest&#x27;, (req, res, next) =&gt; { req.requestId = uuidv4(); res.locals = {}; res.locals.nonce = uuidv4().substring(0, 8); // Set custom security headers const customHeaders = Config.get(&#x27;headers&#x27;) || {}; for (const headerName in customHeaders) { let headerValue = customHeaders[headerName]; if (Array.isArray(headerValue)) { headerValue = headerValue .map(value =&gt; { if (headerName === &#x27;Content-Security-Policy&#x27;) return value.indexOf(&#x27;style-src&#x27;) == -1 ? `${value} &#x27;nonce-${res.locals.nonce}&#x27;` : value; return value; }) .join(&#x27;; &#x27;); } else if (typeof headerValue === &#x27;string&#x27;) { if (headerName === &#x27;Content-Security-Policy&#x27;) headerValue = headerValue.indexOf(&#x27;style-src&#x27;) == -1 ? `${headerValue} &#x27;nonce-${res.locals.nonce}&#x27;` : headerValue; } res.setHeader(headerName, headerValue); } // Serve HTML files from the /public/views directory const publicDir = path.join(process.cwd(), &#x27;public/views&#x27;); const requestPath = req.path === &#x27;/&#x27; ? &#x27;index&#x27; : req.path.substring(1); const possiblePaths = [ path.join(publicDir, `${requestPath}.html`), path.join(publicDir, requestPath, &#x27;index.html&#x27;), path.join(publicDir, `${requestPath}`), path.join(publicDir, requestPath, &#x27;index.html&#x27;), ]; // Check if any of the possible paths exists let fileFound = false; for (const filePath of possiblePaths) { if (fs.existsSync(filePath)) { fileFound = true; const config = Config.getAll(); return res.render(filePath, { nonce: res.locals.nonce, requestId: req.requestId, config, }); } } if (!fileFound) res.code(404).send(&#x27;Page not found&#x27;); next(); }); // Start the server const host = &#x27;0.0.0.0&#x27;; const port = 3000; app.listen({ host, port }).then(server =&gt; { console.log(`Server running at http://${host}:${port}`); }); The CMMV framework provides flexibility by supporting any view engine compatible with Express, such as EJS, Mustache, and more. Additionally, you can implement custom view engines, like the @cmmv/view engine used in the example above, to enhance server-side rendering capabilities and optimize performance with customized behavior.",
        "hierarchy": {
            "lvl0": "",
            "lvl1": "View Engine",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "server/middleware",
        "url": "/server/middleware.html",
        "content": "Middleware The middleware system in @cmmv/server offers flexibility and powerful integration for processing HTTP requests and responses. Similar to Express, it provides hooks and integration points that allow developers to modify the behavior of requests as they flow through the system. However, the middleware in @cmmv/server also introduces new behaviors and optimizations, particularly through its use of hooks. This system allows for the implementation of essential middleware functions such as ETag, Body-Parser, Compression, Cookie-Parser, CORS, Helmet, and Server-Static, each of which follows a common pattern. Some of these middlewares, like ETag, are fully compatible with Express. Others, such as Server-Static, have custom implementations that introduce specific behavior changes, making them incompatible with Express. The core design of middleware in @cmmv/server revolves around hooks, which are triggered at various points in the request-response lifecycle. This design allows for more precise and efficient processing of requests. Sample ETag middleware is used to manage ETag headers for caching purposes. ETags are a mechanism for cache validation and are generated based on the content of the response body. If the content hasn’t changed between requests, the server can respond with a 304 Not Modified status, improving performance. Here’s an example of the ETag middleware implemented in @cmmv/server: export class EtagMiddleware { public middlewareName: string = &#x27;etag&#x27;; protected options: ETagOptions; constructor(options?: ETagOptions) { this.options = { algorithm: options?.algorithm || &#x27;sha1&#x27;, weak: Boolean(options?.weak === true), }; } async process(req, res, next) { if (req.app &amp;&amp; typeof req.app.addHook == &#x27;function&#x27;) req.app.addHook(&#x27;onSend&#x27;, this.onCall.bind(this)); else this.onCall.call(this, req, res, res.body, next); } onCall(req, res, payload, done) { const hash = this.buildHashFn(this.options.algorithm, this.options.weak); let etag = res.getHeader(&#x27;etag&#x27;); let newPayload; if (!etag) { if (!(typeof payload === &#x27;string&#x27; || payload instanceof Buffer)) { done(null, newPayload); return; } etag = hash(payload); res.set(&#x27;etag&#x27;, etag); } if ( req.headers[&#x27;if-none-match&#x27;] === etag || req.headers[&#x27;if-none-match&#x27;] === &#x27;W/&#x27; + etag || &#x27;W/&#x27; + req.headers[&#x27;if-none-match&#x27;] === etag ) { res.code(304); newPayload = &#x27;&#x27;; } done(null, newPayload); } buildHashFn(algorithm = &#x27;sha1&#x27;, weak = false) { this.validateAlgorithm(algorithm); const prefix = weak ? &#x27;W/&quot;&#x27; : &#x27;&quot;&#x27;; if (algorithm === &#x27;fnv1a&#x27;) return payload =&gt; prefix + fnv1a(payload).toString(36) + &#x27;&quot;&#x27;; return payload =&gt; prefix + createHash(algorithm).update(payload).digest(&#x27;base64&#x27;) + &#x27;&quot;&#x27;; } validateAlgorithm(algorithm) { if (algorithm === &#x27;fnv1a&#x27;) return true; try { createHash(algorithm); } catch (e) { throw new TypeError(`Algorithm ${algorithm} not supported.`); } } } export default async function (options?: ETagOptions) { const middleware = new EtagMiddleware(options); return (req, res, next) =&gt; middleware.process(req, res, next); } export const etag = function (options?: ETagOptions) { const middleware = new EtagMiddleware(options); return (req, res, next) =&gt; middleware.process(req, res, next); }; The middleware system in @cmmv/server is designed to offer both compatibility with Express and enhancements that provide better control over the request-response cycle. By leveraging hooks and selective execution, the system ensures that middleware only runs when necessary, leading to better performance. While most middleware is compatible with Express, some—like Server-Static—introduce specific behavior changes. This system is designed to be flexible and modular, allowing you to implement custom middleware easily, integrate existing middleware, and optimize your application’s performance. Additionally, all middlewares implemented for @cmmv/server must return a promise, ensuring they fit into the asynchronous lifecycle of the framework. When possible, compatible versions of middleware are provided for use in Express applications. Compression The @cmmv/compression middleware provides HTTP response compression for your server, supporting gzip, deflate, and brotli encodings. Compression reduces the size of the response body, which improves the speed and efficiency of content delivery to the client. It can be used in both @cmmv/server and Express environments with some variations in implementation. This middleware integrates seamlessly with the request lifecycle, applying compression to responses based on content type, size, and the client’s Accept-Encoding header. The middleware automatically handles large payloads and dynamically adjusts encoding for different content types. Installation To install the @cmmv/compression middleware, run the following command: npm install @cmmv/compression Usage When using @cmmv/server, the compression middleware must be added as part of the middleware chain. Here’s an example of how to use it: import compression from &#x27;@cmmv/compression&#x27;; app.use(compression({ threshold: 1024, cacheEnabled: true })); The @cmmv/compression middleware comes with a range of options to control how and when compression is applied. Below is a list of available options: Option Type Default Description threshold number or string 1024 Specifies the minimum response size (in bytes) required for compression to be applied. Smaller responses are not compressed. Accepts human-readable string values such as ‘1kb’. cacheEnabled boolean false Enables caching of compressed responses to improve performance on repeated requests. Responses will be stored in memory for the specified duration. cacheTimeout number 60000 (1 min) Sets the timeout (in milliseconds) after which cached compressed responses are purged from the memory cache. Only applicable if cacheEnabled is true. algorithm string 'sha1' Specifies the hashing algorithm used to generate an ETag for caching validation. Supported values include sha1, md5, and fnv1a. weak boolean false Indicates whether the ETag should be marked as “weak”, meaning it provides less strict validation for cache revalidation. level number zlib.constants.Z_DEFAULT_COMPRESSION Specifies the compression level for zlib-based algorithms. Accepts a value between 0 (no compression) and 9 (maximum compression). memLevel number 8 Controls the memory usage for compression (higher values use more memory but provide better compression). Accepts values between 1 and 9. strategy number zlib.constants.Z_DEFAULT_STRATEGY Specifies the compression strategy to be used by zlib algorithms. Common strategies include Z_FILTERED, Z_HUFFMAN_ONLY, and Z_RLE. filter function shouldCompress A function to determine whether or not a response should be compressed based on its content type or other factors. flush boolean false Enables the manual flushing of compression buffers. When enabled, the server can force a flush when necessary (for example, when streaming responses). chunkSize number 16384 Defines the chunk size used for compression streams. Smaller chunk sizes result in more frequent writes but can impact performance. windowBits number 15 Specifies the size of the compression window (in bits). A larger window size provides better compression but uses more memory. Cookie-Parser The @cmmv/cookie-parser middleware is designed to parse cookies in HTTP requests, both signed and unsigned, and make them available in the req.cookies object. It supports both CMMV and Express, providing seamless integration with either framework. Installation npm install @cmmv/cookie-parser Usage In CMMV, the middleware is used by registering it with the app using hooks. It will automatically parse cookies on incoming requests and make them available in the req.cookies and req.signedCookies objects. import cmmv from &#x27;@cmmv/server&#x27;; import cookieParser from &#x27;@cmmv/cookie-parser&#x27;; const app = cmmv(); app.use(cookieParser({ secret: &#x27;mySecretKey&#x27; })); app.get(&#x27;/cookies&#x27;, (req, res) =&gt; { res.send({ cookies: req.cookies, signedCookies: req.signedCookies, }); }); app.listen({ port: 3000 }); Option Type Default Description name string The name of the cookie to parse. secret string/string[] [] A string or array of strings used to sign and verify cookies. This ensures the integrity of signed cookies. decode function A custom decoder function for parsing cookies. If not provided, the default decodeURIComponent is used. path string '/' Defines the URL path that must exist for the cookie to be included in requests. Example for Signed Cookies app.use(cookieParser({ secret: &#x27;mySecretKey&#x27; })); app.get(&#x27;/set-cookie&#x27;, (req, res) =&gt; { res.cookie(&#x27;name&#x27;, &#x27;value&#x27;, { signed: true }); res.send(&#x27;Cookie set&#x27;); }); app.get(&#x27;/get-cookie&#x27;, (req, res) =&gt; { res.json({ signedCookies: req.signedCookies }); }); Cors The CORS (Cross-Origin Resource Sharing) middleware allows you to enable cross-origin resource sharing for your applications by setting appropriate HTTP headers. It is based on the Express CORS middleware but has been adapted to support asynchronous hooks for the CMMV server environment, making it fully compatible with @cmmv/server while maintaining compatibility with Express wherever possible. Installation npm install @cmmv/cors Usage import cmmv from &#x27;@cmmv/server&#x27;; import cors from &#x27;@cmmv/cors&#x27;; const app = cmmv(); app.use(cors()); app.listen({ port: 3000 }); Option Type Default Description origin string or function * Specifies the origin that is allowed to access the resource. Can be a string, array, or function. methods string or string[] 'GET,HEAD,PUT,PATCH,POST,DELETE' Specifies the HTTP methods allowed for cross-origin requests. preflightContinue boolean false If true, the middleware will not short-circuit preflight requests and will pass them to the next handler. optionsSuccessStatus number 204 The status code sent for successful OPTIONS requests (preflight). Some legacy browsers use 204 for success. credentials boolean false If true, the Access-Control-Allow-Credentials header will be set to true. maxAge number 0 Specifies the time in seconds that browsers are allowed to cache preflight responses. headers string or string[] undefined Specifies which headers are allowed to be sent in a request. allowedHeaders string or string[] undefined Specifies the headers that can be used in the actual request. Defaults to the request’s Access-Control-Request-Headers. exposedHeaders string or string[] undefined Specifies which headers are exposed to the browser. Defaults to none. Etag The CMMV ETag middleware automatically adds an ETag header to HTTP responses, helping with cache validation by generating a unique hash for each response payload. This middleware is based on the Fastify ETag implementation but adapted to work within the CMMV framework. The ETag header allows browsers and other clients to determine whether the content has changed since the last request, reducing bandwidth usage and improving performance. This middleware is designed to support both CMMV and Express environments. For CMMV, the default export returns a promise, and for Express, a separate etag function is available. Installation npm install @cmmv/etag Usage import cmmv from &#x27;@cmmv/server&#x27;; import etag from &#x27;@cmmv/etag&#x27;; const app = cmmv(); app.use(etag()); app.listen({ port: 3000 }); The ETagOptions interface provides several configuration options to customize the behavior of the ETag middleware. Option Type Default Description algorithm string ‘sha1’ Specifies the hashing algorithm to use for generating the ETag. Supported values include ‘sha1’, ‘md5’, and ‘fnv1a’. weak boolean false If true, the middleware generates weak ETags (prefixed with W/). Weak ETags allow for more lenient cache validation. Helmet The @cmmv/helmet middleware is designed to enhance the security of web applications by setting various HTTP headers. It provides support for content security policies, security headers like X-Frame-Options, Strict-Transport-Security, and more. This middleware is built with flexibility in mind, allowing you to customize its behavior based on your application’s requirements. It follows a similar implementation pattern to the popular helmet library and includes native integration with CMMV while maintaining compatibility with Express when possible. This middleware automatically configures HTTP security headers for better protection against common vulnerabilities such as cross-site scripting (XSS) attacks, clickjacking, and data sniffing. Installation npm install @cmmv/helmet Usage import cmmv from &#x27;@cmmv/server&#x27;; import helmet from &#x27;@cmmv/helmet&#x27;; const app = cmmv(); app.use(helmet({ contentSecurityPolicy: { directives: { defaultSrc: [&quot;&#x27;self&#x27;&quot;], scriptSrc: [&quot;&#x27;self&#x27;&quot;, &quot;https://trustedscripts.com&quot;], }, }, hsts: { maxAge: 31536000, // Force HTTPS for one year }, frameguard: { action: &#x27;deny&#x27;, // Disallow iframes entirely } })); app.listen({ port: 3000 }); The HelmetMiddleware allows for configuring various HTTP headers and security policies. Below is the list of available options: Option Type Default Description contentSecurityPolicy object or boolean Enabled with default policies Configures the Content Security Policy (CSP) header. Can be disabled by setting it to false or customized by providing an object. frameguard object or boolean SAMEORIGIN Sets the X-Frame-Options header to prevent clickjacking. dnsPrefetchControl boolean true Controls the X-DNS-Prefetch-Control header to improve privacy. expectCt object or boolean false Adds the Expect-CT header to enforce Certificate Transparency requirements. hsts object or boolean true Sets the Strict-Transport-Security header to force HTTPS connections for a specified time. ieNoOpen boolean true Sets the X-Download-Options header to prevent file downloads from opening automatically in Internet Explorer. noSniff boolean true Sets the X-Content-Type-Options header to prevent browsers from MIME-sniffing the response. xssFilter boolean true Sets the X-XSS-Protection header to enable the XSS filter built into most modern web browsers. referrerPolicy string or object no-referrer Configures the Referrer-Policy header to control the information sent in the Referer header. hidePoweredBy boolean or object true Hides the X-Powered-By header to avoid leaking information about the server technology. permittedCrossDomainPolicies object or boolean false Configures the X-Permitted-Cross-Domain-Policies header, often used by Flash/Adobe products. Server-Static The @cmmv/server-static middleware provides functionality to serve static files from a directory. It is inspired by serve-static from Express and Fastify’s fastify-static. This middleware can be configured to serve files from one or more directories and provides caching, file compression, and other useful options for serving static content. You can use the serveStatic function to serve static files from a directory: import cmmv, { serverStatic } from &#x27;@cmmv/server&#x27;; const app = cmmv(); const host = &#x27;0.0.0.0&#x27;; const port = 3000; app.use(serverStatic(&#x27;public&#x27;)); app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;); app.get(&#x27;/view&#x27;, function (req, res) { res.render(&#x27;index&#x27;, { title: &#x27;Hey&#x27;, message: &#x27;Hello there!&#x27; }); }); app.listen({ host, port }) .then(server =&gt; { console.log( `Listen on http://${server.address().address}:${server.address().port}`, ); }) .catch(err =&gt; { throw Error(err.message); }); All Middlwares This example sets up a server using @cmmv/server with various middlewares to efficiently handle HTTP requests. It serves static files from the public folder, enables CORS for cross-origin resource sharing, and adds ETag headers for caching using the fnv1a algorithm. The cookie parser middleware is used to parse cookies and populate req.cookies, while JSON and URL-encoded parsers process request body data. Responses are compressed using GZIP via the compression middleware, and Helmet adds security headers, including a custom Content Security Policy. The server defines routes to handle basic GET and POST requests, render views, send JSON responses, and handle dynamic routes. It listens on 0.0.0.0:3000, with an option to enable HTTP/2 and HTTPS if certificates are provided. //import { readFileSync } from &quot;node:fs&quot;; import cmmv, { json, urlencoded, serverStatic } from &#x27;@cmmv/server&#x27;; import etag from &#x27;@cmmv/etag&#x27;; import cors from &#x27;@cmmv/cors&#x27;; import cookieParser from &#x27;@cmmv/cookie-parser&#x27;; import compression from &#x27;@cmmv/compression&#x27;; import helmet from &#x27;@cmmv/helmet&#x27;; const app = cmmv({ /*http2: true, https: { key: readFileSync(&quot;./cert/private-key.pem&quot;), cert: readFileSync(&quot;./cert/certificate.pem&quot;), passphrase: &quot;1234&quot; }*/ }); const host = &#x27;0.0.0.0&#x27;; const port = 3000; app.use(serverStatic(&#x27;public&#x27;)); app.use(cors()); app.use(etag({ algorithm: &#x27;fnv1a&#x27; })); app.use(cookieParser()); app.use(json({ limit: &#x27;50mb&#x27; })); app.use(urlencoded({ limit: &#x27;50mb&#x27;, extended: true })); app.use(compression({ level: 6 })); app.use( helmet({ contentSecurityPolicy: { useDefaults: false, directives: { defaultSrc: [&quot;&#x27;self&#x27;&quot;], scriptSrc: [&quot;&#x27;self&#x27;&quot;, &#x27;example.com&#x27;], objectSrc: [&quot;&#x27;none&#x27;&quot;], upgradeInsecureRequests: [], }, }, }), ); app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;); app.get(&#x27;/view&#x27;, function (req, res) { res.render(&#x27;index&#x27;, { title: &#x27;Hey&#x27;, message: &#x27;Hello there!&#x27; }); }); app.get(&#x27;/&#x27;, async (req, res) =&gt; { res.send(&#x27;Hello World&#x27;); }); app.get(&#x27;/json&#x27;, async (req, res) =&gt; { res.json({ hello: &#x27;world&#x27; }); }); app.get(&#x27;/user/:id&#x27;, async (req, res) =&gt; { res.send(&#x27;User &#x27; + req.params.id); }); app.get(&#x27;/users&#x27;, async (req, res) =&gt; { res.json(req.query); }); app.post(&#x27;/test&#x27;, async (req, res) =&gt; { console.log(req.body); res.send(&#x27;ok&#x27;); }); app.listen({ host, port }) .then(server =&gt; { const addr = server.address(); console.log( `Listen on http://${addr.address}:${addr.port}`, ); }) .catch(err =&gt; { throw Error(err.message); });",
        "hierarchy": {
            "lvl0": "Middleware",
            "lvl1": "Sample",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "server/http2",
        "url": "/server/http2.html",
        "content": "HTTP2 The @cmmv/server framework natively supports HTTP/2, which offers significant performance improvements over HTTP/1.1 by allowing multiplexed streams, header compression, and server push. These features are ideal for applications that need faster page load times and better resource utilization, especially in modern web applications. HTTP/2 is particularly useful for reducing latency, improving page load performance, and enhancing the overall efficiency of the client-server communication. Enabling HTTP/2 in @cmmv/server To enable HTTP/2, you simply need to configure the server with the http2 option set to true. Additionally, you will need to provide SSL certificates since HTTP/2 requires HTTPS for browser support. Here’s an example of how to implement HTTP/2 support in @cmmv/server: Example with HTTP/2 import { readFileSync } from &#x27;node:fs&#x27;; import cmmv from &#x27;@cmmv/server&#x27;; const app = cmmv({ http2: true, // Enable HTTP/2 https: { key: readFileSync(&#x27;./cert/private-key.pem&#x27;), cert: readFileSync(&#x27;./cert/certificate.pem&#x27;), passphrase: &#x27;1234&#x27; } }); const host = &#x27;0.0.0.0&#x27;; const port = 3000; app.get(&#x27;/&#x27;, (req, res) =&gt; { res.send(&#x27;Hello HTTP/2 World!&#x27;); }); app.listen({ host, port }) .then(server =&gt; { console.log( `HTTP/2 server running on https://${server.address().address}:${server.address().port}` ); }) .catch(err =&gt; { throw new Error(err.message); }); ALPN negotiation allows support for both HTTPS and HTTP/2 over the same socket. Node core req and res objects can be either HTTP/1 or HTTP/2: const app = cmmv({ http2: true, // Enable HTTP/2 https: { allowHTTP1: true, // fallback support for HTTP1 key: readFileSync(&#x27;./cert/private-key.pem&#x27;), cert: readFileSync(&#x27;./cert/certificate.pem&#x27;), passphrase: &#x27;1234&#x27; } }); You can test your new server with: $ npx h2url https://localhost:3000 Self-Signed SSL Certificate To test HTTP/2 locally with @cmmv/server, you need an SSL certificate because browsers require HTTPS to support HTTP/2. Here’s how to generate a self-signed certificate for your localhost environment. Steps to Create a Self-Signed SSL Certificate You can use OpenSSL, which is a free and open-source tool, to generate the necessary SSL files (private key and certificate) for local development. Follow the steps below: 1. Install OpenSSL If you don’t already have OpenSSL installed, you can download and install it from here or through a package manager like brew on macOS or apt-get on Linux. For macOS: brew install openssl For Linux (Ubuntu/Debian): sudo apt-get install openssl 2. Generate a Private Key First, you need to create a private key that will be used to sign the SSL certificate. openssl genpkey -algorithm RSA -out private-key.pem -aes256 3. Create a Self-Signed Certificate Now that you have a private key, you can create the SSL certificate. openssl req -new -x509 -key private-key.pem -out certificate.pem -days 365 This command will generate a self-signed certificate named certificate.pem that’s valid for 365 days. The -subj parameter provides the necessary certificate information, such as the Common Name (CN), which should be localhost. 4. Bypass Browser Warnings (Optional) Since the certificate is self-signed, most browsers will display a security warning. To bypass this: Chrome: Navigate to chrome://flags/#allow-insecure-localhost and enable the flag that allows insecure localhost. Firefox: Click “Advanced” and then “Add Exception” when the warning appears. 5. Use the Certificate in @cmmv/server Now, you can use the generated private-key.pem and certificate.pem files in your @cmmv/server configuration as shown below: import { readFileSync } from &#x27;node:fs&#x27;; import cmmv from &#x27;@cmmv/server&#x27;; const app = cmmv({ http2: true, https: { key: readFileSync(&#x27;./cert/private-key.pem&#x27;), cert: readFileSync(&#x27;./cert/certificate.pem&#x27;), passphrase: &#x27;your-passphrase&#x27; } }); app.get(&#x27;/&#x27;, (req, res) =&gt; { res.send(&#x27;Hello, HTTP/2 with HTTPS!&#x27;); }); app.listen({ host: &#x27;0.0.0.0&#x27;, port: 3000 }) .then(server =&gt; { console.log(`HTTP/2 server running on https://localhost:3000`); }) .catch(err =&gt; { console.error(&#x27;Error starting the server:&#x27;, err); }); Now your local server will run with HTTP/2 and SSL encryption! Plain or insecure If you are building microservices, you can connect to HTTP2 in plain text, however, this is not supported by browsers. import { readFileSync } from &#x27;node:fs&#x27;; import cmmv from &#x27;@cmmv/server&#x27;; const app = cmmv({ http2: true }); app.get(&#x27;/&#x27;, (req, res) =&gt; { res.send(&#x27;Hello, HTTP/2 without HTTPS!&#x27;); }); app.listen({ host: &#x27;0.0.0.0&#x27;, port: 3000 }) .then(server =&gt; { console.log(`HTTP/2 server running on https://localhost:3000`); }) .catch(err =&gt; { console.error(&#x27;Error starting the server:&#x27;, err); }); You can test your new server with: $ npx h2url http://localhost:3000",
        "hierarchy": {
            "lvl0": "HTTP2",
            "lvl1": "Self-Signed SSL Certificate",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "server/content-parser",
        "url": "/server/content-parser.html",
        "content": "Content Type Parser One of the powerful features of the @cmmv/server framework is its ability to create and register middleware parsers that handle specific content types. Unlike traditional middleware systems (such as in Express), the middleware designed for parsing is only executed if the request’s Content-Type matches the specific type you have registered. This ensures that your application processes the request body efficiently and only when required. In this documentation, we will cover how to create generic middleware for parsing specific data types, focusing on the use of the addContentTypeParser function. This function allows you to register custom parsers for different content types. In web applications, different content types often require different parsing strategies. For example: JSON data should be parsed into JavaScript objects. XML or CSV may need special handling to parse correctly. Multipart form data may require a different strategy to extract files and fields. The addContentTypeParser function lets you register middleware to handle specific content types. This ensures that your parser is executed only when the content type matches what you defined. Steps to Create 1. Using addContentTypeParser to Register the Parser To create a custom parser, you need to call the addContentTypeParser function within your application. This function accepts the content type(s) to be parsed and the handler function that defines the parsing behavior. The handler function should always be asynchronous, as it will typically perform I/O operations like reading the request body or processing files. 2. Defining the Asynchronous Handler Function The handler function is where the actual parsing takes place. This function receives the request (req), response (res), and the raw body payload, which it processes and attaches to the req.body object. Here’s an example of how to create and register a custom parser for application/json content type using addContentTypeParser. const app = cmmv(); // Register a custom content type parser for &#x27;application/json&#x27; app.addContentTypeParser(&#x27;application/json&#x27;, async (req, res, payload) =&gt; { // Convert the raw payload (buffer) into a string const bodyString = payload.toString(&#x27;utf-8&#x27;); // Parse the string into a JavaScript object try { req.body = JSON.parse(bodyString); } catch (err) { throw new Error(&#x27;Invalid JSON payload&#x27;); } }); Registering Multiple Parsers You can register multiple parsers for different content types in your application. Here’s an example that registers parsers for both application/json and text/xml content types. import xml2js from &#x27;xml2js&#x27;; // Register a JSON parser app.addContentTypeParser(&#x27;application/json&#x27;, async (req, res, payload) =&gt; { const jsonData = payload.toString(&#x27;utf-8&#x27;); try { req.body = JSON.parse(jsonData); } catch (err) { throw new Error(&#x27;Invalid JSON payload&#x27;); } }); // Register an XML parser app.addContentTypeParser(&#x27;text/xml&#x27;, async (req, res, payload) =&gt; { const xmlData = payload.toString(&#x27;utf-8&#x27;); try { req.body = await xml2js.parseStringPromise(xmlData); } catch (err) { throw new Error(&#x27;Invalid XML payload&#x27;); } }); The addContentTypeParser method in @cmmv/server provides a powerful way to create middleware that handles specific content types, allowing for flexible and efficient request body parsing. By registering custom parsers that only trigger for their respective content types, you can improve the performance and security of your application. With asynchronous handler functions, your middleware can handle complex data parsing, such as JSON, XML, or CSV, while maintaining non-blocking operations, making the framework ideal for high-performance server applications.",
        "hierarchy": {
            "lvl0": "Content Type Parser",
            "lvl1": "Steps to Create",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "server/response",
        "url": "/server/response.html",
        "content": "Response The res object represents the HTTP response in a server-side application and is responsible for managing and sending responses back to the client. This object allows you to set status codes, headers, cookies, and more. It is an enhanced version of the standard Node.js ServerResponse object, providing additional features for greater control over the response. res object is commonly used to send various types of responses—such as HTML, JSON, or files—to the client. By convention, the res object refers to the response (and req refers to the request), but its name can be different depending on the parameters used in your callback function. Example: app.get(&#x27;/user/:id&#x27;, function (req, res) { res.send(&#x27;user &#x27; + req.params.id); }); You can also name the parameters differently, like this: app.get(&#x27;/user/:id&#x27;, function (request, response) { response.send(&#x27;user &#x27; + request.params.id); }); The res object not only supports all built-in methods and properties of Node’s core ServerResponse but also offers additional capabilities, making it easier to manage the HTTP lifecycle in modern applications. Properties res.socket Returns the request socket. console.log(res.socket); res.status Retrieves the HTTP status code of the response. console.log(res.status); // Outputs the status code res.now Returns the current timestamp in milliseconds. console.log(res.now); // Outputs the current timestamp res.elapsedTime Returns the elapsed time in milliseconds since the response started. console.log(res.elapsedTime); // Outputs the time elapsed res.sent Checks if the response has already been sent. if (res.sent) { console.log(&#x27;Response already sent&#x27;); } res.headerSent Returns true if the headers have already been sent. res.writable Returns true if the response is still writable (not ended). res.message (get/set) Retrieves the HTTP status message of the response. res.body (get/set) Returns/set the response body, Can accept different types such as string, Buffer, Object, Stream. res.length (get/set) Returns the length of the response content. / Sets the Content-Length header to n. res.status (get/set) Sets the HTTP status code for the response. res.status = 404; res.lastModified (get/set) Sets the Last-Modified header using a string or a Date. res.lastModified = new Date(); Methods res.has(field) Checks if a specific header is present in the response. if (res.has(&#x27;Content-Type&#x27;)) { console.log(&#x27;Content-Type header is set&#x27;); } res.remove(field) Removes a specific header from the response. res.remove(&#x27;Content-Type&#x27;); res.hijack() Marks the response as hijacked. res.code(code) Sets the HTTP status code and returns the response for chaining. res.code(200); res.links(links) Sets the Link header field with the given links object. res.links({ next: &#x27;http://example.com/page2&#x27;, last: &#x27;http://example.com/page5&#x27; }); res.header(field, val) Sets a header field to a specific value. res.header(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;); res.get(field) Retrieves the value of a specific header. console.log(res.get(&#x27;Content-Type&#x27;)); res.type(type) Sets the Content-Type based on the provided type. res.type(&#x27;json&#x27;); res.sendStatus(statusCode) Sends the HTTP status code with the standard message. res.sendStatus(404); res.send(payload) Sends the response with the provided payload. res.send({ message: &#x27;Hello World&#x27; }); res.json(obj) Sends a JSON response. res.json({ user: &#x27;John&#x27; }); res.jsonp(obj) Sends a JSONP response with callback support. res.sendFile(path, opt, cb) The res.sendFile() function is used to transfer the file located at a given path to the client. It automatically sets the Content-Type response header based on the file extension and triggers a callback when the file transfer is complete or if an error occurs. This method is particularly useful for serving static files or dynamically serving files in response to requests. Here’s an overview of how res.sendFile() works, along with additional options that can be used to control file serving behavior. Option Type Default Description maxAge number/string 0 Specifies the Cache-Control max-age property in milliseconds or a string (converted by ms). Used to set how long the file is cached by clients. root string undefined The root directory from which relative file paths are resolved. Without root, the path must be an absolute path. headers object {} Object containing custom headers that will be added to the response when the file is served. dotfiles string 'ignore' Determines how dotfiles (files or directories starting with a dot, like .gitignore) are handled. Can be set to 'allow', 'deny', or 'ignore'. etag boolean true Whether to generate an ETag header for the file. lastModified boolean true Whether to set the Last-Modified header for the file. cacheControl boolean true Enables or disables setting the Cache-Control header in the response. acceptRanges boolean true Allows partial content (via the Range header). This enables clients to request parts of the file, especially for video and audio streaming. immutable boolean false When set to true, adds Cache-Control: immutable to the response, indicating the file will never change and can be cached indefinitely. res.download(path, filename, opt, cb) The res.download() method is used to transfer the file located at the specified path as an attachment. This prompts the client to download the file. You can optionally provide a different filename for the downloaded file, and a callback function to handle any errors that may occur during the transfer. This method also accepts an options object similar to the one used with res.sendFile(). The Content-Disposition header is automatically set to signal that the file should be downloaded as an attachment, overriding any previously set Content-Disposition headers. Internally, this method uses res.sendFile() to handle the file transfer. res.end(payload, encoding, cb) Ends the response process. res.format(obj) Responds to the request by calling the appropriate callback from the object obj based on the Accept header. res.format({ &#x27;text/plain&#x27;: () =&gt; res.send(&#x27;Plain text&#x27;), &#x27;application/json&#x27;: () =&gt; res.json({ message: &#x27;JSON&#x27; }) }); res.vary(field) Adds the given field to the Vary header. res.vary(&#x27;Accept-Encoding&#x27;); res.attachment(filename) Sets the Content-Disposition header to attachment and sets the file name. res.append(field, val) Appends a value to a specific header. res.append(&#x27;Link&#x27;, [&#x27;&lt;http://localhost/&gt;&#x27;, &#x27;&lt;http://localhost:3000/&gt;&#x27;]); res.append(&#x27;Set-Cookie&#x27;, &#x27;foo=bar; Path=/; HttpOnly&#x27;); res.append(&#x27;Warning&#x27;, &#x27;199 Miscellaneous warning&#x27;); res.location(url) Sets the Location header to the given URL. res.location(&#x27;/foo/bar&#x27;).; res.location(&#x27;http://example.com&#x27;); res.location(&#x27;../login&#x27;); res.redirect(url, alt) Performs a 302 redirect to the specified URL. this.redirect(&#x27;back&#x27;); this.redirect(&#x27;back&#x27;, &#x27;/index.html&#x27;); this.redirect(&#x27;/login&#x27;); this.redirect(&#x27;http://google.com&#x27;); res.clearCookie(name, options) Clears the cookie with the given name. res.clearCookie(&#x27;session_id&#x27;); res.cookie(name, value, options) The res.cookie() method is used to set a cookie with a specified name and value. It allows you to define additional options to control the behavior of the cookie, such as its expiration time, security flags, and more. The method is chainable, meaning you can call it multiple times in a single response. // Set a cookie that expires in 15 minutes res.cookie(&#x27;rememberme&#x27;, &#x27;1&#x27;, { expires: new Date(Date.now() + 900000), httpOnly: true }); // Set a cookie with max-age of 15 minutes (in milliseconds) res.cookie(&#x27;rememberme&#x27;, &#x27;1&#x27;, { maxAge: 900000, httpOnly: true }); Option Type Default Description maxAge number undefined Specifies the cookie’s max-age in milliseconds. If set, it overrides the expires option. expires Date undefined Sets the cookie’s expiration date. Use maxAge as an alternative for setting relative expiration time. path string '/' Defines the URL path for which the cookie is valid. Defaults to the root path /. domain string undefined Specifies the domain for which the cookie is valid. secure boolean false Marks the cookie as secure, ensuring it is only sent over HTTPS. httpOnly boolean false Marks the cookie as HTTP-only, meaning it can’t be accessed via JavaScript in the browser. signed boolean false Indicates whether the cookie should be signed. Requires a secret to be set in cookieParser(). sameSite boolean/string false Restricts how the cookie is sent across sites. Can be 'strict', 'lax', or true (which sets to 'strict'). res.render(view, opt, cb) Renders a view template with the provided options and an optional callback function. If a callback is provided, it is executed once the view has been rendered, and no automatic response is sent. If no callback is provided, the method sends a default response with a status code of 200 and content type text/html. Example: app.get(&#x27;/about&#x27;, (req, res) =&gt; { res.render(&#x27;about&#x27;, { title: &#x27;About Us&#x27;, company: &#x27;MyCompany&#x27; }); }); Callback Example: app.get(&#x27;/custom-view&#x27;, (req, res) =&gt; { res.render(&#x27;custom&#x27;, { title: &#x27;Custom Page&#x27; }, (err, html) =&gt; { if (err) return res.status(500).send(&#x27;Error rendering the page.&#x27;); res.send(html); }); }); In this example, a custom callback function is provided. If an error occurs during rendering, the callback handles it by sending a 500 status code and error message to the client. Response Compatibility res.trailer(key, fn) Sets a trailer header with the provided key and function. res.flushHeaders() Flushes the response headers. res.getHeaderNames() Returns an array of the names of the headers currently set in the response. res.getHeaders() Returns the response headers object. res.hasHeader(name) Checks if a specific header is present in the response. res.removeHeader(name) Removes a specific header from the response. res.setTimeout(msecs, cb) Sets a timeout for the response. res.uncork() Uncorks the response stream. res.writeEarlyHints(hints, callback) Writes HTTP/1.1 103 Early Hints with the provided hints object.",
        "hierarchy": {
            "lvl0": "Response",
            "lvl1": "Properties",
            "lvl2": "res.socket",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "server/request",
        "url": "/server/request.html",
        "content": "Request The req object represents the incoming HTTP request and provides access to various properties and methods, such as the request’s query string, parameters, body, HTTP headers, and more. In this documentation, as well as by common convention, this object is referred to as req (with the HTTP response object being res). However, the actual names used for these objects can be defined by the parameters in the callback function you’re working within. Example: app.get(&#x27;/user/:id&#x27;, function (req, res) { res.send(&#x27;User: &#x27; + req.params.id); }); Alternatively, you could name the parameters differently, like this: app.get(&#x27;/user/:id&#x27;, function (request, response) { response.send(&#x27;User: &#x27; + request.params.id); }); The req object extends Node.js’s core http.IncomingMessage object, which means it inherits all the built-in properties and methods of Node’s request object. In addition, the req object includes a number of added functionalities specific to HTTP request handling in your application, making it more powerful and easier to work with. req.query Returns the parsed query string as an object. The query string is automatically parsed using the query parser (e.g., qs library). // URL: /search?name=John&amp;age=30 console.log(req.query); // { name: &#x27;John&#x27;, age: &#x27;30&#x27; } req.querystring Returns the raw query string from the URL. // URL: /search?name=John&amp;age=30 console.log(req.querystring); // &quot;name=John&amp;age=30&quot; req.search Returns the search string, which is the query string prefixed with a question mark (?). // URL: /search?name=John&amp;age=30 console.log(req.search); // &quot;?name=John&amp;age=30&quot; req.socket Returns the request socket object, which represents the underlying connection. req.protocol Returns the protocol used in the request (http or https). If the application is behind a proxy, it will also check the X-Forwarded-Proto header if the trust proxy setting is enabled. console.log(req.protocol); // &quot;https&quot; req.headers Returns the request headers as an object. console.log(req.headers[&#x27;content-type&#x27;]); // &quot;application/json&quot; req.url Returns the request URL. console.log(req.url); // &quot;/search?name=John&amp;age=30&quot; req.origin Returns the origin of the request, including the protocol and host. console.log(req.origin); // &quot;https://example.com&quot; req.href Returns the full request URL, including the origin and original URL. console.log(req.href); // &quot;https://example.com/search?name=John&amp;age=30&quot; req.secure Returns the HTTP method of the request (e.g., GET, POST, etc.). console.log(req.method); // &quot;GET&quot; req.path Returns the path of the request URL without the query string. // URL: /search?name=John console.log(req.path); // &quot;/search&quot; req.host Returns the host name from the request, considering the X-Forwarded-Host header if the trust proxy setting is enabled. console.log(req.host); // &quot;example.com&quot; req.hostname Returns the hostname from the Host header, excluding the port number. console.log(req.hostname); // &quot;example.com&quot; req.URL Returns a parsed URL object from the WHATWG URL API. req.fresh Returns true if the request is considered “fresh”, meaning the response has not changed since the last request (based on Last-Modified and/or ETag headers). req.stale Returns true if the request is considered “stale”, meaning the resource has changed since the last request. req.idempotent Returns true if the request method is idempotent (GET, HEAD, PUT, DELETE, etc.). req.ip Returns the remote IP address of the request, considering the trust proxy setting. req.ips Returns an array of IP addresses, with the client IP first, followed by any proxy addresses (when trust proxy is enabled). req.length Returns the Content-Length header value as a number if present. req.subdomains Returns an array of subdomains from the request’s hostname. The subdomains are determined by the subdomain offset setting. req.xhr Returns true if the request was made using an XMLHttpRequest (i.e., an Ajax request). req.cookies Returns the cookies sent by the client. req.signedCookies Returns the signed cookies sent by the client. req.header() Alias for req.get(). Returns the value of the specified request header field. req.header(&#x27;Content-Type&#x27;); // &quot;application/json&quot; req.get() Returns the value of the specified request header field. req.get(&#x27;Content-Type&#x27;); // &quot;application/json&quot; req.accepts() Checks if the specified MIME types are acceptable based on the Accept header. Returns the best match or undefined. req.accepts(&#x27;html&#x27;); // &quot;html&quot; req.acceptsEncodings() Checks if the specified encodings are acceptable based on the Accept-Encoding header. req.acceptsEncodings(&#x27;gzip&#x27;); // &quot;gzip&quot; req.acceptsCharsets() Checks if the specified charsets are acceptable based on the Accept-Charset header. req.acceptsCharsets(&#x27;utf-8&#x27;); // &quot;utf-8&quot; req.acceptsLanguages() Checks if the specified languages are acceptable based on the Accept-Language header. req.acceptsLanguages(&#x27;en&#x27;); // &quot;en&quot; req.range() Parses the Range header and returns an array of ranges, or -1 if unsatisfiable, or -2 if invalid. req.range(1000); // [{ start: 0, end: 999 }] req.is() Checks if the request’s Content-Type matches the specified MIME type. req.is(&#x27;json&#x27;); // &quot;json&quot;",
        "hierarchy": {
            "lvl0": "Request",
            "lvl1": "req.query",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "server/hooks",
        "url": "/server/hooks.html",
        "content": "Hooks The hook system in this server framework is designed to follow a similar lifecycle as that of Fastify but with hooks attached to the application. Hooks are functions that are executed at specific points in the request lifecycle, allowing for customizable behavior during the handling of a request. This system enables you to intercept and manipulate requests, responses, or errors at key points during the lifecycle. Each hook is attached to the application and can be defined using the addHook() method. The order in which hooks are called depends on the hook type. Below, we’ll cover three specific hooks: onRequest, preParsing, and onRequestAbort. onRequest The onRequest hook is executed right at the beginning of the request lifecycle, before any parsing of the request. This is the ideal place to perform operations such as authentication, logging, or setting up required request data. Example: app.addHook(&#x27;onRequest&#x27;, (req, res, done) =&gt; { done() }); Or async/await: app.addHook(&#x27;onRequest&#x27;, async (req, res) =&gt; { await asyncMethod() }); preParsing The preParsing hook is called after the onRequest hook, but before the request body or query parameters are parsed. It is ideal for cases where you need to manipulate or validate the raw request stream before parsing it (e.g., custom decompression or encryption). Example: app.addHook(&#x27;preParsing&#x27;, async (req, res) =&gt; { console.log(&#x27;Request is about to be parsed&#x27;); // Modify or inspect the raw request stream here }); onRequestAbort The onRequestAbort hook is triggered when the client aborts the request, typically due to a timeout or the client closing the connection before the server sends the response. This is useful for cleanup operations, such as canceling database queries or logging aborted requests. Example: app.addHook(&#x27;onRequestAbort&#x27;, async (req) =&gt; { console.log(`Request aborted: ${req.id}`); // Perform any cleanup tasks here }); onError The onError hook is triggered whenever an error occurs during the processing of a request. This hook provides an opportunity to log the error, transform it into a more meaningful response, or handle different types of errors in a custom way. Example: app.addHook(&#x27;onError&#x27;, async (error, req, res, done) =&gt; { console.error(&#x27;Error occurred:&#x27;, error); res.status(500).send({ message: &#x27;An internal error occurred&#x27; }); done(); }); onSend The onSend hook is triggered just before the response is sent to the client, after the request has been processed. This is useful for modifying the response body, headers, or performing final checks before sending the response. Example: app.addHook(&#x27;onSend&#x27;, async (req, res, payload) =&gt; { console.log(&#x27;Response is about to be sent&#x27;); // Modify the payload or headers res.setHeader(&#x27;X-Custom-Header&#x27;, &#x27;CustomValue&#x27;); return payload; // The modified or original payload to send }); onResponse The onResponse hook is executed after the response has been fully sent to the client. This is useful for logging request and response information, performing cleanup tasks, or triggering analytics. Example: app.addHook(&#x27;onResponse&#x27;, async (req, res) =&gt; { console.log(`Response sent for request ${req.id}`); // Perform any post-response tasks such as logging }); onTimeout The onTimeout hook is called when the request times out due to exceeding the allowed time for processing. This can happen when the server takes too long to respond. The hook is useful for logging timeout events or triggering alternative behavior when timeouts occur. Example: app.addHook(&#x27;onTimeout&#x27;, async (req, res) =&gt; { console.log(`Request timed out: ${req.id}`); res.status(408).send({ message: &#x27;Request Timeout&#x27; }); }); onListen The onListen hook is triggered when the server starts listening for requests on the specified port and host. It provides an opportunity to perform tasks like logging that the server has started or performing any post-startup operations. Example: app.addHook(&#x27;onListen&#x27;, async (server) =&gt; { console.log(`Server is now listening on ${server.address().port}`); }); onReady The onReady hook is called when the application is fully initialized and ready to handle incoming requests. This is useful for performing any operations that need to occur once the server is completely prepared, such as preloading data, checking system health, or logging a readiness event. Example: app.addHook(&#x27;onReady&#x27;, async () =&gt; { console.log(&#x27;Application is ready to accept requests&#x27;); }); onClose The onClose hook is triggered when the server is about to close or shut down. This is useful for cleanup tasks, such as closing database connections, releasing resources, or logging shutdown events. Example: app.addHook(&#x27;onClose&#x27;, async (server) =&gt; { console.log(&#x27;Server is shutting down&#x27;); // Perform cleanup tasks });",
        "hierarchy": {
            "lvl0": "Hooks",
            "lvl1": "onRequest",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "server/application",
        "url": "/server/application.html",
        "content": "Application The Application class is the core component that manages the server’s lifecycle, routes, and middleware. It acts as the entry point for configuring routes, applying middleware, and handling HTTP requests and responses. This class is designed to be flexible, allowing developers to define various route-handling mechanisms and middleware functions that enhance the server’s capabilities. The Application class in this system is heavily inspired by frameworks like Express, but it is designed to improve performance and add support for modern HTTP features like HTTP2. It also integrates additional middleware and optimizations such as compression and caching mechanisms. app.addRoute() The addRoute method allows the application to register specific routes with corresponding handlers. This method takes a configuration object as its parameter, which includes the HTTP method, the route path, and the handler function. The addRoute method ensures that each route is mapped properly within the internal router and can handle requests accordingly. Exemple: app.addRoute({ method: &#x27;GET&#x27;, url: &#x27;/users&#x27;, handler: (req, res) =&gt; { res.json({ users: [&#x27;John&#x27;, &#x27;Jane&#x27;] }); } }); This example registers a GET route at the /users URL, with a handler that responds with a JSON object. app.use() The use method is used to apply middleware functions to the application. Middleware functions are executed in the order they are registered, allowing for various operations such as request validation, logging, and response modifications. use can also handle sub-applications or routers, making it a powerful tool for structuring large applications into smaller components. Exemple: app.use((req, res, next) =&gt; { console.log(`${req.method} ${req.url}`); next(); // Pass control to the next middleware/route }); In this example, every incoming request is logged before passing control to the next middleware or route handler. app.render() The render method is responsible for rendering views in the application. It allows dynamic HTML templates to be rendered with data passed in by the application. This method typically works with template engines like Pug, which are registered via the app.set() method. Exemple: app.render(&#x27;email&#x27;, function (err, html) { // ... }) app.render(&#x27;email&#x27;, { name: &#x27;Tobi&#x27; }, function (err, html) { // ... }) app.route() The route method provides a mechanism to define a route handler for a specific HTTP method and path. Unlike addRoute, which directly registers the handler, route returns an object where you can chain methods for configuring the route further. Exemple: const userRoute = app.route(&#x27;GET&#x27;, &#x27;/user/:id&#x27;); userRoute.stack.push((req, res) =&gt; { res.send(`User ID: ${req.params.id}`); }); This example creates a GET route for /user/:id and registers a handler that responds with the user ID provided in the URL. The route method is especially useful when you need more control over how the route is handled, allowing for greater flexibility. app.engine() The engine method is used to register a template engine with the application for rendering dynamic views. Template engines allow HTML files to be dynamically populated with data before being served to the client. Parameters: ext: The file extension for which the engine should be registered. It can be a string representing the extension (e.g., 'ejs' or 'pug'). fn: The callback function responsible for rendering the template. This function typically accepts the file path, options, and a callback to render the view. Example: app.engine(&#x27;pug&#x27;, require(&#x27;pug&#x27;).__express); app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;); app.set() The set method is used to configure application settings. It can be used to either assign a value to a setting or retrieve the current value of a setting. Parameters: setting: The name of the setting (e.g., 'view engine', 'env', 'etag'). val: The value to assign to the setting. Example: app.set(&#x27;env&#x27;, &#x27;production&#x27;); app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;); In this example, the environment is set to 'production', and the view engine is set to 'pug'. Special Settings: 'etag': Configures the ETag generation mechanism for caching. 'query parser': Sets how the query string should be parsed. 'trust proxy': Determines if the app should trust reverse proxies. app.param() The param method is used to define route parameter preprocessing. This is useful for middleware that performs actions on specific route parameters before the request is processed. Parameters: name: The name of the route parameter, or an array of parameter names. fn: A callback function to handle the route parameter. The callback receives (req, res, next, value). Example: app.param(&#x27;id&#x27;, (req, res, next, id) =&gt; { console.log(`Received ID: ${id}`); next(); }); This example logs the id parameter whenever a route that includes :id is hit. app.path() The path method returns the application’s absolute pathname. If the application is mounted at a specific path (e.g., /admin), it will return the full mount path, including any parent application mounts. Example: const admin = express(); app.use(&#x27;/admin&#x27;, admin); console.log(admin.path()); // Outputs: &#x27;/admin&#x27; app.enabled() The enabled method checks if a specific setting is enabled (i.e., truthy). It returns true if the setting is enabled, and false if it is not. Example: app.set(&#x27;view cache&#x27;, true); console.log(app.enabled(&#x27;view cache&#x27;)); // Outputs: true app.disabled() The disabled method checks if a specific setting is disabled (i.e., falsy). It returns true if the setting is disabled, and false if it is not. Example: app.set(&#x27;view cache&#x27;, false); console.log(app.disabled(&#x27;view cache&#x27;)); // Outputs: true app.enable() The enable method enables a specific setting, making it truthy. Example: app.enable(&#x27;view cache&#x27;); console.log(app.enabled(&#x27;view cache&#x27;)); // Outputs: true app.disable() The disable method disables a specific setting, making it falsy. Example: app.disable(&#x27;view cache&#x27;); console.log(app.disabled(&#x27;view cache&#x27;)); // Outputs: true app.setErrorHandler() The setErrorHandler method sets a global error handler for the application. This handler will be invoked whenever an error occurs during request processing. The default error handler will be overridden by the one provided in this method. Example: app.setErrorHandler((error, req, res) =&gt; { console.error(&#x27;Error occurred:&#x27;, error); res.status(500).send({ error: &#x27;Internal Server Error&#x27; }); }); app.addHook() The addHook method allows you to attach hooks to specific lifecycle events during the request-response cycle. You can add hooks for events such as onSend, preSerialization, onError, and more. Example: app.addHook(&#x27;onSend&#x27;, async (request, response, payload) =&gt; { console.log(&#x27;Response being sent for URL:&#x27;, request.url); }); This example adds a hook for the onSend event that logs a message just before the response is sent to the client. app.addContentTypeParser() The addContentTypeParser method registers a custom content-type parser for handling different types of request bodies. It allows the application to parse specific content types such as XML, YAML, etc. Example: app.addContentTypeParser(&#x27;application/xml&#x27;, (req, res, body, done) =&gt; { const parsed = parseXml(body); // Custom XML parsing logic done(null, parsed); }); This example registers a custom parser for application/xml content type that converts XML into a usable JavaScript object. app.contentTypeParser() The contentTypeParser method is used internally to process incoming request bodies based on the registered content-type parsers. It finds the parser for the given content type and applies it to the request body. Example: app.contentTypeParser(&#x27;application/json&#x27;, (req, res, next) =&gt; { console.log(req.body); // Process parsed JSON body next(); }, req, res); This example processes requests with a content type of application/json and logs the parsed body. app.METHOD The app.METHOD() functions in the framework allow you to define routes based on specific HTTP methods, such as GET, PUT, POST, and DELETE. Each HTTP method corresponds to a method call on the application object, for example, app.get(), app.post(), app.put(), etc. These methods handle incoming requests by routing them to the appropriate callback based on the HTTP method and URL. While the documentation focuses primarily on the most common methods (GET, POST, PUT, DELETE), other HTTP methods like PATCH, OPTIONS, and HEAD are supported in the same way. You can define routes using any standard HTTP method by using the corresponding function on the app object. For HTTP methods that are not valid JavaScript variable names (e.g., M-SEARCH), you can use bracket notation to define the route. For example: app[&#x27;m-search&#x27;](&#x27;/&#x27;, function(req, res) { res.send(&#x27;M-SEARCH request&#x27;); }); Additionally, when defining a route with app.get(), the framework automatically handles HEAD requests for the same path, unless you explicitly define app.head() for that path. The app.all() function is special in that it routes requests of all HTTP methods to a specific path. This is not derived from any one HTTP method, making it useful for middleware or handling any type of request at a given route. For more detailed information on routing and the various HTTP methods supported, see the routing guide in the documentation. checkout copy delete get head lock merge mkactivity mkcol move m-search notify options patch post purge put report search subscribe trace unlock unsubscribe app.listen The listen() method starts the server on the specified host and port, returning a Promise that resolves when the server successfully starts listening for incoming connections, or rejects if an error occurs. Example: const listenOptions = { host: &#x27;0.0.0.0&#x27;, port: 3000 }; app.listen(listenOptions) .then(server =&gt; { const attr = server.address(); console.log(`Server is listening at ${attr.address}:${attr.port}`); }) .catch(err =&gt; { console.error(&#x27;Failed to start the server:&#x27;, err); });",
        "hierarchy": {
            "lvl0": "Application",
            "lvl1": "app.addRoute()",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    },
    {
        "objectID": "server/overview",
        "url": "/server/overview.html",
        "content": "Server The @cmmv/server is a minimalistic server written in TypeScript, designed to maintain the same structure and methods as Express, while addressing performance issues and introducing new features for efficient delivery of components and static files. This project incorporates code from Express, Koa, and Fastify, but has been completely rewritten in TypeScript with a focus on modernity and performance. Additionally, it integrates features from Vite to optimize the delivery of components and assets, ensuring a faster and more agile experience for modern applications. Due to the complexity of the project, it has been separated into another repository cmmv-server monorepo, which contains multiple packages. In addition to the core server, several modules have been implemented, including: body-parser compression cookie-parser cors etag helmet server-static Below, we will discuss each module in more detail. Currently, the project is in a testing phase and therefore not recommended for production use. Features Fully rewritten in TypeScript. Dynamic property definitions (like Object.defineProperty) were removed to avoid serious performance issues. Fastify-inspired hook system for flexible request lifecycle management. Support for HTTP/2. Compression support for Brotli, gzip, and deflate. ETag implementation using FNV-1a. Built-in support for cryptographic algorithms such as MD5, SHA-1, and others from the crypto module. Superior performance compared to Koa, Hapi, and Express, and ongoing optimization to achieve performance similar to Fastify. Full compatibility with all methods provided by Express.js. Benchmarks https://github.com/fastify/benchmarks Machine: linux x64 | 32 vCPUs | 256.6GB Mem Node: v20.17.0 Run: Thu Oct 02 2024 15:23:41 GMT+0000 (Coordinated Universal Time) Method: autocannon -c 100 -d 40 -p 10 localhost:3000 Framework Version Router Requests/s Latency (ms) Throughput/Mb polka 0.5.2 ✓ 47499.2 20.61 8.47 connect 3.7.0 ✗ 47233.6 20.70 8.42 bare v20.17.0 ✗ 46587.2 20.99 8.31 fastify 5.0.0 ✓ 46321.0 21.17 8.30 server-base-router 7.1.32 ✓ 46158.6 21.19 8.23 micro 10.0.1 ✗ 45477.4 21.55 8.11 rayo 1.4.6 ✓ 45397.6 21.59 8.10 server-base 7.1.32 ✗ 44877.0 21.85 8.00 micro-route 2.5.0 ✓ 43836.6 22.37 7.82 connect-router 1.3.8 ✓ 43080.0 22.78 7.68 cmmv 0.0.11 ✓ 41603.9 23.60 7.46 restana 4.9.9 ✓ 41601.8 23.57 7.42 hono 4.6.3 ✓ 41482.1 23.66 7.40 polkadot 1.0.0 ✗ 40766.6 24.08 7.27 0http 3.5.3 ✓ 38630.6 25.44 6.89 koa 2.15.3 ✗ 38582.8 25.46 6.88 take-five 2.0.0 ✓ 37030.6 26.59 13.31 h3 1.13.0 ✗ 36602.2 26.86 6.53 koa-isomorphic-router 1.0.1 ✓ 36570.6 26.88 6.52 h3-router 1.13.0 ✓ 35513.8 27.70 6.33 koa-router 12.0.1 ✓ 35363.8 27.84 6.31 hapi 21.3.10 ✓ 32379.0 30.42 5.77 microrouter 3.1.3 ✓ 32073.4 30.72 5.72 restify 11.1.0 ✓ 30820.4 31.97 5.56 fastify-big-json 5.0.0 ✓ 12205.6 81.42 140.44 express 5.0.0 ✓ 10808.0 91.93 1.93 express-with-middlewares 5.0.0 ✓ 9815.5 101.27 3.65 trpc-router 10.45.2 ✓ N/A N/A N/A Installation Install the @cmmv/server package via npm: $ npm install @cmmv/server @cmmv/server-static @cmmv/body-parser Quick Start Below is a simple example of how to create a new CMMV application: import cmmv, { json, urlencoded, serverStatic } from &#x27;@cmmv/server&#x27;; const app = cmmv({ /*http2: true, https: { key: readFileSync(&quot;./cert/private-key.pem&quot;), cert: readFileSync(&quot;./cert/certificate.pem&quot;), passphrase: &quot;1234&quot; }*/ }); app.use(serverStatic(&#x27;public&#x27;)); app.use(json({ limit: &#x27;50mb&#x27; })); app.use(urlencoded({ limit: &#x27;50mb&#x27;, extended: true })); app.get(&#x27;/&#x27;, async (req, res) =&gt; { res.send(&#x27;Hello World&#x27;); }); app.listen({ host: &quot;0.0.0.0&quot;, port: 3000 }) .then(server =&gt; { const addr = server.address(); console.log( `Listen on http://${addr.address}:${addr.port}`, ); }) .catch(err =&gt; { throw Error(err.message); }); Application The Application class is central to the @cmmv/server and provides a flexible foundation for managing HTTP/HTTP2 server instances, routing, middleware, and error handling. It is built on top of Node.js’s EventEmitter, and integrates features such as query parsing, content-type parsers, and HTTP method handlers. This class is responsible for managing the lifecycle of HTTP requests, routing them to the correct handlers, and applying middlewares and hooks (such as pre-parsing, on-request, and error handling). The class also supports customizable settings and error handling mechanisms. Here’s a breakdown of its features: Features: HTTP/HTTP2 Support: The Application class can create either HTTP or HTTP2 servers, supporting both regular and secure requests. Routing: Offers full routing capabilities for different HTTP methods (GET, POST, etc.) via the Router class. Middleware: Supports chaining middlewares via the use() method, including handling arrays of middlewares. Error Handling: Custom error handling through setErrorHandler that allows defining specific error-handling logic. View Rendering: Uses the View class for rendering templates. It supports custom view engines that can be registered via app.engine(). Hooks: Manages lifecycle hooks like onRequest, preParsing, onError, and more, which can be used to customize request handling. Configuration Options: Configurable server settings like timeouts, body limits, and HTTP2 support. Option Description Type Default http2 Enables HTTP2 support. When true, the server instance will use HTTP2 for communication. boolean false https Configuration for HTTPS (including keys and certificates). Required for secure HTTP2. object undefined connectionTimeout The time (in milliseconds) the server will wait before closing idle connections. number 0 keepAliveTimeout The time (in milliseconds) the server will wait for a keep-alive connection before closing it. number 72000 maxRequestsPerSocket The maximum number of requests allowed per socket. number 0 requestTimeout The time (in milliseconds) the server will wait for the request to complete before timing out. number 0 bodyLimit The maximum size (in bytes) for the request body. number 1048576 maxHeaderSize The maximum size (in bytes) for the request headers. number 16384 insecureHTTPParser Enables the use of an insecure HTTP parser that accepts non-standard HTTP requests. boolean false joinDuplicateHeaders Combines duplicate HTTP headers into a single header if set to true. boolean false querystringParser Custom query string parsing function. Must be a function if provided. function undefined serverFactory A custom function for creating the server instance, useful for advanced configurations like clustering. function undefined This table lists the configuration options available when creating an instance of the Application class, which can be used to fine-tune its behavior for different environments and use cases. import cmmv from &#x27;@cmmv/server&#x27;; const app = new cmmv({ http2: true, https: { key: fs.readFileSync(&#x27;./key.pem&#x27;), cert: fs.readFileSync(&#x27;./cert.pem&#x27;) }, requestTimeout: 30000 }); app.listen({ port: 8080, host: &#x27;0.0.0.0&#x27; }); This example creates a secure HTTP2 server using the Application class with custom request timeouts and listens on port 8080. The flexibility of the Application class allows for dynamic middleware registration, custom hooks, and full control over server behavior. Router The Router class is responsible for defining, registering, and handling routes in the @cmmv/server. It uses the find-my-way module to manage HTTP method routing, and it provides an abstraction for setting up routes using various HTTP methods (GET, POST, PUT, DELETE, etc.). By utilizing find-my-way, the Router class ensures efficient routing, supporting features such as route param handling, middleware stacking, and dynamic route resolution. This router supports all major HTTP methods and allows flexible route definitions. Features of the Router: Route Management: Allows registering routes for all HTTP methods, including custom methods like BIND, MKCOL, and more. Middleware Support: Supports middleware stacking for each route, allowing the addition of multiple handlers per route. Parameter Handlers: Provides a mechanism to handle parameters within routes via the param() method, similar to how Express handles route parameters. Dynamic Path Handling: Efficiently resolves dynamic paths and can apply multiple middlewares to the same route. Error Handling: Includes mechanisms to ensure valid route handlers are defined, with error handling for missing or invalid handlers. Compatibility: While it provides an API similar to Express.js for route definitions, it does not depend on Express and operates independently. The find-my-way library is a high-performance HTTP router that matches requests to registered routes. It provides features such as: Dynamic Routing: Supports dynamic path segments and parameters (e.g., /users/:id). Multiple Methods: Routes can be registered for any HTTP method (GET, POST, etc.). Case Sensitivity: Routes are case-insensitive by default but can be configured otherwise. Performance: Designed for efficiency, it supports fast lookup times for large numbers of routes. Middleware Stack: Allows attaching an array of middleware functions to a single route. The Router class provides methods for each HTTP method and allows route definitions. Below is a table summarizing the methods and their functionality: Method Description Example Usage acl() Registers a route for the ACL method. router.acl('/resources', handler) bind() Registers a route for the BIND method. router.bind('/binding', handler) checkout() Registers a route for the CHECKOUT method. router.checkout('/checkout', handler) connect() Registers a route for the CONNECT method. router.connect('/connect', handler) copy() Registers a route for the COPY method. router.copy('/copy', handler) delete() Registers a route for the DELETE method. router.delete('/resource/:id', handler) get() Registers a route for the GET method. Also registers HEAD by default. router.get('/users', handler) head() Registers a route for the HEAD method. router.head('/headers', handler) link() Registers a route for the LINK method. router.link('/link', handler) lock() Registers a route for the LOCK method. router.lock('/lock', handler) m-search() Registers a route for the M-SEARCH method. router['m-search']('/search', handler) merge() Registers a route for the MERGE method. router.merge('/merge', handler) mkactivity() Registers a route for the MKACTIVITY method. router.mkactivity('/activity', handler) mkcalendar() Registers a route for the MKCALENDAR method. router.mkcalendar('/calendar', handler) mkcol() Registers a route for the MKCOL method. router.mkcol('/col', handler) move() Registers a route for the MOVE method. router.move('/move', handler) notify() Registers a route for the NOTIFY method. router.notify('/notify', handler) options() Registers a route for the OPTIONS method. router.options('/options', handler) patch() Registers a route for the PATCH method. router.patch('/update', handler) post() Registers a route for the POST method. router.post('/submit', handler) propfind() Registers a route for the PROPFIND method. router.propfind('/find', handler) proppatch() Registers a route for the PROPPATCH method. router.proppatch('/patch', handler) purge() Registers a route for the PURGE method. router.purge('/purge', handler) put() Registers a route for the PUT method. router.put('/resource', handler) rebind() Registers a route for the REBIND method. router.rebind('/rebind', handler) report() Registers a route for the REPORT method. router.report('/report', handler) search() Registers a route for the SEARCH method. router.search('/search', handler) source() Registers a route for the SOURCE method. router.source('/source', handler) subscribe() Registers a route for the SUBSCRIBE method. router.subscribe('/subscribe', handler) trace() Registers a route for the TRACE method. router.trace('/trace', handler) unbind() Registers a route for the UNBIND method. router.unbind('/unbind', handler) unlink() Registers a route for the UNLINK method. router.unlink('/unlink', handler) unlock() Registers a route for the UNLOCK method. router.unlock('/unlock', handler) unsubscribe() Registers a route for the UNSUBSCRIBE method. router.unsubscribe('/unsubscribe', handler) Example // Initialize router const router = new Router(); // Register GET route router.get(&#x27;/users&#x27;, (req, res) =&gt; { res.send(&#x27;List of users&#x27;); }); // Register POST route router.post(&#x27;/users&#x27;, (req, res) =&gt; { res.send(&#x27;User created&#x27;); }); // Register PUT route router.put(&#x27;/users/:id&#x27;, (req, res) =&gt; { res.send(`User ${req.params.id} updated`); }); // Register DELETE route router.delete(&#x27;/users/:id&#x27;, (req, res) =&gt; { res.send(`User ${req.params.id} deleted`); }); In this example, the Router class is used to define routes for handling different HTTP methods such as GET, POST, PUT, and DELETE. Each route accepts a request (req) and a response (res), allowing handlers to manage incoming requests and send appropriate responses. Exemple in Application import cmmv from &#x27;@cmmv/server&#x27;; const app = cmmv(); const host = &#x27;0.0.0.0&#x27;; const port = 3000; app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;); app.get(&#x27;/view&#x27;, function (req, res) { res.render(&#x27;index&#x27;, { title: &#x27;Hey&#x27;, message: &#x27;Hello there!&#x27; }); }); app.get(&#x27;/&#x27;, async (req, res) =&gt; { res.send(&#x27;Hello World&#x27;); }); app.get(&#x27;/json&#x27;, async (req, res) =&gt; { res.json({ hello: &#x27;world&#x27; }); }); app.get(&#x27;/user/:id&#x27;, async (req, res) =&gt; { res.send(&#x27;User &#x27; + req.params.id); }); app.get(&#x27;/users&#x27;, async (req, res) =&gt; { res.json(req.query); }); app.post(&#x27;/test&#x27;, async (req, res) =&gt; { console.log(req.body); res.send(&#x27;ok&#x27;); }); app.listen({ host, port }); Static The @cmmv/server-static middleware is used to serve static files from a specified directory or directories. It is designed to handle requests for static content such as HTML, CSS, JavaScript, images, or any other assets. The middleware offers several configuration options for file serving behavior, including caching, compression, custom headers, and more. Once the middleware is initialized, it listens for requests matching the specified prefix and serves files from the root directory (or multiple directories) as configured. Option Description Type Default root Specifies the root directory (or directories) from which static files will be served. string or string[] undefined (Required) prefix URL prefix for serving static files. Files will be served from prefix + path (e.g., /static/myfile.js). string '/' maxAge Sets the Cache-Control max-age directive in milliseconds. Determines how long files should be cached by the client. number 0 cacheControl Enables or disables the Cache-Control header. When enabled, cache headers will be automatically set based on the maxAge option. boolean true dotfiles Defines how to handle dotfiles (files starting with .). Options are 'allow', 'deny', or 'ignore'. 'allow', 'deny', 'ignore' 'allow' serverDotfiles If enabled, the server will serve dotfiles from the root directory. boolean false index Specifies the default file to serve when a directory is requested. Can be a string (e.g., 'index.html') or false to disable index file serving. string or boolean 'index.html' fallthrough When true, allows requests to fall through to the next middleware if a file is not found. If false, a 404 error will be returned. boolean true redirect Redirects requests to directories that don’t end with a / by adding a trailing slash. boolean true immutable When set to true, serves files with the Cache-Control: immutable directive, indicating that the files will never change. boolean false lastModified Enables or disables the Last-Modified header. When enabled, it sets the Last-Modified header based on the file’s last modified time. boolean true etag Enables or disables the generation of ETag headers, which can be used for cache validation. boolean true extensions File extensions to try when a file is not found (e.g., serving file.html when the request is for file). Can be an array of strings. string[] or boolean false acceptRanges Enables support for HTTP range requests, useful for media streaming. boolean true preCompressed If true, the middleware will attempt to serve pre-compressed files (e.g., .br or .gz files) if available. boolean false allowedPath A function that can be used to filter or restrict access to specific paths. The function receives pathname, root, and req as parameters and returns true to allow the path or false to reject it. Function undefined setHeaders A custom function to set headers for the response. It receives res, path, and stat as parameters and can modify headers before the response is sent. Function null This middleware is not compatible with Express because its internal workings differ significantly from Express’s static file server. One major change is the removal of directory listing support. Instead, the middleware verifies existing files and creates routes at the application’s startup, resulting in improved efficiency. It leverages @fastify/send and @fastify/accept-negotiator to deliver files efficiently. Additionally, it supports add-ons like @cmmv/etag and @cmmv/compression for enhanced static file delivery, offering cache control through the use of lastModified and ETag headers. These features provide a more optimized and performant static file server compared to traditional approaches. JSON The @cmmv/body-parser middleware in cmmv-server serves as a built-in function designed to handle incoming requests with JSON payloads. Similar to Express, this middleware parses the request body and attaches the parsed data to the req.body object, making it easily accessible for further processing. This middleware specifically parses JSON data, and only processes requests where the Content-Type: application/json or application/vnd.api+json header matches the specified type option. It supports any Unicode encoding and can automatically inflate compressed requests using gzip or deflate. After the middleware runs, the parsed JSON data is available in req.body. If there’s no body to parse, the Content-Type doesn’t match, or an error occurs, req.body will be an empty object ({}). Since req.body is populated from user-provided input, it is important to note that all properties and values in the object are untrusted. They should be carefully validated before being used. For instance, attempting to access req.body.foo.toString() could result in errors if foo is undefined, not a string, or if the toString method has been overridden or replaced by malicious input. The following table outlines the options available for configuring this middleware, offering customization over its behavior to suit various application needs. Property Description Type Default inflate Enables or disables handling deflated (compressed) bodies. When disabled, deflated bodies are rejected. Boolean true limit Controls the maximum request body size. If this is a number, the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing. Mixed &quot;100kb&quot; reviver The reviver option is passed directly to JSON.parse as the second argument. It allows custom transformation of parsed JSON data. More details can be found in the MDN documentation on JSON.parse. Function null strict Enables or disables only accepting arrays and objects as valid JSON. When disabled, the middleware will accept anything that JSON.parse accepts. Boolean true type Determines the media type the middleware will parse. This can be a string, array of strings, or a function. If not a function, the value is passed directly to the type-is library and can be an extension (e.g., json), a MIME type (e.g., application/json), or a wildcard MIME type (e.g., */json). If a function, it is called as fn(req) and parses when it returns true. Mixed &quot;application/json&quot; verify If provided, this function is called as verify(req, res, buf, encoding), where buf is the raw request body. The parsing can be aborted by throwing an error from within this function. Function undefined Raw This middleware processes incoming request payloads and converts them into a Buffer, leveraging functionality inspired by body-parser. It is designed specifically to handle bodies as Buffers and only processes requests where the Content-Type: application/octet-stream or application/vnd+octets header matches the defined type option. The parser is capable of handling any Unicode encoding and supports automatic decompression for gzip and deflate encoded requests. After the middleware runs, a Buffer containing the parsed data is assigned to the req.body property. If no body is found, the Content-Type doesn’t match, or an error occurs, req.body will either default to an empty object ({}) or remain unchanged if another parser has already processed it. Since req.body is populated based on user input, it is crucial to validate any properties and values before using them. For example, calling req.body.toString() might lead to errors if req.body has been altered by multiple parsers. It is highly recommended to verify that req.body is a Buffer before performing any buffer-specific operations. The following table provides an overview of the optional configuration options: Property Description Type Default inflate Enables or disables handling deflated (compressed) bodies. When disabled, deflated bodies are rejected. Boolean true limit Controls the maximum request body size. If this is a number, it specifies the number of bytes. If it is a string, the value is passed to the bytes library for parsing. Mixed &quot;100kb&quot; type Determines the media type the middleware will parse. This can be a string, array of strings, or a function. If it’s not a function, it’s passed to the type-is library and can be an extension (e.g., bin), a MIME type (e.g., application/octet-stream), or a wildcard MIME type (e.g., application/*). Mixed &quot;application/octet-stream&quot; verify A function called as verify(req, res, buf, encoding) where buf is the raw request body and encoding is its encoding. Throwing an error from this function aborts the parsing process. Function undefined Text This middleware processes incoming request payloads by converting them into a string, utilizing functionality from the body-parser module. It provides middleware that parses all bodies as strings, only processing requests where the Content-Type: text/plain header aligns with the specified type. It handles various Unicode encodings and supports automatic decompression of gzip and deflate encodings. After the middleware runs, a new string representation of the parsed data is assigned to the req.body object. If there is no body to parse, the Content-Type does not match, or an error occurs, req.body will default to an empty object ({}). Since the structure of req.body is based on user input, it is important to treat it as untrusted. Each property and value must be validated before use. For instance, attempting to call req.body.trim() could lead to errors if req.body is not a string. Therefore, it’s advisable to ensure that req.body is a string before using string methods. The following table outlines the available configuration options: Property Description Type Default defaultCharset Specifies the default character set for the text content when the charset is not included in the Content-Type header of the request. String &quot;utf-8&quot; inflate Controls whether or not compressed (deflated) request bodies should be handled. If disabled, compressed bodies will be rejected. Boolean true limit Sets the maximum allowed size for the request body. When provided as a number, the value is treated as the number of bytes. If provided as a string, it is parsed using the bytes library. Mixed &quot;100kb&quot; type Defines the media type the middleware should parse. This option can be a string, an array of strings, or a function. If not a function, the value is passed to the type-is library and can be an extension (e.g., txt), a MIME type (e.g., text/plain), or a wildcard pattern (e.g., text/*). If a function, it is called as fn(req) and the request is parsed if it returns a truthy value. Mixed &quot;text/plain&quot; verify If provided, this function is invoked as verify(req, res, buf, encoding), where buf is the raw request body in Buffer form, and encoding is the encoding of the request. Parsing can be stopped by throwing an error within this function. Function undefined Urlencoded This middleware is designed to parse incoming requests that contain urlencoded payloads. It is based on the functionality provided by body-parser. The middleware only processes urlencoded bodies, specifically looking for requests where the Content-Type: application/x-www-form-urlencoded header matches the specified type option. This parser accepts bodies encoded in UTF-8 and supports automatic decompression for requests compressed with gzip or deflate. After the middleware processes a request, it populates the req.body object with the parsed data. If no body is found, the Content-Type doesn’t match, or an error occurs, req.body will be set to an empty object ({}). The object will contain key-value pairs, where values can either be strings or arrays (when extended: false), or any data type (when extended: true). Since req.body is populated based on user input, it is important to validate all properties and values before using them. For example, calling req.body.foo.toString() might cause errors if foo is not a string, or if it is undefined. Therefore, it is advisable to check the type of req.body values before performing any operations on them. The following table outlines the available configuration options for the middleware: Property Description Type Default extended Allows you to choose between parsing URL-encoded data with the querystring library (when false) or the qs library (when true). The “extended” syntax allows for more complex objects and arrays to be encoded into URL-encoded format. Boolean true inflate Enables or disables support for handling compressed (deflated) request bodies. If disabled, compressed bodies will be rejected. Boolean true limit Sets the maximum allowed size for the request body. If provided as a number, it specifies the number of bytes. If provided as a string, it will be parsed by the bytes library. Mixed &quot;100kb&quot; parameterLimit Controls the maximum number of parameters that can be present in the URL-encoded data. If the request exceeds this limit, an error will be thrown. Number 1000 type Defines which media types the middleware will process. This can be specified as a string, array of strings, or a function. If not a function, this value is passed to the type-is library and can be an extension (e.g., urlencoded), a MIME type (e.g., application/x-www-form-urlencoded), or a wildcard pattern. Mixed &quot;application/x-www-form-urlencoded&quot; verify A function that is invoked as verify(req, res, buf, encoding), where buf is the raw request body in Buffer form. Throwing an error from this function will stop the parsing process. Function undefined",
        "hierarchy": {
            "lvl0": "Server",
            "lvl1": "Features",
            "lvl2": "",
            "lvl3": "",
            "lvl4": "",
            "lvl5": "",
            "lvl6": ""
        },
        "anchor": "",
        "type": "content"
    }
]